{"version":3,"sources":["./node_modules/@angular/material/__ivy_ngcc__/fesm2015/autocomplete.js","./node_modules/@angular/material/__ivy_ngcc__/fesm2015/slider.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAA+D;AACkB;AACf;AAC4N;AACvD;AAC7J;AACjB;AACoB;AACD;AACzB;AAC8C;AAC5C;AACF;AACyB;AACF;;AAE1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACQ;AACN;AACK;AACH;AACK;AACM;;AAEvD;AACA,0DAA0D;AAC1D,IAAI,4DAAqB;AACzB,IAAI,0DAAmB;AACvB,IAAI,0DAAmB;AACvB,CAAC;AACD;AACA,mBAAmB,2DAAoB;AACvC,IAAI,wDAAiB;AACrB,IAAI,yDAAkB;AACtB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0EAAkB;AACpD,CAAC;AACD;AACA,6CAA6C,yDAAc;AAC3D;AACA;AACA,CAAC;AACD;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAkB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uDAAY;AAC9C;AACA,0BAA0B,uDAAY;AACtC;AACA,0BAA0B,uDAAY;AACtC;AACA,mCAAmC,uDAAY;AAC/C;AACA;AACA,sCAAsC,+BAA+B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uCAAuC;AACzD;AACA;AACA;AACA;AACA,iCAAiC,oCAAoC;AACrE;AACA,sCAAsC,4EAAqB;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wEAAiB;AAC/C;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,yEAA0B;AACzD;AACA;AACA,2CAA2C,8DAA8D;AACzG;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAC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ACA;AACA;AACA;AACA;AACA,wCAAwC,yCAAO;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4CAAK;AACrC;AACA,uBAAuB,4CAAK;AAC5B;AACA;AACA;AACA;AACA,sBAAsB,qDAAI,KAAK,0DAAS;AACxC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,mCAAmC;AACnE;AACA,qCAAqC,4EAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAAK,kEAAkE,uDAAM;AAC5F,gDAAgD,uDAAM;AACtD,YAAY,yCAAE;AACd;AACA,QAAQ,oDAAG,2BAA2B,4EAAwB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4CAAK,CAAC,gDAAS,2BAA2B,gDAAS,8BAA8B,gDAAS;AACzG,kBAAkB,uDAAM;AACxB;AACA;AACA,gCAAgC,sEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,0DAAM,KAAK,sEAAc;AACjD;AACA;AACA,6CAA6C,yDAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,4DAAQ,gBAAgB,8DAAU;AAC7E,8CAA8C,uDAAG;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,qDAAI;AACzD,qEAAqE,oDAAG;AACxE;AACA;AACA,QAAQ,sDAAK;AACb;AACA,eAAe,4CAAK;AACpB;AACA;AACA;AACA,QAAQ,0DAAS;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,qDAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gEAAc,sDAAsD,kFAAkF;AACrL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0DAAM,KAAK,sEAAc;AAChE,uCAAuC,4DAAQ,IAAI,sEAAc;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,2CAA2C,+BAA+B;AAC1E;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,mCAAmC,+BAA+B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAa;AAChC;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0EAA0E;AACvF,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,sFAAsF;AACnG,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,qFAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,gFAAwB;AAClE;AACA;AACA;AACA;AACA;AACA,oFAAoF,+CAA+C,+DAAwB,CAAC,qDAAiB,GAAG,+DAAwB,CAAC,yDAAc,GAAG,+DAAwB,CAAC,2DAAuB,GAAG,+DAAwB,CAAC,iDAAa,GAAG,+DAAwB,CAAC,4DAAwB,GAAG,+DAAwB,oCAAoC,+DAAwB,CAAC,8DAAqB,MAAM,+DAAwB,CAAC,yEAAc,MAAM,+DAAwB,CAAC,qDAAQ,MAAM,+DAAwB,CAAC,kEAAoB,GAAG,+DAAwB,uCAAuC;AAC7pB,iDAAiD,+DAAwB,EAAE,6CAA6C,gTAAgT,aAAa,kEAA2B,GAAG;AACnd;AACA,KAAK,OAAO,qDAAU,EAAE;AACxB,KAAK,OAAO,yDAAO,EAAE;AACrB,KAAK,OAAO,2DAAgB,EAAE;AAC9B,KAAK,OAAO,iDAAM,EAAE;AACpB,KAAK,OAAO,4DAAiB,EAAE;AAC/B,KAAK,gCAAgC,OAAO,iDAAM,6CAA6C,GAAG;AAClG,KAAK,OAAO,8DAAc,gBAAgB,OAAO,mDAAQ,EAAE,GAAG;AAC9D,KAAK,OAAO,uEAAY,gBAAgB,OAAO,mDAAQ,EAAE,GAAG,OAAO,iDAAM,SAAS,yEAAc,IAAI,GAAG,OAAO,+CAAI,EAAE,GAAG;AACvH,KAAK,gCAAgC,OAAO,mDAAQ,EAAE,GAAG,OAAO,iDAAM,SAAS,qDAAQ,IAAI,GAAG;AAC9F,KAAK,OAAO,kEAAa,EAAE;AAC3B,KAAK,gCAAgC,OAAO,mDAAQ,EAAE,GAAG,OAAO,iDAAM,6CAA6C;AACnH;AACA;AACA,oBAAoB,OAAO,gDAAK,8BAA8B;AAC9D,gBAAgB,OAAO,gDAAK,sCAAsC;AAClE,mBAAmB,OAAO,gDAAK,yCAAyC;AACxE,6BAA6B,OAAO,gDAAK,2BAA2B;AACpE,4BAA4B,OAAO,gDAAK,sCAAsC;AAC9E;AACA,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB,KAAK,gBAAgB,UAAU,OAAO,qDAAiB,EAAE,GAAG,OAAO,yDAAc,EAAE,GAAG,OAAO,2DAAuB,EAAE,GAAG,OAAO,iDAAa,EAAE,GAAG,OAAO,4DAAwB,EAAE,GAAG;AACtL,sBAAsB,iDAAM;AAC5B;AACA,aAAa,GAAG,GAAG,OAAO,8DAAqB;AAC/C,sBAAsB,mDAAQ;AAC9B,aAAa,GAAG,GAAG,OAAO,uEAAmB;AAC7C,sBAAsB,mDAAQ;AAC9B,aAAa;AACb,sBAAsB,iDAAM;AAC5B,uBAAuB,yEAAc;AACrC,aAAa;AACb,sBAAsB,+CAAI;AAC1B,aAAa,GAAG,GAAG;AACnB,sBAAsB,mDAAQ;AAC9B,aAAa;AACb,sBAAsB,iDAAM;AAC5B,uBAAuB,qDAAQ;AAC/B,aAAa,GAAG,GAAG,OAAO,kEAAoB,EAAE,GAAG;AACnD,sBAAsB,mDAAQ;AAC9B,aAAa;AACb,sBAAsB,iDAAM;AAC5B;AACA,aAAa,GAAG,EAAE,EAAE,GAAG;AACvB,kBAAkB,gDAAK;AACvB;AACA,SAAS;AACT,kBAAkB,gDAAK;AACvB;AACA,SAAS;AACT,kBAAkB,gDAAK;AACvB;AACA,SAAS;AACT,kBAAkB,gDAAK;AACvB;AACA,SAAS;AACT,kBAAkB,gDAAK;AACvB;AACA,SAAS,GAAG,EAAE,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yCAAyC,oDAAoD,uFAAuF,mEAA4B,wDAAwD,GAAG,EAAE;AACtU,4CAA4C,+DAAwB,EAAE,iPAAiP;AACvT,QAAQ,wDAAiB,0EAA0E,2BAA2B,EAAE,qEAAqE,yBAAyB,EAAE,6EAA6E,iCAAiC,EAAE,iFAAiF,mCAAmC,EAAE;AACtc,KAAK;AACL,QAAQ,yDAAkB;AAC1B,KAAK,EAAE,mDAAmD,gEAAyB,qCAAqC,wEAAiC,GAAG;AAC5J,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wEAAwE,2CAA2C;AACnH,2CAA2C,8DAAuB,EAAE,8BAA8B;AAClG,2CAA2C,8DAAuB,EAAE;AACpE,YAAY,+DAAa;AACzB,YAAY,mEAAe;AAC3B,YAAY,mEAAe;AAC3B,YAAY,yDAAY;AACxB,WAAW,wEAAmB;AAC9B,QAAQ,mEAAe;AACvB,QAAQ,mEAAe,GAAG;AAC1B,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,mDAAQ;AACtB;AACA;AACA,oBAAoB,+DAAa;AACjC,oBAAoB,mEAAe;AACnC,oBAAoB,mEAAe;AACnC,oBAAoB,yDAAY;AAChC;AACA;AACA;AACA;AACA;AACA,oBAAoB,wEAAmB;AACvC,oBAAoB,mEAAe;AACnC,oBAAoB,mEAAe;AACnC;AACA;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;AACtB,cAAc,oDAAoD,gEAAyB,yBAAyB,4BAA4B,yEAAyE,EAAE,wBAAwB,SAAS,+DAAa;AACzQ,QAAQ,mEAAe;AACvB,QAAQ,mEAAe;AACvB,QAAQ,yDAAY,EAAE,EAAE,wBAAwB,yEAAyE,wEAAmB;AAC5I,QAAQ,mEAAe;AACvB,QAAQ,mEAAe,EAAE,EAAE,EAAE,EAAE,EAAE;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAE+d;;AAE/d,wC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3hCyD;AAC+J;AACrH;AAClD;AACE;AACiC;AACiD;AAClF;AAC0B;AACL;AACpC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACI;AACA;AACF;;AAE1C;AACA,2BAA2B,sFAA+B,EAAE,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6DAAiB;AAC9B,iBAAiB,yDAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,qEAAa,CAAC,kEAAU,CAAC,qEAAa;AAC7D;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAY;AACtC;AACA,yBAAyB,uDAAY;AACrC;AACA;AACA;AACA;AACA;AACA,+BAA+B,uDAAY;AAC3C;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA,sCAAsC,oDAAkB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA,uBAAuB,4EAAqB;AAC5C;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,oBAAoB,2EAAoB;AACxC;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA,oBAAoB,2EAAoB;AACxC;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA,qBAAqB,2EAAoB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,yBAAyB;AAC/C,2BAA2B,oBAAoB,4EAAqB,QAAQ;AAC5E;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA,iCAAiC,2EAAoB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2EAAoB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA,yBAAyB,4EAAqB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,iBAAiB,UAAU,iBAAiB;AACxF;AACA;AACA;AACA,mCAAmC,KAAK,GAAG,KAAK,EAAE,oBAAoB,cAAc,MAAM;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,QAAQ,UAAU,QAAQ;AACtE;AACA;AACA;AACA,mCAAmC,KAAK,GAAG,KAAK,EAAE,oBAAoB,cAAc,MAAM;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK,GAAG,KAAK,EAAE,OAAO;AAC3D;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS,QAAQ,SAAS;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,KAAK,GAAG,KAAK,EAAE,aAAa,IAAI,OAAO;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,KAAK,QAAQ,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,KAAK,IAAI,OAAO;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qEAAc;AAC3C;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAO;AACxB;AACA;AACA,iBAAiB,4DAAS;AAC1B;AACA;AACA,iBAAiB,sDAAG;AACpB;AACA;AACA,iBAAiB,uDAAI;AACrB;AACA;AACA,iBAAiB,6DAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,2DAAQ;AACzB;AACA;AACA,iBAAiB,8DAAW;AAC5B;AACA;AACA;AACA,iBAAiB,6DAAU;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,6BAA6B,+DAAwB,CAAC,qDAAiB,GAAG,+DAAwB,CAAC,2DAAmB,GAAG,+DAAwB,CAAC,4DAAwB,GAAG,+DAAwB,CAAC,6DAAqB,MAAM,+DAAwB,cAAc,+DAAwB,CAAC,iDAAa,GAAG,+DAAwB,CAAC,qDAAQ,GAAG,+DAAwB,CAAC,wFAAqB,MAAM;AACxb,+BAA+B,+DAAwB,EAAE,6FAA6F;AACtJ,QAAQ,yDAAkB;AAC1B,KAAK;AACL;AACA,QAAQ,4DAAqB,MAAM,yDAAkB;AACrD,KAAK,EAAE,+IAA+I;AACtJ,QAAQ,wDAAiB,yDAAyD,uBAAuB,EAAE,wDAAwD,sBAAsB,EAAE,oEAAoE,+BAA+B,EAAE,0DAA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","file":"default-node_modules_angular_material___ivy_ngcc___fesm2015_autocomplete_js-node_modules_angu-af90d9-es2015.js","sourcesContent":["import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\r\nimport { coerceBooleanProperty, coerceStringArray } from '@angular/cdk/coercion';\r\nimport { Platform, _getEventTarget } from '@angular/cdk/platform';\r\nimport { InjectionToken, EventEmitter, Directive, ChangeDetectorRef, ElementRef, Inject, ViewChild, TemplateRef, Input, Output, Component, ViewEncapsulation, ChangeDetectionStrategy, ContentChildren, forwardRef, ViewContainerRef, NgZone, Optional, Host, NgModule } from '@angular/core';\r\nimport { mixinDisableRipple, MAT_OPTION_PARENT_COMPONENT, MAT_OPTGROUP, MatOption, MatOptionSelectionChange, _countGroupLabelsBeforeOption, _getOptionScrollPosition, MatOptionModule, MatCommonModule } from '@angular/material/core';\r\nimport { Subscription, Subject, defer, merge, of, fromEvent } from 'rxjs';\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\r\nimport { ViewportRuler, CdkScrollableModule } from '@angular/cdk/scrolling';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { ESCAPE, hasModifierKey, ENTER, UP_ARROW, DOWN_ARROW, TAB } from '@angular/cdk/keycodes';\r\nimport { TemplatePortal } from '@angular/cdk/portal';\r\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\r\nimport { MatFormField, MAT_FORM_FIELD } from '@angular/material/form-field';\r\nimport { take, switchMap, filter, map, tap, delay } from 'rxjs/operators';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Autocomplete IDs need to be unique across components, so this counter exists outside of\r\n * the component definition.\r\n */\r\nimport * as ɵngcc0 from '@angular/core';\r\nimport * as ɵngcc1 from '@angular/cdk/platform';\r\nimport * as ɵngcc2 from '@angular/common';\r\nimport * as ɵngcc3 from '@angular/cdk/overlay';\r\nimport * as ɵngcc4 from '@angular/cdk/bidi';\r\nimport * as ɵngcc5 from '@angular/cdk/scrolling';\r\nimport * as ɵngcc6 from '@angular/material/form-field';\r\n\r\nconst _c0 = [\"panel\"];\r\nfunction MatAutocomplete_ng_template_0_Template(rf, ctx) { if (rf & 1) {\r\n    ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\r\n    ɵngcc0.ɵɵprojection(2);\r\n    ɵngcc0.ɵɵelementEnd();\r\n} if (rf & 2) {\r\n    const formFieldId_r1 = ctx.id;\r\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\r\n    ɵngcc0.ɵɵproperty(\"id\", ctx_r0.id)(\"ngClass\", ctx_r0._classList);\r\n    ɵngcc0.ɵɵattribute(\"aria-label\", ctx_r0.ariaLabel || null)(\"aria-labelledby\", ctx_r0._getPanelAriaLabelledby(formFieldId_r1));\r\n} }\r\nconst _c1 = [\"*\"];\r\nlet _uniqueAutocompleteIdCounter = 0;\r\n/** Event object that is emitted when an autocomplete option is selected. */\r\nclass MatAutocompleteSelectedEvent {\r\n    constructor(\r\n    /** Reference to the autocomplete panel that emitted the event. */\r\n    source, \r\n    /** Option that was selected. */\r\n    option) {\r\n        this.source = source;\r\n        this.option = option;\r\n    }\r\n}\r\n// Boilerplate for applying mixins to MatAutocomplete.\r\n/** @docs-private */\r\nconst _MatAutocompleteMixinBase = mixinDisableRipple(class {\r\n});\r\n/** Injection token to be used to override the default options for `mat-autocomplete`. */\r\nconst MAT_AUTOCOMPLETE_DEFAULT_OPTIONS = new InjectionToken('mat-autocomplete-default-options', {\r\n    providedIn: 'root',\r\n    factory: MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY,\r\n});\r\n/** @docs-private */\r\nfunction MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY() {\r\n    return { autoActiveFirstOption: false };\r\n}\r\n/** Base class with all of the `MatAutocomplete` functionality. */\r\nclass _MatAutocompleteBase extends _MatAutocompleteMixinBase {\r\n    constructor(_changeDetectorRef, _elementRef, defaults, platform) {\r\n        super();\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._elementRef = _elementRef;\r\n        this._activeOptionChanges = Subscription.EMPTY;\r\n        /** Whether the autocomplete panel should be visible, depending on option length. */\r\n        this.showPanel = false;\r\n        this._isOpen = false;\r\n        /** Function that maps an option's control value to its display value in the trigger. */\r\n        this.displayWith = null;\r\n        /** Event that is emitted whenever an option from the list is selected. */\r\n        this.optionSelected = new EventEmitter();\r\n        /** Event that is emitted when the autocomplete panel is opened. */\r\n        this.opened = new EventEmitter();\r\n        /** Event that is emitted when the autocomplete panel is closed. */\r\n        this.closed = new EventEmitter();\r\n        /** Emits whenever an option is activated using the keyboard. */\r\n        this.optionActivated = new EventEmitter();\r\n        this._classList = {};\r\n        /** Unique ID to be used by autocomplete trigger's \"aria-owns\" property. */\r\n        this.id = `mat-autocomplete-${_uniqueAutocompleteIdCounter++}`;\r\n        // TODO(crisbeto): the problem that the `inertGroups` option resolves is only present on\r\n        // Safari using VoiceOver. We should occasionally check back to see whether the bug\r\n        // wasn't resolved in VoiceOver, and if it has, we can remove this and the `inertGroups`\r\n        // option altogether.\r\n        this.inertGroups = (platform === null || platform === void 0 ? void 0 : platform.SAFARI) || false;\r\n        this._autoActiveFirstOption = !!defaults.autoActiveFirstOption;\r\n    }\r\n    /** Whether the autocomplete panel is open. */\r\n    get isOpen() { return this._isOpen && this.showPanel; }\r\n    /**\r\n     * Whether the first option should be highlighted when the autocomplete panel is opened.\r\n     * Can be configured globally through the `MAT_AUTOCOMPLETE_DEFAULT_OPTIONS` token.\r\n     */\r\n    get autoActiveFirstOption() { return this._autoActiveFirstOption; }\r\n    set autoActiveFirstOption(value) {\r\n        this._autoActiveFirstOption = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * Takes classes set on the host mat-autocomplete element and applies them to the panel\r\n     * inside the overlay container to allow for easy styling.\r\n     */\r\n    set classList(value) {\r\n        if (value && value.length) {\r\n            this._classList = coerceStringArray(value).reduce((classList, className) => {\r\n                classList[className] = true;\r\n                return classList;\r\n            }, {});\r\n        }\r\n        else {\r\n            this._classList = {};\r\n        }\r\n        this._setVisibilityClasses(this._classList);\r\n        this._elementRef.nativeElement.className = '';\r\n    }\r\n    ngAfterContentInit() {\r\n        this._keyManager = new ActiveDescendantKeyManager(this.options).withWrap();\r\n        this._activeOptionChanges = this._keyManager.change.subscribe(index => {\r\n            if (this.isOpen) {\r\n                this.optionActivated.emit({ source: this, option: this.options.toArray()[index] || null });\r\n            }\r\n        });\r\n        // Set the initial visibility state.\r\n        this._setVisibility();\r\n    }\r\n    ngOnDestroy() {\r\n        this._activeOptionChanges.unsubscribe();\r\n    }\r\n    /**\r\n     * Sets the panel scrollTop. This allows us to manually scroll to display options\r\n     * above or below the fold, as they are not actually being focused when active.\r\n     */\r\n    _setScrollTop(scrollTop) {\r\n        if (this.panel) {\r\n            this.panel.nativeElement.scrollTop = scrollTop;\r\n        }\r\n    }\r\n    /** Returns the panel's scrollTop. */\r\n    _getScrollTop() {\r\n        return this.panel ? this.panel.nativeElement.scrollTop : 0;\r\n    }\r\n    /** Panel should hide itself when the option list is empty. */\r\n    _setVisibility() {\r\n        this.showPanel = !!this.options.length;\r\n        this._setVisibilityClasses(this._classList);\r\n        this._changeDetectorRef.markForCheck();\r\n    }\r\n    /** Emits the `select` event. */\r\n    _emitSelectEvent(option) {\r\n        const event = new MatAutocompleteSelectedEvent(this, option);\r\n        this.optionSelected.emit(event);\r\n    }\r\n    /** Gets the aria-labelledby for the autocomplete panel. */\r\n    _getPanelAriaLabelledby(labelId) {\r\n        if (this.ariaLabel) {\r\n            return null;\r\n        }\r\n        const labelExpression = labelId ? labelId + ' ' : '';\r\n        return this.ariaLabelledby ? labelExpression + this.ariaLabelledby : labelId;\r\n    }\r\n    /** Sets the autocomplete visibility classes on a classlist based on the panel is visible. */\r\n    _setVisibilityClasses(classList) {\r\n        classList[this._visibleClass] = this.showPanel;\r\n        classList[this._hiddenClass] = !this.showPanel;\r\n    }\r\n}\r\n_MatAutocompleteBase.ɵfac = function _MatAutocompleteBase_Factory(t) { return new (t || _MatAutocompleteBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.Platform)); };\r\n_MatAutocompleteBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: _MatAutocompleteBase, viewQuery: function _MatAutocompleteBase_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵviewQuery(TemplateRef, 7);\r\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.template = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.panel = _t.first);\r\n    } }, inputs: { displayWith: \"displayWith\", autoActiveFirstOption: \"autoActiveFirstOption\", classList: [\"class\", \"classList\"], ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"], panelWidth: \"panelWidth\" }, outputs: { optionSelected: \"optionSelected\", opened: \"opened\", closed: \"closed\", optionActivated: \"optionActivated\" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\r\n_MatAutocompleteBase.ctorParameters = () => [\r\n    { type: ChangeDetectorRef },\r\n    { type: ElementRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] },\r\n    { type: Platform }\r\n];\r\n_MatAutocompleteBase.propDecorators = {\r\n    template: [{ type: ViewChild, args: [TemplateRef, { static: true },] }],\r\n    panel: [{ type: ViewChild, args: ['panel',] }],\r\n    ariaLabel: [{ type: Input, args: ['aria-label',] }],\r\n    ariaLabelledby: [{ type: Input, args: ['aria-labelledby',] }],\r\n    displayWith: [{ type: Input }],\r\n    autoActiveFirstOption: [{ type: Input }],\r\n    panelWidth: [{ type: Input }],\r\n    optionSelected: [{ type: Output }],\r\n    opened: [{ type: Output }],\r\n    closed: [{ type: Output }],\r\n    optionActivated: [{ type: Output }],\r\n    classList: [{ type: Input, args: ['class',] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(_MatAutocompleteBase, [{\r\n        type: Directive\r\n    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS]\r\n            }] }, { type: ɵngcc1.Platform }]; }, { displayWith: [{\r\n            type: Input\r\n        }], optionSelected: [{\r\n            type: Output\r\n        }], opened: [{\r\n            type: Output\r\n        }], closed: [{\r\n            type: Output\r\n        }], optionActivated: [{\r\n            type: Output\r\n        }], autoActiveFirstOption: [{\r\n            type: Input\r\n        }], classList: [{\r\n            type: Input,\r\n            args: ['class']\r\n        }], template: [{\r\n            type: ViewChild,\r\n            args: [TemplateRef, { static: true }]\r\n        }], panel: [{\r\n            type: ViewChild,\r\n            args: ['panel']\r\n        }], ariaLabel: [{\r\n            type: Input,\r\n            args: ['aria-label']\r\n        }], ariaLabelledby: [{\r\n            type: Input,\r\n            args: ['aria-labelledby']\r\n        }], panelWidth: [{\r\n            type: Input\r\n        }] }); })();\r\nclass MatAutocomplete extends _MatAutocompleteBase {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._visibleClass = 'mat-autocomplete-visible';\r\n        this._hiddenClass = 'mat-autocomplete-hidden';\r\n    }\r\n}\r\nMatAutocomplete.ɵfac = /*@__PURE__*/ function () { let ɵMatAutocomplete_BaseFactory; return function MatAutocomplete_Factory(t) { return (ɵMatAutocomplete_BaseFactory || (ɵMatAutocomplete_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatAutocomplete)))(t || MatAutocomplete); }; }();\r\nMatAutocomplete.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatAutocomplete, selectors: [[\"mat-autocomplete\"]], contentQueries: function MatAutocomplete_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MAT_OPTGROUP, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatOption, 5);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.optionGroups = _t);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.options = _t);\r\n    } }, hostAttrs: [1, \"mat-autocomplete\"], inputs: { disableRipple: \"disableRipple\" }, exportAs: [\"matAutocomplete\"], features: [ɵngcc0.ɵɵProvidersFeature([\r\n            { provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }\r\n        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, consts: [[\"role\", \"listbox\", 1, \"mat-autocomplete-panel\", 3, \"id\", \"ngClass\"], [\"panel\", \"\"]], template: function MatAutocomplete_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef();\r\n        ɵngcc0.ɵɵtemplate(0, MatAutocomplete_ng_template_0_Template, 3, 4, \"ng-template\");\r\n    } }, directives: [ɵngcc2.NgClass], styles: [\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}mat-autocomplete{display:none}\\n\"], encapsulation: 2, changeDetection: 0 });\r\nMatAutocomplete.propDecorators = {\r\n    optionGroups: [{ type: ContentChildren, args: [MAT_OPTGROUP, { descendants: true },] }],\r\n    options: [{ type: ContentChildren, args: [MatOption, { descendants: true },] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatAutocomplete, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'mat-autocomplete',\r\n                template: \"<ng-template let-formFieldId=\\\"id\\\">\\n  <div class=\\\"mat-autocomplete-panel\\\"\\n       role=\\\"listbox\\\"\\n       [id]=\\\"id\\\"\\n       [attr.aria-label]=\\\"ariaLabel || null\\\"\\n       [attr.aria-labelledby]=\\\"_getPanelAriaLabelledby(formFieldId)\\\"\\n       [ngClass]=\\\"_classList\\\"\\n       #panel>\\n    <ng-content></ng-content>\\n  </div>\\n</ng-template>\\n\",\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                exportAs: 'matAutocomplete',\r\n                inputs: ['disableRipple'],\r\n                host: {\r\n                    'class': 'mat-autocomplete'\r\n                },\r\n                providers: [\r\n                    { provide: MAT_OPTION_PARENT_COMPONENT, useExisting: MatAutocomplete }\r\n                ],\r\n                styles: [\".mat-autocomplete-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;visibility:hidden;max-width:none;max-height:256px;position:relative;width:100%;border-bottom-left-radius:4px;border-bottom-right-radius:4px}.mat-autocomplete-panel.mat-autocomplete-visible{visibility:visible}.mat-autocomplete-panel.mat-autocomplete-hidden{visibility:hidden}.mat-autocomplete-panel-above .mat-autocomplete-panel{border-radius:0;border-top-left-radius:4px;border-top-right-radius:4px}.mat-autocomplete-panel .mat-divider-horizontal{margin-top:-1px}.cdk-high-contrast-active .mat-autocomplete-panel{outline:solid 1px}mat-autocomplete{display:none}\\n\"]\r\n            }]\r\n    }], null, { optionGroups: [{\r\n            type: ContentChildren,\r\n            args: [MAT_OPTGROUP, { descendants: true }]\r\n        }], options: [{\r\n            type: ContentChildren,\r\n            args: [MatOption, { descendants: true }]\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Base class containing all of the functionality for `MatAutocompleteOrigin`. */\r\nclass _MatAutocompleteOriginBase {\r\n    constructor(\r\n    /** Reference to the element on which the directive is applied. */\r\n    elementRef) {\r\n        this.elementRef = elementRef;\r\n    }\r\n}\r\n_MatAutocompleteOriginBase.ɵfac = function _MatAutocompleteOriginBase_Factory(t) { return new (t || _MatAutocompleteOriginBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };\r\n_MatAutocompleteOriginBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: _MatAutocompleteOriginBase });\r\n_MatAutocompleteOriginBase.ctorParameters = () => [\r\n    { type: ElementRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(_MatAutocompleteOriginBase, [{\r\n        type: Directive\r\n    }], function () { return [{ type: ɵngcc0.ElementRef }]; }, null); })();\r\n/**\r\n * Directive applied to an element to make it usable\r\n * as a connection point for an autocomplete panel.\r\n */\r\nclass MatAutocompleteOrigin extends _MatAutocompleteOriginBase {\r\n}\r\nMatAutocompleteOrigin.ɵfac = /*@__PURE__*/ function () { let ɵMatAutocompleteOrigin_BaseFactory; return function MatAutocompleteOrigin_Factory(t) { return (ɵMatAutocompleteOrigin_BaseFactory || (ɵMatAutocompleteOrigin_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatAutocompleteOrigin)))(t || MatAutocompleteOrigin); }; }();\r\nMatAutocompleteOrigin.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MatAutocompleteOrigin, selectors: [[\"\", \"matAutocompleteOrigin\", \"\"]], exportAs: [\"matAutocompleteOrigin\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatAutocompleteOrigin, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[matAutocompleteOrigin]',\r\n                exportAs: 'matAutocompleteOrigin'\r\n            }]\r\n    }], null, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Injection token that determines the scroll handling while the autocomplete panel is open. */\r\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY = new InjectionToken('mat-autocomplete-scroll-strategy');\r\n/** @docs-private */\r\nfunction MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY(overlay) {\r\n    return () => overlay.scrollStrategies.reposition();\r\n}\r\n/** @docs-private */\r\nconst MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER = {\r\n    provide: MAT_AUTOCOMPLETE_SCROLL_STRATEGY,\r\n    deps: [Overlay],\r\n    useFactory: MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY,\r\n};\r\n/**\r\n * Provider that allows the autocomplete to register as a ControlValueAccessor.\r\n * @docs-private\r\n */\r\nconst MAT_AUTOCOMPLETE_VALUE_ACCESSOR = {\r\n    provide: NG_VALUE_ACCESSOR,\r\n    useExisting: forwardRef(() => MatAutocompleteTrigger),\r\n    multi: true\r\n};\r\n/**\r\n * Creates an error to be thrown when attempting to use an autocomplete trigger without a panel.\r\n * @docs-private\r\n */\r\nfunction getMatAutocompleteMissingPanelError() {\r\n    return Error('Attempting to open an undefined instance of `mat-autocomplete`. ' +\r\n        'Make sure that the id passed to the `matAutocomplete` is correct and that ' +\r\n        'you\\'re attempting to open it after the ngAfterContentInit hook.');\r\n}\r\n/** Base class with all of the `MatAutocompleteTrigger` functionality. */\r\nclass _MatAutocompleteTriggerBase {\r\n    constructor(_element, _overlay, _viewContainerRef, _zone, _changeDetectorRef, scrollStrategy, _dir, _formField, _document, _viewportRuler, _defaults) {\r\n        this._element = _element;\r\n        this._overlay = _overlay;\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._zone = _zone;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._dir = _dir;\r\n        this._formField = _formField;\r\n        this._document = _document;\r\n        this._viewportRuler = _viewportRuler;\r\n        this._defaults = _defaults;\r\n        this._componentDestroyed = false;\r\n        this._autocompleteDisabled = false;\r\n        /** Whether or not the label state is being overridden. */\r\n        this._manuallyFloatingLabel = false;\r\n        /** Subscription to viewport size changes. */\r\n        this._viewportSubscription = Subscription.EMPTY;\r\n        /**\r\n         * Whether the autocomplete can open the next time it is focused. Used to prevent a focused,\r\n         * closed autocomplete from being reopened if the user switches to another browser tab and then\r\n         * comes back.\r\n         */\r\n        this._canOpenOnNextFocus = true;\r\n        /** Stream of keyboard events that can close the panel. */\r\n        this._closeKeyEventStream = new Subject();\r\n        /**\r\n         * Event handler for when the window is blurred. Needs to be an\r\n         * arrow function in order to preserve the context.\r\n         */\r\n        this._windowBlurHandler = () => {\r\n            // If the user blurred the window while the autocomplete is focused, it means that it'll be\r\n            // refocused when they come back. In this case we want to skip the first focus event, if the\r\n            // pane was closed, in order to avoid reopening it unintentionally.\r\n            this._canOpenOnNextFocus =\r\n                this._document.activeElement !== this._element.nativeElement || this.panelOpen;\r\n        };\r\n        /** `View -> model callback called when value changes` */\r\n        this._onChange = () => { };\r\n        /** `View -> model callback called when autocomplete has been touched` */\r\n        this._onTouched = () => { };\r\n        /**\r\n         * Position of the autocomplete panel relative to the trigger element. A position of `auto`\r\n         * will render the panel underneath the trigger if there is enough space for it to fit in\r\n         * the viewport, otherwise the panel will be shown above it. If the position is set to\r\n         * `above` or `below`, the panel will always be shown above or below the trigger. no matter\r\n         * whether it fits completely in the viewport.\r\n         */\r\n        this.position = 'auto';\r\n        /**\r\n         * `autocomplete` attribute to be set on the input element.\r\n         * @docs-private\r\n         */\r\n        this.autocompleteAttribute = 'off';\r\n        this._overlayAttached = false;\r\n        /** Stream of autocomplete option selections. */\r\n        this.optionSelections = defer(() => {\r\n            if (this.autocomplete && this.autocomplete.options) {\r\n                return merge(...this.autocomplete.options.map(option => option.onSelectionChange));\r\n            }\r\n            // If there are any subscribers before `ngAfterViewInit`, the `autocomplete` will be undefined.\r\n            // Return a stream that we'll replace with the real one once everything is in place.\r\n            return this._zone.onStable\r\n                .pipe(take(1), switchMap(() => this.optionSelections));\r\n        });\r\n        this._scrollStrategy = scrollStrategy;\r\n    }\r\n    /**\r\n     * Whether the autocomplete is disabled. When disabled, the element will\r\n     * act as a regular input and the user won't be able to open the panel.\r\n     */\r\n    get autocompleteDisabled() { return this._autocompleteDisabled; }\r\n    set autocompleteDisabled(value) {\r\n        this._autocompleteDisabled = coerceBooleanProperty(value);\r\n    }\r\n    ngAfterViewInit() {\r\n        const window = this._getWindow();\r\n        if (typeof window !== 'undefined') {\r\n            this._zone.runOutsideAngular(() => window.addEventListener('blur', this._windowBlurHandler));\r\n        }\r\n    }\r\n    ngOnChanges(changes) {\r\n        if (changes['position'] && this._positionStrategy) {\r\n            this._setStrategyPositions(this._positionStrategy);\r\n            if (this.panelOpen) {\r\n                this._overlayRef.updatePosition();\r\n            }\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        const window = this._getWindow();\r\n        if (typeof window !== 'undefined') {\r\n            window.removeEventListener('blur', this._windowBlurHandler);\r\n        }\r\n        this._viewportSubscription.unsubscribe();\r\n        this._componentDestroyed = true;\r\n        this._destroyPanel();\r\n        this._closeKeyEventStream.complete();\r\n    }\r\n    /** Whether or not the autocomplete panel is open. */\r\n    get panelOpen() {\r\n        return this._overlayAttached && this.autocomplete.showPanel;\r\n    }\r\n    /** Opens the autocomplete suggestion panel. */\r\n    openPanel() {\r\n        this._attachOverlay();\r\n        this._floatLabel();\r\n    }\r\n    /** Closes the autocomplete suggestion panel. */\r\n    closePanel() {\r\n        this._resetLabel();\r\n        if (!this._overlayAttached) {\r\n            return;\r\n        }\r\n        if (this.panelOpen) {\r\n            // Only emit if the panel was visible.\r\n            this.autocomplete.closed.emit();\r\n        }\r\n        this.autocomplete._isOpen = this._overlayAttached = false;\r\n        if (this._overlayRef && this._overlayRef.hasAttached()) {\r\n            this._overlayRef.detach();\r\n            this._closingActionsSubscription.unsubscribe();\r\n        }\r\n        // Note that in some cases this can end up being called after the component is destroyed.\r\n        // Add a check to ensure that we don't try to run change detection on a destroyed view.\r\n        if (!this._componentDestroyed) {\r\n            // We need to trigger change detection manually, because\r\n            // `fromEvent` doesn't seem to do it at the proper time.\r\n            // This ensures that the label is reset when the\r\n            // user clicks outside.\r\n            this._changeDetectorRef.detectChanges();\r\n        }\r\n    }\r\n    /**\r\n     * Updates the position of the autocomplete suggestion panel to ensure that it fits all options\r\n     * within the viewport.\r\n     */\r\n    updatePosition() {\r\n        if (this._overlayAttached) {\r\n            this._overlayRef.updatePosition();\r\n        }\r\n    }\r\n    /**\r\n     * A stream of actions that should close the autocomplete panel, including\r\n     * when an option is selected, on blur, and when TAB is pressed.\r\n     */\r\n    get panelClosingActions() {\r\n        return merge(this.optionSelections, this.autocomplete._keyManager.tabOut.pipe(filter(() => this._overlayAttached)), this._closeKeyEventStream, this._getOutsideClickStream(), this._overlayRef ?\r\n            this._overlayRef.detachments().pipe(filter(() => this._overlayAttached)) :\r\n            of()).pipe(\r\n        // Normalize the output so we return a consistent type.\r\n        map(event => event instanceof MatOptionSelectionChange ? event : null));\r\n    }\r\n    /** The currently active option, coerced to MatOption type. */\r\n    get activeOption() {\r\n        if (this.autocomplete && this.autocomplete._keyManager) {\r\n            return this.autocomplete._keyManager.activeItem;\r\n        }\r\n        return null;\r\n    }\r\n    /** Stream of clicks outside of the autocomplete panel. */\r\n    _getOutsideClickStream() {\r\n        return merge(fromEvent(this._document, 'click'), fromEvent(this._document, 'auxclick'), fromEvent(this._document, 'touchend'))\r\n            .pipe(filter(event => {\r\n            // If we're in the Shadow DOM, the event target will be the shadow root, so we have to\r\n            // fall back to check the first element in the path of the click event.\r\n            const clickTarget = _getEventTarget(event);\r\n            const formField = this._formField ? this._formField._elementRef.nativeElement : null;\r\n            const customOrigin = this.connectedTo ? this.connectedTo.elementRef.nativeElement : null;\r\n            return this._overlayAttached && clickTarget !== this._element.nativeElement &&\r\n                (!formField || !formField.contains(clickTarget)) &&\r\n                (!customOrigin || !customOrigin.contains(clickTarget)) &&\r\n                (!!this._overlayRef && !this._overlayRef.overlayElement.contains(clickTarget));\r\n        }));\r\n    }\r\n    // Implemented as part of ControlValueAccessor.\r\n    writeValue(value) {\r\n        Promise.resolve(null).then(() => this._setTriggerValue(value));\r\n    }\r\n    // Implemented as part of ControlValueAccessor.\r\n    registerOnChange(fn) {\r\n        this._onChange = fn;\r\n    }\r\n    // Implemented as part of ControlValueAccessor.\r\n    registerOnTouched(fn) {\r\n        this._onTouched = fn;\r\n    }\r\n    // Implemented as part of ControlValueAccessor.\r\n    setDisabledState(isDisabled) {\r\n        this._element.nativeElement.disabled = isDisabled;\r\n    }\r\n    _handleKeydown(event) {\r\n        const keyCode = event.keyCode;\r\n        // Prevent the default action on all escape key presses. This is here primarily to bring IE\r\n        // in line with other browsers. By default, pressing escape on IE will cause it to revert\r\n        // the input value to the one that it had on focus, however it won't dispatch any events\r\n        // which means that the model value will be out of sync with the view.\r\n        if (keyCode === ESCAPE && !hasModifierKey(event)) {\r\n            event.preventDefault();\r\n        }\r\n        if (this.activeOption && keyCode === ENTER && this.panelOpen) {\r\n            this.activeOption._selectViaInteraction();\r\n            this._resetActiveItem();\r\n            event.preventDefault();\r\n        }\r\n        else if (this.autocomplete) {\r\n            const prevActiveItem = this.autocomplete._keyManager.activeItem;\r\n            const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\r\n            if (this.panelOpen || keyCode === TAB) {\r\n                this.autocomplete._keyManager.onKeydown(event);\r\n            }\r\n            else if (isArrowKey && this._canOpen()) {\r\n                this.openPanel();\r\n            }\r\n            if (isArrowKey || this.autocomplete._keyManager.activeItem !== prevActiveItem) {\r\n                this._scrollToOption(this.autocomplete._keyManager.activeItemIndex || 0);\r\n            }\r\n        }\r\n    }\r\n    _handleInput(event) {\r\n        let target = event.target;\r\n        let value = target.value;\r\n        // Based on `NumberValueAccessor` from forms.\r\n        if (target.type === 'number') {\r\n            value = value == '' ? null : parseFloat(value);\r\n        }\r\n        // If the input has a placeholder, IE will fire the `input` event on page load,\r\n        // focus and blur, in addition to when the user actually changed the value. To\r\n        // filter out all of the extra events, we save the value on focus and between\r\n        // `input` events, and we check whether it changed.\r\n        // See: https://connect.microsoft.com/IE/feedback/details/885747/\r\n        if (this._previousValue !== value) {\r\n            this._previousValue = value;\r\n            this._onChange(value);\r\n            if (this._canOpen() && this._document.activeElement === event.target) {\r\n                this.openPanel();\r\n            }\r\n        }\r\n    }\r\n    _handleFocus() {\r\n        if (!this._canOpenOnNextFocus) {\r\n            this._canOpenOnNextFocus = true;\r\n        }\r\n        else if (this._canOpen()) {\r\n            this._previousValue = this._element.nativeElement.value;\r\n            this._attachOverlay();\r\n            this._floatLabel(true);\r\n        }\r\n    }\r\n    /**\r\n     * In \"auto\" mode, the label will animate down as soon as focus is lost.\r\n     * This causes the value to jump when selecting an option with the mouse.\r\n     * This method manually floats the label until the panel can be closed.\r\n     * @param shouldAnimate Whether the label should be animated when it is floated.\r\n     */\r\n    _floatLabel(shouldAnimate = false) {\r\n        if (this._formField && this._formField.floatLabel === 'auto') {\r\n            if (shouldAnimate) {\r\n                this._formField._animateAndLockLabel();\r\n            }\r\n            else {\r\n                this._formField.floatLabel = 'always';\r\n            }\r\n            this._manuallyFloatingLabel = true;\r\n        }\r\n    }\r\n    /** If the label has been manually elevated, return it to its normal state. */\r\n    _resetLabel() {\r\n        if (this._manuallyFloatingLabel) {\r\n            this._formField.floatLabel = 'auto';\r\n            this._manuallyFloatingLabel = false;\r\n        }\r\n    }\r\n    /**\r\n     * This method listens to a stream of panel closing actions and resets the\r\n     * stream every time the option list changes.\r\n     */\r\n    _subscribeToClosingActions() {\r\n        const firstStable = this._zone.onStable.pipe(take(1));\r\n        const optionChanges = this.autocomplete.options.changes.pipe(tap(() => this._positionStrategy.reapplyLastPosition()), \r\n        // Defer emitting to the stream until the next tick, because changing\r\n        // bindings in here will cause \"changed after checked\" errors.\r\n        delay(0));\r\n        // When the zone is stable initially, and when the option list changes...\r\n        return merge(firstStable, optionChanges)\r\n            .pipe(\r\n        // create a new stream of panelClosingActions, replacing any previous streams\r\n        // that were created, and flatten it so our stream only emits closing events...\r\n        switchMap(() => {\r\n            const wasOpen = this.panelOpen;\r\n            this._resetActiveItem();\r\n            this.autocomplete._setVisibility();\r\n            if (this.panelOpen) {\r\n                this._overlayRef.updatePosition();\r\n                // If the `panelOpen` state changed, we need to make sure to emit the `opened`\r\n                // event, because we may not have emitted it when the panel was attached. This\r\n                // can happen if the users opens the panel and there are no options, but the\r\n                // options come in slightly later or as a result of the value changing.\r\n                if (wasOpen !== this.panelOpen) {\r\n                    this.autocomplete.opened.emit();\r\n                }\r\n            }\r\n            return this.panelClosingActions;\r\n        }), \r\n        // when the first closing event occurs...\r\n        take(1))\r\n            // set the value, close the panel, and complete.\r\n            .subscribe(event => this._setValueAndClose(event));\r\n    }\r\n    /** Destroys the autocomplete suggestion panel. */\r\n    _destroyPanel() {\r\n        if (this._overlayRef) {\r\n            this.closePanel();\r\n            this._overlayRef.dispose();\r\n            this._overlayRef = null;\r\n        }\r\n    }\r\n    _setTriggerValue(value) {\r\n        const toDisplay = this.autocomplete && this.autocomplete.displayWith ?\r\n            this.autocomplete.displayWith(value) :\r\n            value;\r\n        // Simply falling back to an empty string if the display value is falsy does not work properly.\r\n        // The display value can also be the number zero and shouldn't fall back to an empty string.\r\n        const inputValue = toDisplay != null ? toDisplay : '';\r\n        // If it's used within a `MatFormField`, we should set it through the property so it can go\r\n        // through change detection.\r\n        if (this._formField) {\r\n            this._formField._control.value = inputValue;\r\n        }\r\n        else {\r\n            this._element.nativeElement.value = inputValue;\r\n        }\r\n        this._previousValue = inputValue;\r\n    }\r\n    /**\r\n     * This method closes the panel, and if a value is specified, also sets the associated\r\n     * control to that value. It will also mark the control as dirty if this interaction\r\n     * stemmed from the user.\r\n     */\r\n    _setValueAndClose(event) {\r\n        if (event && event.source) {\r\n            this._clearPreviousSelectedOption(event.source);\r\n            this._setTriggerValue(event.source.value);\r\n            this._onChange(event.source.value);\r\n            this._element.nativeElement.focus();\r\n            this.autocomplete._emitSelectEvent(event.source);\r\n        }\r\n        this.closePanel();\r\n    }\r\n    /**\r\n     * Clear any previous selected option and emit a selection change event for this option\r\n     */\r\n    _clearPreviousSelectedOption(skip) {\r\n        this.autocomplete.options.forEach(option => {\r\n            if (option !== skip && option.selected) {\r\n                option.deselect();\r\n            }\r\n        });\r\n    }\r\n    _attachOverlay() {\r\n        var _a;\r\n        if (!this.autocomplete && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw getMatAutocompleteMissingPanelError();\r\n        }\r\n        let overlayRef = this._overlayRef;\r\n        if (!overlayRef) {\r\n            this._portal = new TemplatePortal(this.autocomplete.template, this._viewContainerRef, { id: (_a = this._formField) === null || _a === void 0 ? void 0 : _a.getLabelId() });\r\n            overlayRef = this._overlay.create(this._getOverlayConfig());\r\n            this._overlayRef = overlayRef;\r\n            // Use the `keydownEvents` in order to take advantage of\r\n            // the overlay event targeting provided by the CDK overlay.\r\n            overlayRef.keydownEvents().subscribe(event => {\r\n                // Close when pressing ESCAPE or ALT + UP_ARROW, based on the a11y guidelines.\r\n                // See: https://www.w3.org/TR/wai-aria-practices-1.1/#textbox-keyboard-interaction\r\n                if ((event.keyCode === ESCAPE && !hasModifierKey(event)) ||\r\n                    (event.keyCode === UP_ARROW && hasModifierKey(event, 'altKey'))) {\r\n                    this._closeKeyEventStream.next();\r\n                    this._resetActiveItem();\r\n                    // We need to stop propagation, otherwise the event will eventually\r\n                    // reach the input itself and cause the overlay to be reopened.\r\n                    event.stopPropagation();\r\n                    event.preventDefault();\r\n                }\r\n            });\r\n            this._viewportSubscription = this._viewportRuler.change().subscribe(() => {\r\n                if (this.panelOpen && overlayRef) {\r\n                    overlayRef.updateSize({ width: this._getPanelWidth() });\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            // Update the trigger, panel width and direction, in case anything has changed.\r\n            this._positionStrategy.setOrigin(this._getConnectedElement());\r\n            overlayRef.updateSize({ width: this._getPanelWidth() });\r\n        }\r\n        if (overlayRef && !overlayRef.hasAttached()) {\r\n            overlayRef.attach(this._portal);\r\n            this._closingActionsSubscription = this._subscribeToClosingActions();\r\n        }\r\n        const wasOpen = this.panelOpen;\r\n        this.autocomplete._setVisibility();\r\n        this.autocomplete._isOpen = this._overlayAttached = true;\r\n        // We need to do an extra `panelOpen` check in here, because the\r\n        // autocomplete won't be shown if there are no options.\r\n        if (this.panelOpen && wasOpen !== this.panelOpen) {\r\n            this.autocomplete.opened.emit();\r\n        }\r\n    }\r\n    _getOverlayConfig() {\r\n        var _a;\r\n        return new OverlayConfig({\r\n            positionStrategy: this._getOverlayPosition(),\r\n            scrollStrategy: this._scrollStrategy(),\r\n            width: this._getPanelWidth(),\r\n            direction: this._dir,\r\n            panelClass: (_a = this._defaults) === null || _a === void 0 ? void 0 : _a.overlayPanelClass,\r\n        });\r\n    }\r\n    _getOverlayPosition() {\r\n        const strategy = this._overlay.position()\r\n            .flexibleConnectedTo(this._getConnectedElement())\r\n            .withFlexibleDimensions(false)\r\n            .withPush(false);\r\n        this._setStrategyPositions(strategy);\r\n        this._positionStrategy = strategy;\r\n        return strategy;\r\n    }\r\n    /** Sets the positions on a position strategy based on the directive's input state. */\r\n    _setStrategyPositions(positionStrategy) {\r\n        // Note that we provide horizontal fallback positions, even though by default the dropdown\r\n        // width matches the input, because consumers can override the width. See #18854.\r\n        const belowPositions = [\r\n            { originX: 'start', originY: 'bottom', overlayX: 'start', overlayY: 'top' },\r\n            { originX: 'end', originY: 'bottom', overlayX: 'end', overlayY: 'top' }\r\n        ];\r\n        // The overlay edge connected to the trigger should have squared corners, while\r\n        // the opposite end has rounded corners. We apply a CSS class to swap the\r\n        // border-radius based on the overlay position.\r\n        const panelClass = this._aboveClass;\r\n        const abovePositions = [\r\n            { originX: 'start', originY: 'top', overlayX: 'start', overlayY: 'bottom', panelClass },\r\n            { originX: 'end', originY: 'top', overlayX: 'end', overlayY: 'bottom', panelClass }\r\n        ];\r\n        let positions;\r\n        if (this.position === 'above') {\r\n            positions = abovePositions;\r\n        }\r\n        else if (this.position === 'below') {\r\n            positions = belowPositions;\r\n        }\r\n        else {\r\n            positions = [...belowPositions, ...abovePositions];\r\n        }\r\n        positionStrategy.withPositions(positions);\r\n    }\r\n    _getConnectedElement() {\r\n        if (this.connectedTo) {\r\n            return this.connectedTo.elementRef;\r\n        }\r\n        return this._formField ? this._formField.getConnectedOverlayOrigin() : this._element;\r\n    }\r\n    _getPanelWidth() {\r\n        return this.autocomplete.panelWidth || this._getHostWidth();\r\n    }\r\n    /** Returns the width of the input element, so the panel width can match it. */\r\n    _getHostWidth() {\r\n        return this._getConnectedElement().nativeElement.getBoundingClientRect().width;\r\n    }\r\n    /**\r\n     * Resets the active item to -1 so arrow events will activate the\r\n     * correct options, or to 0 if the consumer opted into it.\r\n     */\r\n    _resetActiveItem() {\r\n        const autocomplete = this.autocomplete;\r\n        if (autocomplete.autoActiveFirstOption) {\r\n            // Note that we go through `setFirstItemActive`, rather than `setActiveItem(0)`, because\r\n            // the former will find the next enabled option, if the first one is disabled.\r\n            autocomplete._keyManager.setFirstItemActive();\r\n        }\r\n        else {\r\n            autocomplete._keyManager.setActiveItem(-1);\r\n        }\r\n    }\r\n    /** Determines whether the panel can be opened. */\r\n    _canOpen() {\r\n        const element = this._element.nativeElement;\r\n        return !element.readOnly && !element.disabled && !this._autocompleteDisabled;\r\n    }\r\n    /** Use defaultView of injected document if available or fallback to global window reference */\r\n    _getWindow() {\r\n        var _a;\r\n        return ((_a = this._document) === null || _a === void 0 ? void 0 : _a.defaultView) || window;\r\n    }\r\n    /** Scrolls to a particular option in the list. */\r\n    _scrollToOption(index) {\r\n        // Given that we are not actually focusing active options, we must manually adjust scroll\r\n        // to reveal options below the fold. First, we find the offset of the option from the top\r\n        // of the panel. If that offset is below the fold, the new scrollTop will be the offset -\r\n        // the panel height + the option height, so the active option will be just visible at the\r\n        // bottom of the panel. If that offset is above the top of the visible panel, the new scrollTop\r\n        // will become the offset. If that offset is visible within the panel already, the scrollTop is\r\n        // not adjusted.\r\n        const autocomplete = this.autocomplete;\r\n        const labelCount = _countGroupLabelsBeforeOption(index, autocomplete.options, autocomplete.optionGroups);\r\n        if (index === 0 && labelCount === 1) {\r\n            // If we've got one group label before the option and we're at the top option,\r\n            // scroll the list to the top. This is better UX than scrolling the list to the\r\n            // top of the option, because it allows the user to read the top group's label.\r\n            autocomplete._setScrollTop(0);\r\n        }\r\n        else if (autocomplete.panel) {\r\n            const option = autocomplete.options.toArray()[index];\r\n            if (option) {\r\n                const element = option._getHostElement();\r\n                const newScrollPosition = _getOptionScrollPosition(element.offsetTop, element.offsetHeight, autocomplete._getScrollTop(), autocomplete.panel.nativeElement.offsetHeight);\r\n                autocomplete._setScrollTop(newScrollPosition);\r\n            }\r\n        }\r\n    }\r\n}\r\n_MatAutocompleteTriggerBase.ɵfac = function _MatAutocompleteTriggerBase_Factory(t) { return new (t || _MatAutocompleteTriggerBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(MAT_AUTOCOMPLETE_SCROLL_STRATEGY), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(MAT_FORM_FIELD, 9), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.ViewportRuler), ɵngcc0.ɵɵdirectiveInject(MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, 8)); };\r\n_MatAutocompleteTriggerBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: _MatAutocompleteTriggerBase, inputs: { position: [\"matAutocompletePosition\", \"position\"], autocompleteAttribute: [\"autocomplete\", \"autocompleteAttribute\"], autocompleteDisabled: [\"matAutocompleteDisabled\", \"autocompleteDisabled\"], autocomplete: [\"matAutocomplete\", \"autocomplete\"], connectedTo: [\"matAutocompleteConnectedTo\", \"connectedTo\"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });\r\n_MatAutocompleteTriggerBase.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: Overlay },\r\n    { type: ViewContainerRef },\r\n    { type: NgZone },\r\n    { type: ChangeDetectorRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY,] }] },\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: MatFormField, decorators: [{ type: Optional }, { type: Inject, args: [MAT_FORM_FIELD,] }, { type: Host }] },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },\r\n    { type: ViewportRuler },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS,] }] }\r\n];\r\n_MatAutocompleteTriggerBase.propDecorators = {\r\n    autocomplete: [{ type: Input, args: ['matAutocomplete',] }],\r\n    position: [{ type: Input, args: ['matAutocompletePosition',] }],\r\n    connectedTo: [{ type: Input, args: ['matAutocompleteConnectedTo',] }],\r\n    autocompleteAttribute: [{ type: Input, args: ['autocomplete',] }],\r\n    autocompleteDisabled: [{ type: Input, args: ['matAutocompleteDisabled',] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(_MatAutocompleteTriggerBase, [{\r\n        type: Directive\r\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc3.Overlay }, { type: ɵngcc0.ViewContainerRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY]\r\n            }] }, { type: ɵngcc4.Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: ɵngcc6.MatFormField, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [MAT_FORM_FIELD]\r\n            }, {\r\n                type: Host\r\n            }] }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [DOCUMENT]\r\n            }] }, { type: ɵngcc5.ViewportRuler }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [MAT_AUTOCOMPLETE_DEFAULT_OPTIONS]\r\n            }] }]; }, { position: [{\r\n            type: Input,\r\n            args: ['matAutocompletePosition']\r\n        }], autocompleteAttribute: [{\r\n            type: Input,\r\n            args: ['autocomplete']\r\n        }], autocompleteDisabled: [{\r\n            type: Input,\r\n            args: ['matAutocompleteDisabled']\r\n        }], autocomplete: [{\r\n            type: Input,\r\n            args: ['matAutocomplete']\r\n        }], connectedTo: [{\r\n            type: Input,\r\n            args: ['matAutocompleteConnectedTo']\r\n        }] }); })();\r\nclass MatAutocompleteTrigger extends _MatAutocompleteTriggerBase {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._aboveClass = 'mat-autocomplete-panel-above';\r\n    }\r\n}\r\nMatAutocompleteTrigger.ɵfac = /*@__PURE__*/ function () { let ɵMatAutocompleteTrigger_BaseFactory; return function MatAutocompleteTrigger_Factory(t) { return (ɵMatAutocompleteTrigger_BaseFactory || (ɵMatAutocompleteTrigger_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatAutocompleteTrigger)))(t || MatAutocompleteTrigger); }; }();\r\nMatAutocompleteTrigger.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MatAutocompleteTrigger, selectors: [[\"input\", \"matAutocomplete\", \"\"], [\"textarea\", \"matAutocomplete\", \"\"]], hostAttrs: [1, \"mat-autocomplete-trigger\"], hostVars: 7, hostBindings: function MatAutocompleteTrigger_HostBindings(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵlistener(\"focusin\", function MatAutocompleteTrigger_focusin_HostBindingHandler() { return ctx._handleFocus(); })(\"blur\", function MatAutocompleteTrigger_blur_HostBindingHandler() { return ctx._onTouched(); })(\"input\", function MatAutocompleteTrigger_input_HostBindingHandler($event) { return ctx._handleInput($event); })(\"keydown\", function MatAutocompleteTrigger_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); });\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵattribute(\"autocomplete\", ctx.autocompleteAttribute)(\"role\", ctx.autocompleteDisabled ? null : \"combobox\")(\"aria-autocomplete\", ctx.autocompleteDisabled ? null : \"list\")(\"aria-activedescendant\", ctx.panelOpen && ctx.activeOption ? ctx.activeOption.id : null)(\"aria-expanded\", ctx.autocompleteDisabled ? null : ctx.panelOpen.toString())(\"aria-owns\", ctx.autocompleteDisabled || !ctx.panelOpen ? null : ctx.autocomplete == null ? null : ctx.autocomplete.id)(\"aria-haspopup\", !ctx.autocompleteDisabled);\r\n    } }, exportAs: [\"matAutocompleteTrigger\"], features: [ɵngcc0.ɵɵProvidersFeature([MAT_AUTOCOMPLETE_VALUE_ACCESSOR]), ɵngcc0.ɵɵInheritDefinitionFeature] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatAutocompleteTrigger, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: `input[matAutocomplete], textarea[matAutocomplete]`,\r\n                host: {\r\n                    'class': 'mat-autocomplete-trigger',\r\n                    '[attr.autocomplete]': 'autocompleteAttribute',\r\n                    '[attr.role]': 'autocompleteDisabled ? null : \"combobox\"',\r\n                    '[attr.aria-autocomplete]': 'autocompleteDisabled ? null : \"list\"',\r\n                    '[attr.aria-activedescendant]': '(panelOpen && activeOption) ? activeOption.id : null',\r\n                    '[attr.aria-expanded]': 'autocompleteDisabled ? null : panelOpen.toString()',\r\n                    '[attr.aria-owns]': '(autocompleteDisabled || !panelOpen) ? null : autocomplete?.id',\r\n                    '[attr.aria-haspopup]': '!autocompleteDisabled',\r\n                    // Note: we use `focusin`, as opposed to `focus`, in order to open the panel\r\n                    // a little earlier. This avoids issues where IE delays the focusing of the input.\r\n                    '(focusin)': '_handleFocus()',\r\n                    '(blur)': '_onTouched()',\r\n                    '(input)': '_handleInput($event)',\r\n                    '(keydown)': '_handleKeydown($event)'\r\n                },\r\n                exportAs: 'matAutocompleteTrigger',\r\n                providers: [MAT_AUTOCOMPLETE_VALUE_ACCESSOR]\r\n            }]\r\n    }], null, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass MatAutocompleteModule {\r\n}\r\nMatAutocompleteModule.ɵfac = function MatAutocompleteModule_Factory(t) { return new (t || MatAutocompleteModule)(); };\r\nMatAutocompleteModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MatAutocompleteModule });\r\nMatAutocompleteModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER], imports: [[\r\n            OverlayModule,\r\n            MatOptionModule,\r\n            MatCommonModule,\r\n            CommonModule\r\n        ], CdkScrollableModule,\r\n        MatOptionModule,\r\n        MatCommonModule] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatAutocompleteModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [\r\n                    OverlayModule,\r\n                    MatOptionModule,\r\n                    MatCommonModule,\r\n                    CommonModule\r\n                ],\r\n                exports: [\r\n                    MatAutocomplete,\r\n                    MatAutocompleteTrigger,\r\n                    MatAutocompleteOrigin,\r\n                    CdkScrollableModule,\r\n                    MatOptionModule,\r\n                    MatCommonModule,\r\n                ],\r\n                declarations: [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin],\r\n                providers: [MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatAutocompleteModule, { declarations: function () { return [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin]; }, imports: function () { return [OverlayModule,\r\n        MatOptionModule,\r\n        MatCommonModule,\r\n        CommonModule]; }, exports: function () { return [MatAutocomplete, MatAutocompleteTrigger, MatAutocompleteOrigin, CdkScrollableModule,\r\n        MatOptionModule,\r\n        MatCommonModule]; } }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { MAT_AUTOCOMPLETE_DEFAULT_OPTIONS, MAT_AUTOCOMPLETE_DEFAULT_OPTIONS_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY, MAT_AUTOCOMPLETE_SCROLL_STRATEGY_FACTORY_PROVIDER, MAT_AUTOCOMPLETE_VALUE_ACCESSOR, MatAutocomplete, MatAutocompleteModule, MatAutocompleteOrigin, MatAutocompleteSelectedEvent, MatAutocompleteTrigger, _MatAutocompleteBase, _MatAutocompleteOriginBase, _MatAutocompleteTriggerBase, getMatAutocompleteMissingPanelError };\r\n\r\n//# sourceMappingURL=autocomplete.js.map","import { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { forwardRef, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, ElementRef, ChangeDetectorRef, Optional, Attribute, NgZone, Inject, Input, Output, ViewChild, NgModule } from '@angular/core';\r\nimport { mixinTabIndex, mixinColor, mixinDisabled, MatCommonModule } from '@angular/material/core';\r\nimport { FocusMonitor } from '@angular/cdk/a11y';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\r\nimport { hasModifierKey, DOWN_ARROW, RIGHT_ARROW, UP_ARROW, LEFT_ARROW, HOME, END, PAGE_DOWN, PAGE_UP } from '@angular/cdk/keycodes';\r\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\r\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\r\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\r\nimport { Subscription } from 'rxjs';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nimport * as ɵngcc0 from '@angular/core';\r\nimport * as ɵngcc1 from '@angular/cdk/a11y';\r\nimport * as ɵngcc2 from '@angular/cdk/bidi';\r\nimport * as ɵngcc3 from '@angular/common';\r\n\r\nconst _c0 = [\"sliderWrapper\"];\r\nconst activeEventOptions = normalizePassiveListenerOptions({ passive: false });\r\n/**\r\n * Visually, a 30px separation between tick marks looks best. This is very subjective but it is\r\n * the default separation we chose.\r\n */\r\nconst MIN_AUTO_TICK_SEPARATION = 30;\r\n/** The thumb gap size for a disabled slider. */\r\nconst DISABLED_THUMB_GAP = 7;\r\n/** The thumb gap size for a non-active slider at its minimum value. */\r\nconst MIN_VALUE_NONACTIVE_THUMB_GAP = 7;\r\n/** The thumb gap size for an active slider at its minimum value. */\r\nconst MIN_VALUE_ACTIVE_THUMB_GAP = 10;\r\n/**\r\n * Provider Expression that allows mat-slider to register as a ControlValueAccessor.\r\n * This allows it to support [(ngModel)] and [formControl].\r\n * @docs-private\r\n */\r\nconst MAT_SLIDER_VALUE_ACCESSOR = {\r\n    provide: NG_VALUE_ACCESSOR,\r\n    useExisting: forwardRef(() => MatSlider),\r\n    multi: true\r\n};\r\n/** A simple change event emitted by the MatSlider component. */\r\nclass MatSliderChange {\r\n}\r\n// Boilerplate for applying mixins to MatSlider.\r\n/** @docs-private */\r\nconst _MatSliderBase = mixinTabIndex(mixinColor(mixinDisabled(class {\r\n    constructor(_elementRef) {\r\n        this._elementRef = _elementRef;\r\n    }\r\n}), 'accent'));\r\n/**\r\n * Allows users to select from a range of values by moving the slider thumb. It is similar in\r\n * behavior to the native `<input type=\"range\">` element.\r\n */\r\nclass MatSlider extends _MatSliderBase {\r\n    constructor(elementRef, _focusMonitor, _changeDetectorRef, _dir, tabIndex, _ngZone, _document, _animationMode) {\r\n        super(elementRef);\r\n        this._focusMonitor = _focusMonitor;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._dir = _dir;\r\n        this._ngZone = _ngZone;\r\n        this._animationMode = _animationMode;\r\n        this._invert = false;\r\n        this._max = 100;\r\n        this._min = 0;\r\n        this._step = 1;\r\n        this._thumbLabel = false;\r\n        this._tickInterval = 0;\r\n        this._value = null;\r\n        this._vertical = false;\r\n        /** Event emitted when the slider value has changed. */\r\n        this.change = new EventEmitter();\r\n        /** Event emitted when the slider thumb moves. */\r\n        this.input = new EventEmitter();\r\n        /**\r\n         * Emits when the raw value of the slider changes. This is here primarily\r\n         * to facilitate the two-way binding for the `value` input.\r\n         * @docs-private\r\n         */\r\n        this.valueChange = new EventEmitter();\r\n        /** onTouch function registered via registerOnTouch (ControlValueAccessor). */\r\n        this.onTouched = () => { };\r\n        this._percent = 0;\r\n        /**\r\n         * Whether or not the thumb is sliding and what the user is using to slide it with.\r\n         * Used to determine if there should be a transition for the thumb and fill track.\r\n         */\r\n        this._isSliding = null;\r\n        /**\r\n         * Whether or not the slider is active (clicked or sliding).\r\n         * Used to shrink and grow the thumb as according to the Material Design spec.\r\n         */\r\n        this._isActive = false;\r\n        /** The size of a tick interval as a percentage of the size of the track. */\r\n        this._tickIntervalPercent = 0;\r\n        /** The dimensions of the slider. */\r\n        this._sliderDimensions = null;\r\n        this._controlValueAccessorChangeFn = () => { };\r\n        /** Subscription to the Directionality change EventEmitter. */\r\n        this._dirChangeSubscription = Subscription.EMPTY;\r\n        /** Called when the user has put their pointer down on the slider. */\r\n        this._pointerDown = (event) => {\r\n            // Don't do anything if the slider is disabled or the\r\n            // user is using anything other than the main mouse button.\r\n            if (this.disabled || this._isSliding || (!isTouchEvent(event) && event.button !== 0)) {\r\n                return;\r\n            }\r\n            this._ngZone.run(() => {\r\n                this._touchId = isTouchEvent(event) ?\r\n                    getTouchIdForSlider(event, this._elementRef.nativeElement) : undefined;\r\n                const pointerPosition = getPointerPositionOnPage(event, this._touchId);\r\n                if (pointerPosition) {\r\n                    const oldValue = this.value;\r\n                    this._isSliding = 'pointer';\r\n                    this._lastPointerEvent = event;\r\n                    event.preventDefault();\r\n                    this._focusHostElement();\r\n                    this._onMouseenter(); // Simulate mouseenter in case this is a mobile device.\r\n                    this._bindGlobalEvents(event);\r\n                    this._focusHostElement();\r\n                    this._updateValueFromPosition(pointerPosition);\r\n                    this._valueOnSlideStart = oldValue;\r\n                    // Emit a change and input event if the value changed.\r\n                    if (oldValue != this.value) {\r\n                        this._emitInputEvent();\r\n                    }\r\n                }\r\n            });\r\n        };\r\n        /**\r\n         * Called when the user has moved their pointer after\r\n         * starting to drag. Bound on the document level.\r\n         */\r\n        this._pointerMove = (event) => {\r\n            if (this._isSliding === 'pointer') {\r\n                const pointerPosition = getPointerPositionOnPage(event, this._touchId);\r\n                if (pointerPosition) {\r\n                    // Prevent the slide from selecting anything else.\r\n                    event.preventDefault();\r\n                    const oldValue = this.value;\r\n                    this._lastPointerEvent = event;\r\n                    this._updateValueFromPosition(pointerPosition);\r\n                    // Native range elements always emit `input` events when the value changed while sliding.\r\n                    if (oldValue != this.value) {\r\n                        this._emitInputEvent();\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        /** Called when the user has lifted their pointer. Bound on the document level. */\r\n        this._pointerUp = (event) => {\r\n            if (this._isSliding === 'pointer') {\r\n                if (!isTouchEvent(event) || typeof this._touchId !== 'number' ||\r\n                    // Note that we use `changedTouches`, rather than `touches` because it\r\n                    // seems like in most cases `touches` is empty for `touchend` events.\r\n                    findMatchingTouch(event.changedTouches, this._touchId)) {\r\n                    event.preventDefault();\r\n                    this._removeGlobalEvents();\r\n                    this._isSliding = null;\r\n                    this._touchId = undefined;\r\n                    if (this._valueOnSlideStart != this.value && !this.disabled) {\r\n                        this._emitChangeEvent();\r\n                    }\r\n                    this._valueOnSlideStart = this._lastPointerEvent = null;\r\n                }\r\n            }\r\n        };\r\n        /** Called when the window has lost focus. */\r\n        this._windowBlur = () => {\r\n            // If the window is blurred while dragging we need to stop dragging because the\r\n            // browser won't dispatch the `mouseup` and `touchend` events anymore.\r\n            if (this._lastPointerEvent) {\r\n                this._pointerUp(this._lastPointerEvent);\r\n            }\r\n        };\r\n        this._document = _document;\r\n        this.tabIndex = parseInt(tabIndex) || 0;\r\n        _ngZone.runOutsideAngular(() => {\r\n            const element = elementRef.nativeElement;\r\n            element.addEventListener('mousedown', this._pointerDown, activeEventOptions);\r\n            element.addEventListener('touchstart', this._pointerDown, activeEventOptions);\r\n        });\r\n    }\r\n    /** Whether the slider is inverted. */\r\n    get invert() { return this._invert; }\r\n    set invert(value) {\r\n        this._invert = coerceBooleanProperty(value);\r\n    }\r\n    /** The maximum value that the slider can have. */\r\n    get max() { return this._max; }\r\n    set max(v) {\r\n        this._max = coerceNumberProperty(v, this._max);\r\n        this._percent = this._calculatePercentage(this._value);\r\n        // Since this also modifies the percentage, we need to let the change detection know.\r\n        this._changeDetectorRef.markForCheck();\r\n    }\r\n    /** The minimum value that the slider can have. */\r\n    get min() { return this._min; }\r\n    set min(v) {\r\n        this._min = coerceNumberProperty(v, this._min);\r\n        this._percent = this._calculatePercentage(this._value);\r\n        // Since this also modifies the percentage, we need to let the change detection know.\r\n        this._changeDetectorRef.markForCheck();\r\n    }\r\n    /** The values at which the thumb will snap. */\r\n    get step() { return this._step; }\r\n    set step(v) {\r\n        this._step = coerceNumberProperty(v, this._step);\r\n        if (this._step % 1 !== 0) {\r\n            this._roundToDecimal = this._step.toString().split('.').pop().length;\r\n        }\r\n        // Since this could modify the label, we need to notify the change detection.\r\n        this._changeDetectorRef.markForCheck();\r\n    }\r\n    /** Whether or not to show the thumb label. */\r\n    get thumbLabel() { return this._thumbLabel; }\r\n    set thumbLabel(value) { this._thumbLabel = coerceBooleanProperty(value); }\r\n    /**\r\n     * How often to show ticks. Relative to the step so that a tick always appears on a step.\r\n     * Ex: Tick interval of 4 with a step of 3 will draw a tick every 4 steps (every 12 values).\r\n     */\r\n    get tickInterval() { return this._tickInterval; }\r\n    set tickInterval(value) {\r\n        if (value === 'auto') {\r\n            this._tickInterval = 'auto';\r\n        }\r\n        else if (typeof value === 'number' || typeof value === 'string') {\r\n            this._tickInterval = coerceNumberProperty(value, this._tickInterval);\r\n        }\r\n        else {\r\n            this._tickInterval = 0;\r\n        }\r\n    }\r\n    /** Value of the slider. */\r\n    get value() {\r\n        // If the value needs to be read and it is still uninitialized, initialize it to the min.\r\n        if (this._value === null) {\r\n            this.value = this._min;\r\n        }\r\n        return this._value;\r\n    }\r\n    set value(v) {\r\n        if (v !== this._value) {\r\n            let value = coerceNumberProperty(v, 0);\r\n            // While incrementing by a decimal we can end up with values like 33.300000000000004.\r\n            // Truncate it to ensure that it matches the label and to make it easier to work with.\r\n            if (this._roundToDecimal && value !== this.min && value !== this.max) {\r\n                value = parseFloat(value.toFixed(this._roundToDecimal));\r\n            }\r\n            this._value = value;\r\n            this._percent = this._calculatePercentage(this._value);\r\n            // Since this also modifies the percentage, we need to let the change detection know.\r\n            this._changeDetectorRef.markForCheck();\r\n        }\r\n    }\r\n    /** Whether the slider is vertical. */\r\n    get vertical() { return this._vertical; }\r\n    set vertical(value) {\r\n        this._vertical = coerceBooleanProperty(value);\r\n    }\r\n    /** The value to be used for display purposes. */\r\n    get displayValue() {\r\n        if (this.displayWith) {\r\n            // Value is never null but since setters and getters cannot have\r\n            // different types, the value getter is also typed to return null.\r\n            return this.displayWith(this.value);\r\n        }\r\n        // Note that this could be improved further by rounding something like 0.999 to 1 or\r\n        // 0.899 to 0.9, however it is very performance sensitive, because it gets called on\r\n        // every change detection cycle.\r\n        if (this._roundToDecimal && this.value && this.value % 1 !== 0) {\r\n            return this.value.toFixed(this._roundToDecimal);\r\n        }\r\n        return this.value || 0;\r\n    }\r\n    /** set focus to the host element */\r\n    focus(options) {\r\n        this._focusHostElement(options);\r\n    }\r\n    /** blur the host element */\r\n    blur() {\r\n        this._blurHostElement();\r\n    }\r\n    /** The percentage of the slider that coincides with the value. */\r\n    get percent() { return this._clamp(this._percent); }\r\n    /**\r\n     * Whether the axis of the slider is inverted.\r\n     * (i.e. whether moving the thumb in the positive x or y direction decreases the slider's value).\r\n     */\r\n    _shouldInvertAxis() {\r\n        // Standard non-inverted mode for a vertical slider should be dragging the thumb from bottom to\r\n        // top. However from a y-axis standpoint this is inverted.\r\n        return this.vertical ? !this.invert : this.invert;\r\n    }\r\n    /** Whether the slider is at its minimum value. */\r\n    _isMinValue() {\r\n        return this.percent === 0;\r\n    }\r\n    /**\r\n     * The amount of space to leave between the slider thumb and the track fill & track background\r\n     * elements.\r\n     */\r\n    _getThumbGap() {\r\n        if (this.disabled) {\r\n            return DISABLED_THUMB_GAP;\r\n        }\r\n        if (this._isMinValue() && !this.thumbLabel) {\r\n            return this._isActive ? MIN_VALUE_ACTIVE_THUMB_GAP : MIN_VALUE_NONACTIVE_THUMB_GAP;\r\n        }\r\n        return 0;\r\n    }\r\n    /** CSS styles for the track background element. */\r\n    _getTrackBackgroundStyles() {\r\n        const axis = this.vertical ? 'Y' : 'X';\r\n        const scale = this.vertical ? `1, ${1 - this.percent}, 1` : `${1 - this.percent}, 1, 1`;\r\n        const sign = this._shouldInvertMouseCoords() ? '-' : '';\r\n        return {\r\n            // scale3d avoids some rendering issues in Chrome. See #12071.\r\n            transform: `translate${axis}(${sign}${this._getThumbGap()}px) scale3d(${scale})`\r\n        };\r\n    }\r\n    /** CSS styles for the track fill element. */\r\n    _getTrackFillStyles() {\r\n        const percent = this.percent;\r\n        const axis = this.vertical ? 'Y' : 'X';\r\n        const scale = this.vertical ? `1, ${percent}, 1` : `${percent}, 1, 1`;\r\n        const sign = this._shouldInvertMouseCoords() ? '' : '-';\r\n        return {\r\n            // scale3d avoids some rendering issues in Chrome. See #12071.\r\n            transform: `translate${axis}(${sign}${this._getThumbGap()}px) scale3d(${scale})`,\r\n            // iOS Safari has a bug where it won't re-render elements which start of as `scale(0)` until\r\n            // something forces a style recalculation on it. Since we'll end up with `scale(0)` when\r\n            // the value of the slider is 0, we can easily get into this situation. We force a\r\n            // recalculation by changing the element's `display` when it goes from 0 to any other value.\r\n            display: percent === 0 ? 'none' : ''\r\n        };\r\n    }\r\n    /** CSS styles for the ticks container element. */\r\n    _getTicksContainerStyles() {\r\n        let axis = this.vertical ? 'Y' : 'X';\r\n        // For a horizontal slider in RTL languages we push the ticks container off the left edge\r\n        // instead of the right edge to avoid causing a horizontal scrollbar to appear.\r\n        let sign = !this.vertical && this._getDirection() == 'rtl' ? '' : '-';\r\n        let offset = this._tickIntervalPercent / 2 * 100;\r\n        return {\r\n            'transform': `translate${axis}(${sign}${offset}%)`\r\n        };\r\n    }\r\n    /** CSS styles for the ticks element. */\r\n    _getTicksStyles() {\r\n        let tickSize = this._tickIntervalPercent * 100;\r\n        let backgroundSize = this.vertical ? `2px ${tickSize}%` : `${tickSize}% 2px`;\r\n        let axis = this.vertical ? 'Y' : 'X';\r\n        // Depending on the direction we pushed the ticks container, push the ticks the opposite\r\n        // direction to re-center them but clip off the end edge. In RTL languages we need to flip the\r\n        // ticks 180 degrees so we're really cutting off the end edge abd not the start.\r\n        let sign = !this.vertical && this._getDirection() == 'rtl' ? '-' : '';\r\n        let rotate = !this.vertical && this._getDirection() == 'rtl' ? ' rotate(180deg)' : '';\r\n        let styles = {\r\n            'backgroundSize': backgroundSize,\r\n            // Without translateZ ticks sometimes jitter as the slider moves on Chrome & Firefox.\r\n            'transform': `translateZ(0) translate${axis}(${sign}${tickSize / 2}%)${rotate}`\r\n        };\r\n        if (this._isMinValue() && this._getThumbGap()) {\r\n            const shouldInvertAxis = this._shouldInvertAxis();\r\n            let side;\r\n            if (this.vertical) {\r\n                side = shouldInvertAxis ? 'Bottom' : 'Top';\r\n            }\r\n            else {\r\n                side = shouldInvertAxis ? 'Right' : 'Left';\r\n            }\r\n            styles[`padding${side}`] = `${this._getThumbGap()}px`;\r\n        }\r\n        return styles;\r\n    }\r\n    _getThumbContainerStyles() {\r\n        const shouldInvertAxis = this._shouldInvertAxis();\r\n        let axis = this.vertical ? 'Y' : 'X';\r\n        // For a horizontal slider in RTL languages we push the thumb container off the left edge\r\n        // instead of the right edge to avoid causing a horizontal scrollbar to appear.\r\n        let invertOffset = (this._getDirection() == 'rtl' && !this.vertical) ? !shouldInvertAxis : shouldInvertAxis;\r\n        let offset = (invertOffset ? this.percent : 1 - this.percent) * 100;\r\n        return {\r\n            'transform': `translate${axis}(-${offset}%)`\r\n        };\r\n    }\r\n    /**\r\n     * Whether mouse events should be converted to a slider position by calculating their distance\r\n     * from the right or bottom edge of the slider as opposed to the top or left.\r\n     */\r\n    _shouldInvertMouseCoords() {\r\n        const shouldInvertAxis = this._shouldInvertAxis();\r\n        return (this._getDirection() == 'rtl' && !this.vertical) ? !shouldInvertAxis : shouldInvertAxis;\r\n    }\r\n    /** The language direction for this slider element. */\r\n    _getDirection() {\r\n        return (this._dir && this._dir.value == 'rtl') ? 'rtl' : 'ltr';\r\n    }\r\n    ngAfterViewInit() {\r\n        this._focusMonitor\r\n            .monitor(this._elementRef, true)\r\n            .subscribe((origin) => {\r\n            this._isActive = !!origin && origin !== 'keyboard';\r\n            this._changeDetectorRef.detectChanges();\r\n        });\r\n        if (this._dir) {\r\n            this._dirChangeSubscription = this._dir.change.subscribe(() => {\r\n                this._changeDetectorRef.markForCheck();\r\n            });\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        const element = this._elementRef.nativeElement;\r\n        element.removeEventListener('mousedown', this._pointerDown, activeEventOptions);\r\n        element.removeEventListener('touchstart', this._pointerDown, activeEventOptions);\r\n        this._lastPointerEvent = null;\r\n        this._removeGlobalEvents();\r\n        this._focusMonitor.stopMonitoring(this._elementRef);\r\n        this._dirChangeSubscription.unsubscribe();\r\n    }\r\n    _onMouseenter() {\r\n        if (this.disabled) {\r\n            return;\r\n        }\r\n        // We save the dimensions of the slider here so we can use them to update the spacing of the\r\n        // ticks and determine where on the slider click and slide events happen.\r\n        this._sliderDimensions = this._getSliderDimensions();\r\n        this._updateTickIntervalPercent();\r\n    }\r\n    _onFocus() {\r\n        // We save the dimensions of the slider here so we can use them to update the spacing of the\r\n        // ticks and determine where on the slider click and slide events happen.\r\n        this._sliderDimensions = this._getSliderDimensions();\r\n        this._updateTickIntervalPercent();\r\n    }\r\n    _onBlur() {\r\n        this.onTouched();\r\n    }\r\n    _onKeydown(event) {\r\n        if (this.disabled || hasModifierKey(event) ||\r\n            (this._isSliding && this._isSliding !== 'keyboard')) {\r\n            return;\r\n        }\r\n        const oldValue = this.value;\r\n        switch (event.keyCode) {\r\n            case PAGE_UP:\r\n                this._increment(10);\r\n                break;\r\n            case PAGE_DOWN:\r\n                this._increment(-10);\r\n                break;\r\n            case END:\r\n                this.value = this.max;\r\n                break;\r\n            case HOME:\r\n                this.value = this.min;\r\n                break;\r\n            case LEFT_ARROW:\r\n                // NOTE: For a sighted user it would make more sense that when they press an arrow key on an\r\n                // inverted slider the thumb moves in that direction. However for a blind user, nothing\r\n                // about the slider indicates that it is inverted. They will expect left to be decrement,\r\n                // regardless of how it appears on the screen. For speakers ofRTL languages, they probably\r\n                // expect left to mean increment. Therefore we flip the meaning of the side arrow keys for\r\n                // RTL. For inverted sliders we prefer a good a11y experience to having it \"look right\" for\r\n                // sighted users, therefore we do not swap the meaning.\r\n                this._increment(this._getDirection() == 'rtl' ? 1 : -1);\r\n                break;\r\n            case UP_ARROW:\r\n                this._increment(1);\r\n                break;\r\n            case RIGHT_ARROW:\r\n                // See comment on LEFT_ARROW about the conditions under which we flip the meaning.\r\n                this._increment(this._getDirection() == 'rtl' ? -1 : 1);\r\n                break;\r\n            case DOWN_ARROW:\r\n                this._increment(-1);\r\n                break;\r\n            default:\r\n                // Return if the key is not one that we explicitly handle to avoid calling preventDefault on\r\n                // it.\r\n                return;\r\n        }\r\n        if (oldValue != this.value) {\r\n            this._emitInputEvent();\r\n            this._emitChangeEvent();\r\n        }\r\n        this._isSliding = 'keyboard';\r\n        event.preventDefault();\r\n    }\r\n    _onKeyup() {\r\n        if (this._isSliding === 'keyboard') {\r\n            this._isSliding = null;\r\n        }\r\n    }\r\n    /** Use defaultView of injected document if available or fallback to global window reference */\r\n    _getWindow() {\r\n        return this._document.defaultView || window;\r\n    }\r\n    /**\r\n     * Binds our global move and end events. They're bound at the document level and only while\r\n     * dragging so that the user doesn't have to keep their pointer exactly over the slider\r\n     * as they're swiping across the screen.\r\n     */\r\n    _bindGlobalEvents(triggerEvent) {\r\n        // Note that we bind the events to the `document`, because it allows us to capture\r\n        // drag cancel events where the user's pointer is outside the browser window.\r\n        const document = this._document;\r\n        const isTouch = isTouchEvent(triggerEvent);\r\n        const moveEventName = isTouch ? 'touchmove' : 'mousemove';\r\n        const endEventName = isTouch ? 'touchend' : 'mouseup';\r\n        document.addEventListener(moveEventName, this._pointerMove, activeEventOptions);\r\n        document.addEventListener(endEventName, this._pointerUp, activeEventOptions);\r\n        if (isTouch) {\r\n            document.addEventListener('touchcancel', this._pointerUp, activeEventOptions);\r\n        }\r\n        const window = this._getWindow();\r\n        if (typeof window !== 'undefined' && window) {\r\n            window.addEventListener('blur', this._windowBlur);\r\n        }\r\n    }\r\n    /** Removes any global event listeners that we may have added. */\r\n    _removeGlobalEvents() {\r\n        const document = this._document;\r\n        document.removeEventListener('mousemove', this._pointerMove, activeEventOptions);\r\n        document.removeEventListener('mouseup', this._pointerUp, activeEventOptions);\r\n        document.removeEventListener('touchmove', this._pointerMove, activeEventOptions);\r\n        document.removeEventListener('touchend', this._pointerUp, activeEventOptions);\r\n        document.removeEventListener('touchcancel', this._pointerUp, activeEventOptions);\r\n        const window = this._getWindow();\r\n        if (typeof window !== 'undefined' && window) {\r\n            window.removeEventListener('blur', this._windowBlur);\r\n        }\r\n    }\r\n    /** Increments the slider by the given number of steps (negative number decrements). */\r\n    _increment(numSteps) {\r\n        this.value = this._clamp((this.value || 0) + this.step * numSteps, this.min, this.max);\r\n    }\r\n    /** Calculate the new value from the new physical location. The value will always be snapped. */\r\n    _updateValueFromPosition(pos) {\r\n        if (!this._sliderDimensions) {\r\n            return;\r\n        }\r\n        let offset = this.vertical ? this._sliderDimensions.top : this._sliderDimensions.left;\r\n        let size = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;\r\n        let posComponent = this.vertical ? pos.y : pos.x;\r\n        // The exact value is calculated from the event and used to find the closest snap value.\r\n        let percent = this._clamp((posComponent - offset) / size);\r\n        if (this._shouldInvertMouseCoords()) {\r\n            percent = 1 - percent;\r\n        }\r\n        // Since the steps may not divide cleanly into the max value, if the user\r\n        // slid to 0 or 100 percent, we jump to the min/max value. This approach\r\n        // is slightly more intuitive than using `Math.ceil` below, because it\r\n        // follows the user's pointer closer.\r\n        if (percent === 0) {\r\n            this.value = this.min;\r\n        }\r\n        else if (percent === 1) {\r\n            this.value = this.max;\r\n        }\r\n        else {\r\n            const exactValue = this._calculateValue(percent);\r\n            // This calculation finds the closest step by finding the closest\r\n            // whole number divisible by the step relative to the min.\r\n            const closestValue = Math.round((exactValue - this.min) / this.step) * this.step + this.min;\r\n            // The value needs to snap to the min and max.\r\n            this.value = this._clamp(closestValue, this.min, this.max);\r\n        }\r\n    }\r\n    /** Emits a change event if the current value is different from the last emitted value. */\r\n    _emitChangeEvent() {\r\n        this._controlValueAccessorChangeFn(this.value);\r\n        this.valueChange.emit(this.value);\r\n        this.change.emit(this._createChangeEvent());\r\n    }\r\n    /** Emits an input event when the current value is different from the last emitted value. */\r\n    _emitInputEvent() {\r\n        this.input.emit(this._createChangeEvent());\r\n    }\r\n    /** Updates the amount of space between ticks as a percentage of the width of the slider. */\r\n    _updateTickIntervalPercent() {\r\n        if (!this.tickInterval || !this._sliderDimensions) {\r\n            return;\r\n        }\r\n        if (this.tickInterval == 'auto') {\r\n            let trackSize = this.vertical ? this._sliderDimensions.height : this._sliderDimensions.width;\r\n            let pixelsPerStep = trackSize * this.step / (this.max - this.min);\r\n            let stepsPerTick = Math.ceil(MIN_AUTO_TICK_SEPARATION / pixelsPerStep);\r\n            let pixelsPerTick = stepsPerTick * this.step;\r\n            this._tickIntervalPercent = pixelsPerTick / trackSize;\r\n        }\r\n        else {\r\n            this._tickIntervalPercent = this.tickInterval * this.step / (this.max - this.min);\r\n        }\r\n    }\r\n    /** Creates a slider change object from the specified value. */\r\n    _createChangeEvent(value = this.value) {\r\n        let event = new MatSliderChange();\r\n        event.source = this;\r\n        event.value = value;\r\n        return event;\r\n    }\r\n    /** Calculates the percentage of the slider that a value is. */\r\n    _calculatePercentage(value) {\r\n        return ((value || 0) - this.min) / (this.max - this.min);\r\n    }\r\n    /** Calculates the value a percentage of the slider corresponds to. */\r\n    _calculateValue(percentage) {\r\n        return this.min + percentage * (this.max - this.min);\r\n    }\r\n    /** Return a number between two numbers. */\r\n    _clamp(value, min = 0, max = 1) {\r\n        return Math.max(min, Math.min(value, max));\r\n    }\r\n    /**\r\n     * Get the bounding client rect of the slider track element.\r\n     * The track is used rather than the native element to ignore the extra space that the thumb can\r\n     * take up.\r\n     */\r\n    _getSliderDimensions() {\r\n        return this._sliderWrapper ? this._sliderWrapper.nativeElement.getBoundingClientRect() : null;\r\n    }\r\n    /**\r\n     * Focuses the native element.\r\n     * Currently only used to allow a blur event to fire but will be used with keyboard input later.\r\n     */\r\n    _focusHostElement(options) {\r\n        this._elementRef.nativeElement.focus(options);\r\n    }\r\n    /** Blurs the native element. */\r\n    _blurHostElement() {\r\n        this._elementRef.nativeElement.blur();\r\n    }\r\n    /**\r\n     * Sets the model value. Implemented as part of ControlValueAccessor.\r\n     * @param value\r\n     */\r\n    writeValue(value) {\r\n        this.value = value;\r\n    }\r\n    /**\r\n     * Registers a callback to be triggered when the value has changed.\r\n     * Implemented as part of ControlValueAccessor.\r\n     * @param fn Callback to be registered.\r\n     */\r\n    registerOnChange(fn) {\r\n        this._controlValueAccessorChangeFn = fn;\r\n    }\r\n    /**\r\n     * Registers a callback to be triggered when the component is touched.\r\n     * Implemented as part of ControlValueAccessor.\r\n     * @param fn Callback to be registered.\r\n     */\r\n    registerOnTouched(fn) {\r\n        this.onTouched = fn;\r\n    }\r\n    /**\r\n     * Sets whether the component should be disabled.\r\n     * Implemented as part of ControlValueAccessor.\r\n     * @param isDisabled\r\n     */\r\n    setDisabledState(isDisabled) {\r\n        this.disabled = isDisabled;\r\n    }\r\n}\r\nMatSlider.ɵfac = function MatSlider_Factory(t) { return new (t || MatSlider)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.Directionality, 8), ɵngcc0.ɵɵinjectAttribute('tabindex'), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8)); };\r\nMatSlider.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatSlider, selectors: [[\"mat-slider\"]], viewQuery: function MatSlider_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._sliderWrapper = _t.first);\r\n    } }, hostAttrs: [\"role\", \"slider\", 1, \"mat-slider\", \"mat-focus-indicator\"], hostVars: 29, hostBindings: function MatSlider_HostBindings(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵlistener(\"focus\", function MatSlider_focus_HostBindingHandler() { return ctx._onFocus(); })(\"blur\", function MatSlider_blur_HostBindingHandler() { return ctx._onBlur(); })(\"keydown\", function MatSlider_keydown_HostBindingHandler($event) { return ctx._onKeydown($event); })(\"keyup\", function MatSlider_keyup_HostBindingHandler() { return ctx._onKeyup(); })(\"mouseenter\", function MatSlider_mouseenter_HostBindingHandler() { return ctx._onMouseenter(); })(\"selectstart\", function MatSlider_selectstart_HostBindingHandler($event) { return $event.preventDefault(); });\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵhostProperty(\"tabIndex\", ctx.tabIndex);\r\n        ɵngcc0.ɵɵattribute(\"aria-disabled\", ctx.disabled)(\"aria-valuemax\", ctx.max)(\"aria-valuemin\", ctx.min)(\"aria-valuenow\", ctx.value)(\"aria-valuetext\", ctx.valueText == null ? ctx.displayValue : ctx.valueText)(\"aria-orientation\", ctx.vertical ? \"vertical\" : \"horizontal\");\r\n        ɵngcc0.ɵɵclassProp(\"mat-slider-disabled\", ctx.disabled)(\"mat-slider-has-ticks\", ctx.tickInterval)(\"mat-slider-horizontal\", !ctx.vertical)(\"mat-slider-axis-inverted\", ctx._shouldInvertAxis())(\"mat-slider-invert-mouse-coords\", ctx._shouldInvertMouseCoords())(\"mat-slider-sliding\", ctx._isSliding)(\"mat-slider-thumb-label-showing\", ctx.thumbLabel)(\"mat-slider-vertical\", ctx.vertical)(\"mat-slider-min-value\", ctx._isMinValue())(\"mat-slider-hide-last-tick\", ctx.disabled || ctx._isMinValue() && ctx._getThumbGap() && ctx._shouldInvertAxis())(\"_mat-animation-noopable\", ctx._animationMode === \"NoopAnimations\");\r\n    } }, inputs: { disabled: \"disabled\", color: \"color\", tabIndex: \"tabIndex\", invert: \"invert\", max: \"max\", min: \"min\", step: \"step\", thumbLabel: \"thumbLabel\", tickInterval: \"tickInterval\", value: \"value\", vertical: \"vertical\", displayWith: \"displayWith\", valueText: \"valueText\" }, outputs: { change: \"change\", input: \"input\", valueChange: \"valueChange\" }, exportAs: [\"matSlider\"], features: [ɵngcc0.ɵɵProvidersFeature([MAT_SLIDER_VALUE_ACCESSOR]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 13, vars: 6, consts: [[1, \"mat-slider-wrapper\"], [\"sliderWrapper\", \"\"], [1, \"mat-slider-track-wrapper\"], [1, \"mat-slider-track-background\", 3, \"ngStyle\"], [1, \"mat-slider-track-fill\", 3, \"ngStyle\"], [1, \"mat-slider-ticks-container\", 3, \"ngStyle\"], [1, \"mat-slider-ticks\", 3, \"ngStyle\"], [1, \"mat-slider-thumb-container\", 3, \"ngStyle\"], [1, \"mat-slider-focus-ring\"], [1, \"mat-slider-thumb\"], [1, \"mat-slider-thumb-label\"], [1, \"mat-slider-thumb-label-text\"]], template: function MatSlider_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0, 1);\r\n        ɵngcc0.ɵɵelementStart(2, \"div\", 2);\r\n        ɵngcc0.ɵɵelement(3, \"div\", 3);\r\n        ɵngcc0.ɵɵelement(4, \"div\", 4);\r\n        ɵngcc0.ɵɵelementEnd();\r\n        ɵngcc0.ɵɵelementStart(5, \"div\", 5);\r\n        ɵngcc0.ɵɵelement(6, \"div\", 6);\r\n        ɵngcc0.ɵɵelementEnd();\r\n        ɵngcc0.ɵɵelementStart(7, \"div\", 7);\r\n        ɵngcc0.ɵɵelement(8, \"div\", 8);\r\n        ɵngcc0.ɵɵelement(9, \"div\", 9);\r\n        ɵngcc0.ɵɵelementStart(10, \"div\", 10);\r\n        ɵngcc0.ɵɵelementStart(11, \"span\", 11);\r\n        ɵngcc0.ɵɵtext(12);\r\n        ɵngcc0.ɵɵelementEnd();\r\n        ɵngcc0.ɵɵelementEnd();\r\n        ɵngcc0.ɵɵelementEnd();\r\n        ɵngcc0.ɵɵelementEnd();\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵadvance(3);\r\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx._getTrackBackgroundStyles());\r\n        ɵngcc0.ɵɵadvance(1);\r\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx._getTrackFillStyles());\r\n        ɵngcc0.ɵɵadvance(1);\r\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx._getTicksContainerStyles());\r\n        ɵngcc0.ɵɵadvance(1);\r\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx._getTicksStyles());\r\n        ɵngcc0.ɵɵadvance(1);\r\n        ɵngcc0.ɵɵproperty(\"ngStyle\", ctx._getThumbContainerStyles());\r\n        ɵngcc0.ɵɵadvance(5);\r\n        ɵngcc0.ɵɵtextInterpolate(ctx.displayValue);\r\n    } }, directives: [ɵngcc3.NgStyle], styles: [\".mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:none;vertical-align:middle}.mat-slider:not(.mat-slider-disabled):active,.mat-slider.mat-slider-sliding:not(.mat-slider-disabled){cursor:-webkit-grabbing;cursor:grabbing}.mat-slider-wrapper{-webkit-print-color-adjust:exact;color-adjust:exact;position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{-webkit-background-clip:content-box;background-clip:content-box;background-repeat:repeat;box-sizing:border-box;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider.cdk-keyboard-focused .mat-slider-focus-ring,.mat-slider.cdk-program-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb-label,.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb{cursor:-webkit-grab;cursor:grab}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(0.7);transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-radius 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.cdk-high-contrast-active .mat-slider-thumb-label{outline:solid 1px}.mat-slider-thumb-label-text{z-index:1;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-sliding .mat-slider-track-fill,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-thumb-container{transition-duration:0ms}.mat-slider-has-ticks .mat-slider-wrapper::after{content:\\\"\\\";position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{display:none}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider:not(.mat-slider-disabled).cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label-text{opacity:1}.mat-slider:not(.mat-slider-disabled).cdk-mouse-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-touch-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-program-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(0.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}.cdk-high-contrast-active .mat-slider-horizontal .mat-slider-ticks-container{height:0;outline:solid 2px;top:1px}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(0.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label,.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label-text{transform:none}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}.cdk-high-contrast-active .mat-slider-vertical .mat-slider-ticks-container{width:0;outline:solid 2px;left:1px}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb{-webkit-backface-visibility:hidden;backface-visibility:hidden}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(0.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}.mat-slider._mat-animation-noopable .mat-slider-track-fill,.mat-slider._mat-animation-noopable .mat-slider-track-background,.mat-slider._mat-animation-noopable .mat-slider-ticks,.mat-slider._mat-animation-noopable .mat-slider-thumb-container,.mat-slider._mat-animation-noopable .mat-slider-focus-ring,.mat-slider._mat-animation-noopable .mat-slider-thumb,.mat-slider._mat-animation-noopable .mat-slider-thumb-label,.mat-slider._mat-animation-noopable .mat-slider-thumb-label-text,.mat-slider._mat-animation-noopable .mat-slider-has-ticks .mat-slider-wrapper::after{transition:none}\\n\"], encapsulation: 2, changeDetection: 0 });\r\nMatSlider.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: FocusMonitor },\r\n    { type: ChangeDetectorRef },\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: String, decorators: [{ type: Attribute, args: ['tabindex',] }] },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }\r\n];\r\nMatSlider.propDecorators = {\r\n    invert: [{ type: Input }],\r\n    max: [{ type: Input }],\r\n    min: [{ type: Input }],\r\n    step: [{ type: Input }],\r\n    thumbLabel: [{ type: Input }],\r\n    tickInterval: [{ type: Input }],\r\n    value: [{ type: Input }],\r\n    displayWith: [{ type: Input }],\r\n    valueText: [{ type: Input }],\r\n    vertical: [{ type: Input }],\r\n    change: [{ type: Output }],\r\n    input: [{ type: Output }],\r\n    valueChange: [{ type: Output }],\r\n    _sliderWrapper: [{ type: ViewChild, args: ['sliderWrapper',] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatSlider, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'mat-slider',\r\n                exportAs: 'matSlider',\r\n                providers: [MAT_SLIDER_VALUE_ACCESSOR],\r\n                host: {\r\n                    '(focus)': '_onFocus()',\r\n                    '(blur)': '_onBlur()',\r\n                    '(keydown)': '_onKeydown($event)',\r\n                    '(keyup)': '_onKeyup()',\r\n                    '(mouseenter)': '_onMouseenter()',\r\n                    // On Safari starting to slide temporarily triggers text selection mode which\r\n                    // show the wrong cursor. We prevent it by stopping the `selectstart` event.\r\n                    '(selectstart)': '$event.preventDefault()',\r\n                    'class': 'mat-slider mat-focus-indicator',\r\n                    'role': 'slider',\r\n                    '[tabIndex]': 'tabIndex',\r\n                    '[attr.aria-disabled]': 'disabled',\r\n                    '[attr.aria-valuemax]': 'max',\r\n                    '[attr.aria-valuemin]': 'min',\r\n                    '[attr.aria-valuenow]': 'value',\r\n                    // NVDA and Jaws appear to announce the `aria-valuenow` by calculating its percentage based\r\n                    // on its value between `aria-valuemin` and `aria-valuemax`. Due to how decimals are handled,\r\n                    // it can cause the slider to read out a very long value like 0.20000068 if the current value\r\n                    // is 0.2 with a min of 0 and max of 1. We work around the issue by setting `aria-valuetext`\r\n                    // to the same value that we set on the slider's thumb which will be truncated.\r\n                    '[attr.aria-valuetext]': 'valueText == null ? displayValue : valueText',\r\n                    '[attr.aria-orientation]': 'vertical ? \"vertical\" : \"horizontal\"',\r\n                    '[class.mat-slider-disabled]': 'disabled',\r\n                    '[class.mat-slider-has-ticks]': 'tickInterval',\r\n                    '[class.mat-slider-horizontal]': '!vertical',\r\n                    '[class.mat-slider-axis-inverted]': '_shouldInvertAxis()',\r\n                    // Class binding which is only used by the test harness as there is no other\r\n                    // way for the harness to detect if mouse coordinates need to be inverted.\r\n                    '[class.mat-slider-invert-mouse-coords]': '_shouldInvertMouseCoords()',\r\n                    '[class.mat-slider-sliding]': '_isSliding',\r\n                    '[class.mat-slider-thumb-label-showing]': 'thumbLabel',\r\n                    '[class.mat-slider-vertical]': 'vertical',\r\n                    '[class.mat-slider-min-value]': '_isMinValue()',\r\n                    '[class.mat-slider-hide-last-tick]': 'disabled || _isMinValue() && _getThumbGap() && _shouldInvertAxis()',\r\n                    '[class._mat-animation-noopable]': '_animationMode === \"NoopAnimations\"'\r\n                },\r\n                template: \"<div class=\\\"mat-slider-wrapper\\\" #sliderWrapper>\\n  <div class=\\\"mat-slider-track-wrapper\\\">\\n    <div class=\\\"mat-slider-track-background\\\" [ngStyle]=\\\"_getTrackBackgroundStyles()\\\"></div>\\n    <div class=\\\"mat-slider-track-fill\\\" [ngStyle]=\\\"_getTrackFillStyles()\\\"></div>\\n  </div>\\n  <div class=\\\"mat-slider-ticks-container\\\" [ngStyle]=\\\"_getTicksContainerStyles()\\\">\\n    <div class=\\\"mat-slider-ticks\\\" [ngStyle]=\\\"_getTicksStyles()\\\"></div>\\n  </div>\\n  <div class=\\\"mat-slider-thumb-container\\\" [ngStyle]=\\\"_getThumbContainerStyles()\\\">\\n    <div class=\\\"mat-slider-focus-ring\\\"></div>\\n    <div class=\\\"mat-slider-thumb\\\"></div>\\n    <div class=\\\"mat-slider-thumb-label\\\">\\n      <span class=\\\"mat-slider-thumb-label-text\\\">{{displayValue}}</span>\\n    </div>\\n  </div>\\n</div>\\n\",\r\n                inputs: ['disabled', 'color', 'tabIndex'],\r\n                encapsulation: ViewEncapsulation.None,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                styles: [\".mat-slider{display:inline-block;position:relative;box-sizing:border-box;padding:8px;outline:none;vertical-align:middle}.mat-slider:not(.mat-slider-disabled):active,.mat-slider.mat-slider-sliding:not(.mat-slider-disabled){cursor:-webkit-grabbing;cursor:grabbing}.mat-slider-wrapper{-webkit-print-color-adjust:exact;color-adjust:exact;position:absolute}.mat-slider-track-wrapper{position:absolute;top:0;left:0;overflow:hidden}.mat-slider-track-fill{position:absolute;transform-origin:0 0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-track-background{position:absolute;transform-origin:100% 100%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-ticks-container{position:absolute;left:0;top:0;overflow:hidden}.mat-slider-ticks{-webkit-background-clip:content-box;background-clip:content-box;background-repeat:repeat;box-sizing:border-box;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-container{position:absolute;z-index:1;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-focus-ring{position:absolute;width:30px;height:30px;border-radius:50%;transform:scale(0);opacity:0;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider.cdk-keyboard-focused .mat-slider-focus-ring,.mat-slider.cdk-program-focused .mat-slider-focus-ring{transform:scale(1);opacity:1}.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb-label,.mat-slider:not(.mat-slider-disabled):not(.mat-slider-sliding) .mat-slider-thumb{cursor:-webkit-grab;cursor:grab}.mat-slider-thumb{position:absolute;right:-10px;bottom:-10px;box-sizing:border-box;width:20px;height:20px;border:3px solid transparent;border-radius:50%;transform:scale(0.7);transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-thumb-label{display:none;align-items:center;justify-content:center;position:absolute;width:28px;height:28px;border-radius:50%;transition:transform 400ms cubic-bezier(0.25, 0.8, 0.25, 1),border-radius 400ms cubic-bezier(0.25, 0.8, 0.25, 1),background-color 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.cdk-high-contrast-active .mat-slider-thumb-label{outline:solid 1px}.mat-slider-thumb-label-text{z-index:1;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-sliding .mat-slider-track-fill,.mat-slider-sliding .mat-slider-track-background,.mat-slider-sliding .mat-slider-thumb-container{transition-duration:0ms}.mat-slider-has-ticks .mat-slider-wrapper::after{content:\\\"\\\";position:absolute;border-width:0;border-style:solid;opacity:0;transition:opacity 400ms cubic-bezier(0.25, 0.8, 0.25, 1)}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after,.mat-slider-has-ticks:hover:not(.mat-slider-hide-last-tick) .mat-slider-wrapper::after{opacity:1}.mat-slider-has-ticks.cdk-focused:not(.mat-slider-disabled) .mat-slider-ticks,.mat-slider-has-ticks:hover:not(.mat-slider-disabled) .mat-slider-ticks{opacity:1}.mat-slider-thumb-label-showing .mat-slider-focus-ring{display:none}.mat-slider-thumb-label-showing .mat-slider-thumb-label{display:flex}.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:100% 100%}.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:0 0}.mat-slider:not(.mat-slider-disabled).cdk-focused.mat-slider-thumb-label-showing .mat-slider-thumb{transform:scale(0)}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label{border-radius:50% 50% 0}.mat-slider:not(.mat-slider-disabled).cdk-focused .mat-slider-thumb-label-text{opacity:1}.mat-slider:not(.mat-slider-disabled).cdk-mouse-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-touch-focused .mat-slider-thumb,.mat-slider:not(.mat-slider-disabled).cdk-program-focused .mat-slider-thumb{border-width:2px;transform:scale(1)}.mat-slider-disabled .mat-slider-focus-ring{transform:scale(0);opacity:0}.mat-slider-disabled .mat-slider-thumb{border-width:4px;transform:scale(0.5)}.mat-slider-disabled .mat-slider-thumb-label{display:none}.mat-slider-horizontal{height:48px;min-width:128px}.mat-slider-horizontal .mat-slider-wrapper{height:2px;top:23px;left:8px;right:8px}.mat-slider-horizontal .mat-slider-wrapper::after{height:2px;border-left-width:2px;right:0;top:0}.mat-slider-horizontal .mat-slider-track-wrapper{height:2px;width:100%}.mat-slider-horizontal .mat-slider-track-fill{height:2px;width:100%;transform:scaleX(0)}.mat-slider-horizontal .mat-slider-track-background{height:2px;width:100%;transform:scaleX(1)}.mat-slider-horizontal .mat-slider-ticks-container{height:2px;width:100%}.cdk-high-contrast-active .mat-slider-horizontal .mat-slider-ticks-container{height:0;outline:solid 2px;top:1px}.mat-slider-horizontal .mat-slider-ticks{height:2px;width:100%}.mat-slider-horizontal .mat-slider-thumb-container{width:100%;height:0;top:50%}.mat-slider-horizontal .mat-slider-focus-ring{top:-15px;right:-15px}.mat-slider-horizontal .mat-slider-thumb-label{right:-14px;top:-40px;transform:translateY(26px) scale(0.01) rotate(45deg)}.mat-slider-horizontal .mat-slider-thumb-label-text{transform:rotate(-45deg)}.mat-slider-horizontal.cdk-focused .mat-slider-thumb-label{transform:rotate(45deg)}.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label,.cdk-high-contrast-active .mat-slider-horizontal.cdk-focused .mat-slider-thumb-label-text{transform:none}.mat-slider-vertical{width:48px;min-height:128px}.mat-slider-vertical .mat-slider-wrapper{width:2px;top:8px;bottom:8px;left:23px}.mat-slider-vertical .mat-slider-wrapper::after{width:2px;border-top-width:2px;bottom:0;left:0}.mat-slider-vertical .mat-slider-track-wrapper{height:100%;width:2px}.mat-slider-vertical .mat-slider-track-fill{height:100%;width:2px;transform:scaleY(0)}.mat-slider-vertical .mat-slider-track-background{height:100%;width:2px;transform:scaleY(1)}.mat-slider-vertical .mat-slider-ticks-container{width:2px;height:100%}.cdk-high-contrast-active .mat-slider-vertical .mat-slider-ticks-container{width:0;outline:solid 2px;left:1px}.mat-slider-vertical .mat-slider-focus-ring{bottom:-15px;left:-15px}.mat-slider-vertical .mat-slider-ticks{width:2px;height:100%}.mat-slider-vertical .mat-slider-thumb-container{height:100%;width:0;left:50%}.mat-slider-vertical .mat-slider-thumb{-webkit-backface-visibility:hidden;backface-visibility:hidden}.mat-slider-vertical .mat-slider-thumb-label{bottom:-14px;left:-40px;transform:translateX(26px) scale(0.01) rotate(-45deg)}.mat-slider-vertical .mat-slider-thumb-label-text{transform:rotate(45deg)}.mat-slider-vertical.cdk-focused .mat-slider-thumb-label{transform:rotate(-45deg)}[dir=rtl] .mat-slider-wrapper::after{left:0;right:auto}[dir=rtl] .mat-slider-horizontal .mat-slider-track-fill{transform-origin:100% 100%}[dir=rtl] .mat-slider-horizontal .mat-slider-track-background{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-fill{transform-origin:0 0}[dir=rtl] .mat-slider-horizontal.mat-slider-axis-inverted .mat-slider-track-background{transform-origin:100% 100%}.mat-slider._mat-animation-noopable .mat-slider-track-fill,.mat-slider._mat-animation-noopable .mat-slider-track-background,.mat-slider._mat-animation-noopable .mat-slider-ticks,.mat-slider._mat-animation-noopable .mat-slider-thumb-container,.mat-slider._mat-animation-noopable .mat-slider-focus-ring,.mat-slider._mat-animation-noopable .mat-slider-thumb,.mat-slider._mat-animation-noopable .mat-slider-thumb-label,.mat-slider._mat-animation-noopable .mat-slider-thumb-label-text,.mat-slider._mat-animation-noopable .mat-slider-has-ticks .mat-slider-wrapper::after{transition:none}\\n\"]\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.FocusMonitor }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc2.Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: String, decorators: [{\r\n                type: Attribute,\r\n                args: ['tabindex']\r\n            }] }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [DOCUMENT]\r\n            }] }, { type: String, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [ANIMATION_MODULE_TYPE]\r\n            }] }]; }, { change: [{\r\n            type: Output\r\n        }], input: [{\r\n            type: Output\r\n        }], valueChange: [{\r\n            type: Output\r\n        }], invert: [{\r\n            type: Input\r\n        }], max: [{\r\n            type: Input\r\n        }], min: [{\r\n            type: Input\r\n        }], step: [{\r\n            type: Input\r\n        }], thumbLabel: [{\r\n            type: Input\r\n        }], tickInterval: [{\r\n            type: Input\r\n        }], value: [{\r\n            type: Input\r\n        }], vertical: [{\r\n            type: Input\r\n        }], displayWith: [{\r\n            type: Input\r\n        }], valueText: [{\r\n            type: Input\r\n        }], _sliderWrapper: [{\r\n            type: ViewChild,\r\n            args: ['sliderWrapper']\r\n        }] }); })();\r\n/** Returns whether an event is a touch event. */\r\nfunction isTouchEvent(event) {\r\n    // This function is called for every pixel that the user has dragged so we need it to be\r\n    // as fast as possible. Since we only bind mouse events and touch events, we can assume\r\n    // that if the event's name starts with `t`, it's a touch event.\r\n    return event.type[0] === 't';\r\n}\r\n/** Gets the coordinates of a touch or mouse event relative to the viewport. */\r\nfunction getPointerPositionOnPage(event, id) {\r\n    let point;\r\n    if (isTouchEvent(event)) {\r\n        // The `identifier` could be undefined if the browser doesn't support `TouchEvent.identifier`.\r\n        // If that's the case, attribute the first touch to all active sliders. This should still cover\r\n        // the most common case while only breaking multi-touch.\r\n        if (typeof id === 'number') {\r\n            point = findMatchingTouch(event.touches, id) || findMatchingTouch(event.changedTouches, id);\r\n        }\r\n        else {\r\n            // `touches` will be empty for start/end events so we have to fall back to `changedTouches`.\r\n            point = event.touches[0] || event.changedTouches[0];\r\n        }\r\n    }\r\n    else {\r\n        point = event;\r\n    }\r\n    return point ? { x: point.clientX, y: point.clientY } : undefined;\r\n}\r\n/** Finds a `Touch` with a specific ID in a `TouchList`. */\r\nfunction findMatchingTouch(touches, id) {\r\n    for (let i = 0; i < touches.length; i++) {\r\n        if (touches[i].identifier === id) {\r\n            return touches[i];\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n/** Gets the unique ID of a touch that matches a specific slider. */\r\nfunction getTouchIdForSlider(event, sliderHost) {\r\n    for (let i = 0; i < event.touches.length; i++) {\r\n        const target = event.touches[i].target;\r\n        if (sliderHost === target || sliderHost.contains(target)) {\r\n            return event.touches[i].identifier;\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass MatSliderModule {\r\n}\r\nMatSliderModule.ɵfac = function MatSliderModule_Factory(t) { return new (t || MatSliderModule)(); };\r\nMatSliderModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MatSliderModule });\r\nMatSliderModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[CommonModule, MatCommonModule], MatCommonModule] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatSliderModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [CommonModule, MatCommonModule],\r\n                exports: [MatSlider, MatCommonModule],\r\n                declarations: [MatSlider]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatSliderModule, { declarations: function () { return [MatSlider]; }, imports: function () { return [CommonModule, MatCommonModule]; }, exports: function () { return [MatSlider, MatCommonModule]; } }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { MAT_SLIDER_VALUE_ACCESSOR, MatSlider, MatSliderChange, MatSliderModule };\r\n\r\n//# sourceMappingURL=slider.js.map"],"sourceRoot":"webpack:///"}