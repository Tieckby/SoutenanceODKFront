{"version":3,"sources":["./node_modules/@angular/material/__ivy_ngcc__/fesm2015/sidenav.js"],"names":[],"mappings":"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DAAM;AAC5B,uBAAuB,yDAAU;AACjC,aAAa,GAAG,GAAG,OAAO,qDAAiB,EAAE,GAAG,OAAO,oEAAuB,EAAE,GAAG,OAAO,iDAAa,EAAE,EAAE,EAAE,QAAQ,EAAE;AACvH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yCAAO;AAC5C;AACA,iCAAiC,yCAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAY;AACxB;AACA,oDAAoD,sDAAM,UAAU,mDAAG,QAAQ,EAAE;AACjF;AACA,uDAAuD,sDAAM,qEAAqE,qDAAK;AACvI;AACA,oDAAoD,sDAAM,WAAW,mDAAG,QAAQ,EAAE;AAClF;AACA,uDAAuD,sDAAM,0DAA0D,qDAAK;AAC5H;AACA,8BAA8B,yCAAO;AACrC;AACA;AACA,qCAAqC,uDAAY;AACjD;AACA;AACA;AACA;AACA,gCAAgC,yCAAO;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,+CAAS,iDAAiD,sDAAM;AAC5E,yCAAyC,yDAAM,2BAA2B,qEAAc;AACxF,aAAa,GAAG,yDAAS;AACzB;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,gCAAgC,qEAAoB;AACpD;AACA,SAAS;AACT,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD,6BAA6B,sBAAsB,6EAAqB,QAAQ;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,mBAAmB,6EAAqB,QAAQ;AAC1E;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC,uBAAuB,aAAa,6EAAqB,SAAS;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,qDAAI;AACvC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,6BAA6B,+DAAwB,CAAC,qDAAiB,GAAG,+DAAwB,CAAC,gEAAuB,GAAG,+DAAwB,CAAC,4DAAmB,GAAG,+DAAwB,CAAC,4DAAe,GAAG,+DAAwB,CAAC,iDAAa,GAAG,+DAAwB,CAAC,sDAAQ,MAAM,+DAAwB,2BAA2B;AAC1Y,+BAA+B,+DAAwB,EAAE,qKAAqK;AAC9N,QAAQ,qEAA8B,8FAA8F,4CAA4C,EAAE,6FAA6F,2CAA2C,EAAE;AAC5T,KAAK;AACL,QAAQ,yDAAkB;AAC1B,QAAQ,qEAA8B;AACtC,QAAQ,yDAAkB;AAC1B,KAAK,EAAE,WAAW,6GAA6G,YAAY,+KAA+K,yLAAyL;AACnf,QAAQ,6DAAsB;AAC9B,QAAQ,4DAAqB;AAC7B,QAAQ,0DAAmB;AAC3B,QAAQ,0DAAmB;AAC3B,KAAK,EAAE,eAAe,iEAAoB,4BAA4B,mDAAmD,sBAAsB;AAC/I;AACA,KAAK,OAAO,qDAAU,EAAE;AACxB,KAAK,OAAO,gEAAgB,EAAE;AAC9B,KAAK,OAAO,4DAAY,EAAE;AAC1B,KAAK,OAAO,4DAAQ,EAAE;AACtB,KAAK,OAAO,iDAAM,EAAE;AACpB,KAAK,gCAAgC,OAAO,mDAAQ,EAAE,GAAG,OAAO,iDAAM,SAAS,sDAAQ,IAAI,GAAG;AAC9F,KAAK,yCAAyC,OAAO,mDAAQ,EAAE,GAAG,OAAO,iDAAM,iCAAiC;AAChH;AACA;AACA,gBAAgB,OAAO,gDAAK,EAAE;AAC9B,YAAY,OAAO,gDAAK,EAAE;AAC1B,oBAAoB,OAAO,gDAAK,EAAE;AAClC,iBAAiB,OAAO,gDAAK,EAAE;AAC/B,cAAc,OAAO,gDAAK,EAAE;AAC5B,uBAAuB,OAAO,sDAAW,yBAAyB;AAClE,oBAAoB,OAAO,iDAAM,EAAE;AACnC,qBAAqB,OAAO,iDAAM,qBAAqB;AACvD,mBAAmB,OAAO,iDAAM,EAAE;AAClC,qBAAqB,OAAO,iDAAM,qBAAqB;AACvD,mBAAmB,OAAO,iDAAM,EAAE;AAClC,yBAAyB,OAAO,iDAAM,8BAA8B;AACpE,+BAA+B,OAAO,uDAAY,2CAA2C;AAC7F,8BAA8B,OAAO,uDAAY,0CAA0C;AAC3F;AACA,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iCAAiC,yEAA8B;AAC/D,+BAA+B,iEAAsB;AACrD,aAAa;AACb,KAAK,gBAAgB,UAAU,OAAO,qDAAiB,EAAE,GAAG,OAAO,gEAAuB,EAAE,GAAG,OAAO,4DAAmB,EAAE,GAAG,OAAO,4DAAe,EAAE,GAAG,OAAO,iDAAa,EAAE,GAAG;AAClL,sBAAsB,mDAAQ;AAC9B,aAAa;AACb,sBAAsB,iDAAM;AAC5B,uBAAuB,sDAAQ;AAC/B,aAAa,GAAG,GAAG;AACnB,sBAAsB,mDAAQ;AAC9B,aAAa;AACb,sBAAsB,iDAAM;AAC5B;AACA,aAAa,GAAG,EAAE,EAAE,GAAG;AACvB,kBAAkB,sDAAW;AAC7B;AACA,SAAS;AACT,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,iDAAM;AACxB;AACA,SAAS;AACT,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,iDAAM;AACxB;AACA,SAAS;AACT,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,iDAAM;AACxB;AACA,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT,kBAAkB,gDAAK;AACvB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAY;AAC9B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAY;AAC9B;AACA,SAAS,GAAG,EAAE,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oDAAS;AACrC;AACA,iCAAiC,uDAAY;AAC7C;AACA,8BAA8B,yCAAO;AACrC;AACA,mCAAmC,yCAAO;AAC1C;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,yCAAyC,yCAAO;AAChD;AACA;AACA;AACA,6BAA6B,yDAAS;AACtC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,kBAAkB,yDAAS;AAC3B;AACA;AACA;AACA;AACA,iBAAiB,oBAAoB;AACrC;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C,yBAAyB,kBAAkB,6EAAqB,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,6EAAqB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0DAAS,oBAAoB,yDAAS;AACxD;AACA;AACA;AACA,SAAS;AACT,mCAAmC,0DAAS;AAC5C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sCAAsC,6DAAY;AAClD,YAAY,yDAAS;AACrB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,sDAAM,gDAAgD,yDAAS;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,qCAAqC,yDAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,yDAAS;AAC/C,+CAA+C,qDAAI;AACnD;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,qCAAqC,yDAAS,CAAC,4CAAK;AACpD;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAk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","file":"default-node_modules_angular_material___ivy_ngcc___fesm2015_sidenav_js-es2015.js","sourcesContent":["import { Platform, PlatformModule } from '@angular/cdk/platform';\r\nimport { CdkScrollable, ScrollDispatcher, ViewportRuler, CdkScrollableModule } from '@angular/cdk/scrolling';\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { InjectionToken, Component, ChangeDetectionStrategy, ViewEncapsulation, ChangeDetectorRef, Inject, forwardRef, ElementRef, NgZone, EventEmitter, Optional, Input, HostBinding, Output, HostListener, QueryList, ContentChildren, ContentChild, ViewChild, NgModule } from '@angular/core';\r\nimport { MatCommonModule } from '@angular/material/core';\r\nimport { FocusTrapFactory, FocusMonitor } from '@angular/cdk/a11y';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { coerceBooleanProperty, coerceNumberProperty } from '@angular/cdk/coercion';\r\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\r\nimport { Subject, fromEvent, merge } from 'rxjs';\r\nimport { filter, map, mapTo, takeUntil, distinctUntilChanged, take, startWith, debounceTime } from 'rxjs/operators';\r\nimport { trigger, state, style, transition, animate } from '@angular/animations';\r\nimport { ANIMATION_MODULE_TYPE } from '@angular/platform-browser/animations';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Animations used by the Material drawers.\r\n * @docs-private\r\n */\r\nimport * as ɵngcc0 from '@angular/core';\r\nimport * as ɵngcc1 from '@angular/cdk/scrolling';\r\nimport * as ɵngcc2 from '@angular/cdk/a11y';\r\nimport * as ɵngcc3 from '@angular/cdk/platform';\r\nimport * as ɵngcc4 from '@angular/cdk/bidi';\r\nimport * as ɵngcc5 from '@angular/common';\r\n\r\nconst _c0 = [\"*\"];\r\nfunction MatDrawerContainer_div_0_Template(rf, ctx) { if (rf & 1) {\r\n    const _r3 = ɵngcc0.ɵɵgetCurrentView();\r\n    ɵngcc0.ɵɵelementStart(0, \"div\", 2);\r\n    ɵngcc0.ɵɵlistener(\"click\", function MatDrawerContainer_div_0_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2._onBackdropClicked(); });\r\n    ɵngcc0.ɵɵelementEnd();\r\n} if (rf & 2) {\r\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\r\n    ɵngcc0.ɵɵclassProp(\"mat-drawer-shown\", ctx_r0._isShowingBackdrop());\r\n} }\r\nfunction MatDrawerContainer_mat_drawer_content_3_Template(rf, ctx) { if (rf & 1) {\r\n    ɵngcc0.ɵɵelementStart(0, \"mat-drawer-content\");\r\n    ɵngcc0.ɵɵprojection(1, 2);\r\n    ɵngcc0.ɵɵelementEnd();\r\n} }\r\nconst _c1 = [[[\"mat-drawer\"]], [[\"mat-drawer-content\"]], \"*\"];\r\nconst _c2 = [\"mat-drawer\", \"mat-drawer-content\", \"*\"];\r\nfunction MatSidenavContainer_div_0_Template(rf, ctx) { if (rf & 1) {\r\n    const _r3 = ɵngcc0.ɵɵgetCurrentView();\r\n    ɵngcc0.ɵɵelementStart(0, \"div\", 2);\r\n    ɵngcc0.ɵɵlistener(\"click\", function MatSidenavContainer_div_0_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r3); const ctx_r2 = ɵngcc0.ɵɵnextContext(); return ctx_r2._onBackdropClicked(); });\r\n    ɵngcc0.ɵɵelementEnd();\r\n} if (rf & 2) {\r\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\r\n    ɵngcc0.ɵɵclassProp(\"mat-drawer-shown\", ctx_r0._isShowingBackdrop());\r\n} }\r\nfunction MatSidenavContainer_mat_sidenav_content_3_Template(rf, ctx) { if (rf & 1) {\r\n    ɵngcc0.ɵɵelementStart(0, \"mat-sidenav-content\", 3);\r\n    ɵngcc0.ɵɵprojection(1, 2);\r\n    ɵngcc0.ɵɵelementEnd();\r\n} }\r\nconst _c3 = [[[\"mat-sidenav\"]], [[\"mat-sidenav-content\"]], \"*\"];\r\nconst _c4 = [\"mat-sidenav\", \"mat-sidenav-content\", \"*\"];\r\nconst _c5 = \".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\\n\";\r\nconst matDrawerAnimations = {\r\n    /** Animation that slides a drawer in and out. */\r\n    transformDrawer: trigger('transform', [\r\n        // We remove the `transform` here completely, rather than setting it to zero, because:\r\n        // 1. Having a transform can cause elements with ripples or an animated\r\n        //    transform to shift around in Chrome with an RTL layout (see #10023).\r\n        // 2. 3d transforms causes text to appear blurry on IE and Edge.\r\n        state('open, open-instant', style({\r\n            'transform': 'none',\r\n            'visibility': 'visible',\r\n        })),\r\n        state('void', style({\r\n            // Avoids the shadow showing up when closed in SSR.\r\n            'box-shadow': 'none',\r\n            'visibility': 'hidden',\r\n        })),\r\n        transition('void => open-instant', animate('0ms')),\r\n        transition('void <=> open, open-instant => void', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))\r\n    ])\r\n};\r\n\r\n/**\r\n * Throws an exception when two MatDrawer are matching the same position.\r\n * @docs-private\r\n */\r\nfunction throwMatDuplicatedDrawerError(position) {\r\n    throw Error(`A drawer was already declared for 'position=\"${position}\"'`);\r\n}\r\n/** Configures whether drawers should use auto sizing by default. */\r\nconst MAT_DRAWER_DEFAULT_AUTOSIZE = new InjectionToken('MAT_DRAWER_DEFAULT_AUTOSIZE', {\r\n    providedIn: 'root',\r\n    factory: MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY,\r\n});\r\n/**\r\n * Used to provide a drawer container to a drawer while avoiding circular references.\r\n * @docs-private\r\n */\r\nconst MAT_DRAWER_CONTAINER = new InjectionToken('MAT_DRAWER_CONTAINER');\r\n/** @docs-private */\r\nfunction MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY() {\r\n    return false;\r\n}\r\nclass MatDrawerContent extends CdkScrollable {\r\n    constructor(_changeDetectorRef, _container, elementRef, scrollDispatcher, ngZone) {\r\n        super(elementRef, scrollDispatcher, ngZone);\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._container = _container;\r\n    }\r\n    ngAfterContentInit() {\r\n        this._container._contentMarginChanges.subscribe(() => {\r\n            this._changeDetectorRef.markForCheck();\r\n        });\r\n    }\r\n}\r\nMatDrawerContent.ɵfac = function MatDrawerContent_Factory(t) { return new (t || MatDrawerContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(forwardRef(() => MatDrawerContainer)), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ScrollDispatcher), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\r\nMatDrawerContent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatDrawerContent, selectors: [[\"mat-drawer-content\"]], hostAttrs: [1, \"mat-drawer-content\"], hostVars: 4, hostBindings: function MatDrawerContent_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵstyleProp(\"margin-left\", ctx._container._contentMargins.left, \"px\")(\"margin-right\", ctx._container._contentMargins.right, \"px\");\r\n    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function MatDrawerContent_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef();\r\n        ɵngcc0.ɵɵprojection(0);\r\n    } }, encapsulation: 2, changeDetection: 0 });\r\nMatDrawerContent.ctorParameters = () => [\r\n    { type: ChangeDetectorRef },\r\n    { type: MatDrawerContainer, decorators: [{ type: Inject, args: [forwardRef(() => MatDrawerContainer),] }] },\r\n    { type: ElementRef },\r\n    { type: ScrollDispatcher },\r\n    { type: NgZone }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatDrawerContent, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'mat-drawer-content',\r\n                template: '<ng-content></ng-content>',\r\n                host: {\r\n                    'class': 'mat-drawer-content',\r\n                    '[style.margin-left.px]': '_container._contentMargins.left',\r\n                    '[style.margin-right.px]': '_container._contentMargins.right'\r\n                },\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: MatDrawerContainer, decorators: [{\r\n                type: Inject,\r\n                args: [forwardRef(() => MatDrawerContainer)]\r\n            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.ScrollDispatcher }, { type: ɵngcc0.NgZone }]; }, null); })();\r\n/**\r\n * This component corresponds to a drawer that can be opened on the drawer container.\r\n */\r\nclass MatDrawer {\r\n    constructor(_elementRef, _focusTrapFactory, _focusMonitor, _platform, _ngZone, _doc, _container) {\r\n        this._elementRef = _elementRef;\r\n        this._focusTrapFactory = _focusTrapFactory;\r\n        this._focusMonitor = _focusMonitor;\r\n        this._platform = _platform;\r\n        this._ngZone = _ngZone;\r\n        this._doc = _doc;\r\n        this._container = _container;\r\n        this._elementFocusedBeforeDrawerWasOpened = null;\r\n        /** Whether the drawer is initialized. Used for disabling the initial animation. */\r\n        this._enableAnimations = false;\r\n        this._position = 'start';\r\n        this._mode = 'over';\r\n        this._disableClose = false;\r\n        this._opened = false;\r\n        /** Emits whenever the drawer has started animating. */\r\n        this._animationStarted = new Subject();\r\n        /** Emits whenever the drawer is done animating. */\r\n        this._animationEnd = new Subject();\r\n        /** Current state of the sidenav animation. */\r\n        // @HostBinding is used in the class as it is expected to be extended.  Since @Component decorator\r\n        // metadata is not inherited by child classes, instead the host binding data is defined in a way\r\n        // that can be inherited.\r\n        // tslint:disable-next-line:no-host-decorator-in-concrete\r\n        this._animationState = 'void';\r\n        /** Event emitted when the drawer open state is changed. */\r\n        this.openedChange = \r\n        // Note this has to be async in order to avoid some issues with two-bindings (see #8872).\r\n        new EventEmitter(/* isAsync */ true);\r\n        /** Event emitted when the drawer has been opened. */\r\n        this._openedStream = this.openedChange.pipe(filter(o => o), map(() => { }));\r\n        /** Event emitted when the drawer has started opening. */\r\n        this.openedStart = this._animationStarted.pipe(filter(e => e.fromState !== e.toState && e.toState.indexOf('open') === 0), mapTo(undefined));\r\n        /** Event emitted when the drawer has been closed. */\r\n        this._closedStream = this.openedChange.pipe(filter(o => !o), map(() => { }));\r\n        /** Event emitted when the drawer has started closing. */\r\n        this.closedStart = this._animationStarted.pipe(filter(e => e.fromState !== e.toState && e.toState === 'void'), mapTo(undefined));\r\n        /** Emits when the component is destroyed. */\r\n        this._destroyed = new Subject();\r\n        /** Event emitted when the drawer's position changes. */\r\n        // tslint:disable-next-line:no-output-on-prefix\r\n        this.onPositionChanged = new EventEmitter();\r\n        /**\r\n         * An observable that emits when the drawer mode changes. This is used by the drawer container to\r\n         * to know when to when the mode changes so it can adapt the margins on the content.\r\n         */\r\n        this._modeChanged = new Subject();\r\n        this.openedChange.subscribe((opened) => {\r\n            if (opened) {\r\n                if (this._doc) {\r\n                    this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement;\r\n                }\r\n                this._takeFocus();\r\n            }\r\n            else if (this._isFocusWithinDrawer()) {\r\n                this._restoreFocus();\r\n            }\r\n        });\r\n        /**\r\n         * Listen to `keydown` events outside the zone so that change detection is not run every\r\n         * time a key is pressed. Instead we re-enter the zone only if the `ESC` key is pressed\r\n         * and we don't have close disabled.\r\n         */\r\n        this._ngZone.runOutsideAngular(() => {\r\n            fromEvent(this._elementRef.nativeElement, 'keydown').pipe(filter(event => {\r\n                return event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event);\r\n            }), takeUntil(this._destroyed)).subscribe(event => this._ngZone.run(() => {\r\n                this.close();\r\n                event.stopPropagation();\r\n                event.preventDefault();\r\n            }));\r\n        });\r\n        // We need a Subject with distinctUntilChanged, because the `done` event\r\n        // fires twice on some browsers. See https://github.com/angular/angular/issues/24084\r\n        this._animationEnd.pipe(distinctUntilChanged((x, y) => {\r\n            return x.fromState === y.fromState && x.toState === y.toState;\r\n        })).subscribe((event) => {\r\n            const { fromState, toState } = event;\r\n            if ((toState.indexOf('open') === 0 && fromState === 'void') ||\r\n                (toState === 'void' && fromState.indexOf('open') === 0)) {\r\n                this.openedChange.emit(this._opened);\r\n            }\r\n        });\r\n    }\r\n    /** The side that the drawer is attached to. */\r\n    get position() { return this._position; }\r\n    set position(value) {\r\n        // Make sure we have a valid value.\r\n        value = value === 'end' ? 'end' : 'start';\r\n        if (value != this._position) {\r\n            this._position = value;\r\n            this.onPositionChanged.emit();\r\n        }\r\n    }\r\n    /** Mode of the drawer; one of 'over', 'push' or 'side'. */\r\n    get mode() { return this._mode; }\r\n    set mode(value) {\r\n        this._mode = value;\r\n        this._updateFocusTrapState();\r\n        this._modeChanged.next();\r\n    }\r\n    /** Whether the drawer can be closed with the escape key or by clicking on the backdrop. */\r\n    get disableClose() { return this._disableClose; }\r\n    set disableClose(value) { this._disableClose = coerceBooleanProperty(value); }\r\n    /**\r\n     * Whether the drawer should focus the first focusable element automatically when opened.\r\n     * Defaults to false in when `mode` is set to `side`, otherwise defaults to `true`. If explicitly\r\n     * enabled, focus will be moved into the sidenav in `side` mode as well.\r\n     */\r\n    get autoFocus() {\r\n        const value = this._autoFocus;\r\n        // Note that usually we disable auto focusing in `side` mode, because we don't know how the\r\n        // sidenav is being used, but in some cases it still makes sense to do it. If the consumer\r\n        // explicitly enabled `autoFocus`, we take it as them always wanting to enable it.\r\n        return value == null ? this.mode !== 'side' : value;\r\n    }\r\n    set autoFocus(value) { this._autoFocus = coerceBooleanProperty(value); }\r\n    /**\r\n     * Whether the drawer is opened. We overload this because we trigger an event when it\r\n     * starts or end.\r\n     */\r\n    get opened() { return this._opened; }\r\n    set opened(value) { this.toggle(coerceBooleanProperty(value)); }\r\n    /**\r\n     * Moves focus into the drawer. Note that this works even if\r\n     * the focus trap is disabled in `side` mode.\r\n     */\r\n    _takeFocus() {\r\n        if (!this.autoFocus || !this._focusTrap) {\r\n            return;\r\n        }\r\n        this._focusTrap.focusInitialElementWhenReady().then(hasMovedFocus => {\r\n            // If there were no focusable elements, focus the sidenav itself so the keyboard navigation\r\n            // still works. We need to check that `focus` is a function due to Universal.\r\n            if (!hasMovedFocus && typeof this._elementRef.nativeElement.focus === 'function') {\r\n                this._elementRef.nativeElement.focus();\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Restores focus to the element that was originally focused when the drawer opened.\r\n     * If no element was focused at that time, the focus will be restored to the drawer.\r\n     */\r\n    _restoreFocus() {\r\n        if (!this.autoFocus) {\r\n            return;\r\n        }\r\n        // Note that we don't check via `instanceof HTMLElement` so that we can cover SVGs as well.\r\n        if (this._elementFocusedBeforeDrawerWasOpened) {\r\n            this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, this._openedVia);\r\n        }\r\n        else {\r\n            this._elementRef.nativeElement.blur();\r\n        }\r\n        this._elementFocusedBeforeDrawerWasOpened = null;\r\n        this._openedVia = null;\r\n    }\r\n    /** Whether focus is currently within the drawer. */\r\n    _isFocusWithinDrawer() {\r\n        var _a;\r\n        const activeEl = (_a = this._doc) === null || _a === void 0 ? void 0 : _a.activeElement;\r\n        return !!activeEl && this._elementRef.nativeElement.contains(activeEl);\r\n    }\r\n    ngAfterContentInit() {\r\n        this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\r\n        this._updateFocusTrapState();\r\n    }\r\n    ngAfterContentChecked() {\r\n        // Enable the animations after the lifecycle hooks have run, in order to avoid animating\r\n        // drawers that are open by default. When we're on the server, we shouldn't enable the\r\n        // animations, because we don't want the drawer to animate the first time the user sees\r\n        // the page.\r\n        if (this._platform.isBrowser) {\r\n            this._enableAnimations = true;\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        if (this._focusTrap) {\r\n            this._focusTrap.destroy();\r\n        }\r\n        this._animationStarted.complete();\r\n        this._animationEnd.complete();\r\n        this._modeChanged.complete();\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n    }\r\n    /**\r\n     * Open the drawer.\r\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\r\n     * Used for focus management after the sidenav is closed.\r\n     */\r\n    open(openedVia) {\r\n        return this.toggle(true, openedVia);\r\n    }\r\n    /** Close the drawer. */\r\n    close() {\r\n        return this.toggle(false);\r\n    }\r\n    /** Closes the drawer with context that the backdrop was clicked. */\r\n    _closeViaBackdropClick() {\r\n        // If the drawer is closed upon a backdrop click, we always want to restore focus. We\r\n        // don't need to check whether focus is currently in the drawer, as clicking on the\r\n        // backdrop causes blurring of the active element.\r\n        return this._setOpen(/* isOpen */ false, /* restoreFocus */ true);\r\n    }\r\n    /**\r\n     * Toggle this drawer.\r\n     * @param isOpen Whether the drawer should be open.\r\n     * @param openedVia Whether the drawer was opened by a key press, mouse click or programmatically.\r\n     * Used for focus management after the sidenav is closed.\r\n     */\r\n    toggle(isOpen = !this.opened, openedVia) {\r\n        // If the focus is currently inside the drawer content and we are closing the drawer,\r\n        // restore the focus to the initially focused element (when the drawer opened).\r\n        return this._setOpen(isOpen, /* restoreFocus */ !isOpen && this._isFocusWithinDrawer(), openedVia);\r\n    }\r\n    /**\r\n     * Toggles the opened state of the drawer.\r\n     * @param isOpen Whether the drawer should open or close.\r\n     * @param restoreFocus Whether focus should be restored on close.\r\n     * @param openedVia Focus origin that can be optionally set when opening a drawer. The\r\n     *   origin will be used later when focus is restored on drawer close.\r\n     */\r\n    _setOpen(isOpen, restoreFocus, openedVia = 'program') {\r\n        this._opened = isOpen;\r\n        if (isOpen) {\r\n            this._animationState = this._enableAnimations ? 'open' : 'open-instant';\r\n            this._openedVia = openedVia;\r\n        }\r\n        else {\r\n            this._animationState = 'void';\r\n            if (restoreFocus) {\r\n                this._restoreFocus();\r\n            }\r\n        }\r\n        this._updateFocusTrapState();\r\n        return new Promise(resolve => {\r\n            this.openedChange.pipe(take(1)).subscribe(open => resolve(open ? 'open' : 'close'));\r\n        });\r\n    }\r\n    _getWidth() {\r\n        return this._elementRef.nativeElement ? (this._elementRef.nativeElement.offsetWidth || 0) : 0;\r\n    }\r\n    /** Updates the enabled state of the focus trap. */\r\n    _updateFocusTrapState() {\r\n        if (this._focusTrap) {\r\n            // The focus trap is only enabled when the drawer is open in any mode other than side.\r\n            this._focusTrap.enabled = this.opened && this.mode !== 'side';\r\n        }\r\n    }\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    _animationStartListener(event) {\r\n        this._animationStarted.next(event);\r\n    }\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    _animationDoneListener(event) {\r\n        this._animationEnd.next(event);\r\n    }\r\n}\r\nMatDrawer.ɵfac = function MatDrawer_Factory(t) { return new (t || MatDrawer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusTrapFactory), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Platform), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(MAT_DRAWER_CONTAINER, 8)); };\r\nMatDrawer.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatDrawer, selectors: [[\"mat-drawer\"]], hostAttrs: [\"tabIndex\", \"-1\", 1, \"mat-drawer\"], hostVars: 12, hostBindings: function MatDrawer_HostBindings(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵsyntheticHostListener(\"@transform.start\", function MatDrawer_animation_transform_start_HostBindingHandler($event) { return ctx._animationStartListener($event); })(\"@transform.done\", function MatDrawer_animation_transform_done_HostBindingHandler($event) { return ctx._animationDoneListener($event); });\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵattribute(\"align\", null);\r\n        ɵngcc0.ɵɵsyntheticHostProperty(\"@transform\", ctx._animationState);\r\n        ɵngcc0.ɵɵclassProp(\"mat-drawer-end\", ctx.position === \"end\")(\"mat-drawer-over\", ctx.mode === \"over\")(\"mat-drawer-push\", ctx.mode === \"push\")(\"mat-drawer-side\", ctx.mode === \"side\")(\"mat-drawer-opened\", ctx.opened);\r\n    } }, inputs: { position: \"position\", mode: \"mode\", disableClose: \"disableClose\", autoFocus: \"autoFocus\", opened: \"opened\" }, outputs: { openedChange: \"openedChange\", _openedStream: \"opened\", openedStart: \"openedStart\", _closedStream: \"closed\", closedStart: \"closedStart\", onPositionChanged: \"positionChanged\" }, exportAs: [\"matDrawer\"], ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[\"cdkScrollable\", \"\", 1, \"mat-drawer-inner-container\"]], template: function MatDrawer_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef();\r\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\r\n        ɵngcc0.ɵɵprojection(1);\r\n        ɵngcc0.ɵɵelementEnd();\r\n    } }, directives: [ɵngcc1.CdkScrollable], encapsulation: 2, data: { animation: [matDrawerAnimations.transformDrawer] }, changeDetection: 0 });\r\nMatDrawer.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: FocusTrapFactory },\r\n    { type: FocusMonitor },\r\n    { type: Platform },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },\r\n    { type: MatDrawerContainer, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DRAWER_CONTAINER,] }] }\r\n];\r\nMatDrawer.propDecorators = {\r\n    position: [{ type: Input }],\r\n    mode: [{ type: Input }],\r\n    disableClose: [{ type: Input }],\r\n    autoFocus: [{ type: Input }],\r\n    opened: [{ type: Input }],\r\n    _animationState: [{ type: HostBinding, args: ['@transform',] }],\r\n    openedChange: [{ type: Output }],\r\n    _openedStream: [{ type: Output, args: ['opened',] }],\r\n    openedStart: [{ type: Output }],\r\n    _closedStream: [{ type: Output, args: ['closed',] }],\r\n    closedStart: [{ type: Output }],\r\n    onPositionChanged: [{ type: Output, args: ['positionChanged',] }],\r\n    _animationStartListener: [{ type: HostListener, args: ['@transform.start', ['$event'],] }],\r\n    _animationDoneListener: [{ type: HostListener, args: ['@transform.done', ['$event'],] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatDrawer, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'mat-drawer',\r\n                exportAs: 'matDrawer',\r\n                template: \"<div class=\\\"mat-drawer-inner-container\\\" cdkScrollable>\\r\\n  <ng-content></ng-content>\\r\\n</div>\\r\\n\",\r\n                animations: [matDrawerAnimations.transformDrawer],\r\n                host: {\r\n                    'class': 'mat-drawer',\r\n                    // must prevent the browser from aligning text based on value\r\n                    '[attr.align]': 'null',\r\n                    '[class.mat-drawer-end]': 'position === \"end\"',\r\n                    '[class.mat-drawer-over]': 'mode === \"over\"',\r\n                    '[class.mat-drawer-push]': 'mode === \"push\"',\r\n                    '[class.mat-drawer-side]': 'mode === \"side\"',\r\n                    '[class.mat-drawer-opened]': 'opened',\r\n                    'tabIndex': '-1'\r\n                },\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc2.FocusTrapFactory }, { type: ɵngcc2.FocusMonitor }, { type: ɵngcc3.Platform }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [DOCUMENT]\r\n            }] }, { type: MatDrawerContainer, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [MAT_DRAWER_CONTAINER]\r\n            }] }]; }, { _animationState: [{\r\n            type: HostBinding,\r\n            args: ['@transform']\r\n        }], openedChange: [{\r\n            type: Output\r\n        }], _openedStream: [{\r\n            type: Output,\r\n            args: ['opened']\r\n        }], openedStart: [{\r\n            type: Output\r\n        }], _closedStream: [{\r\n            type: Output,\r\n            args: ['closed']\r\n        }], closedStart: [{\r\n            type: Output\r\n        }], onPositionChanged: [{\r\n            type: Output,\r\n            args: ['positionChanged']\r\n        }], position: [{\r\n            type: Input\r\n        }], mode: [{\r\n            type: Input\r\n        }], disableClose: [{\r\n            type: Input\r\n        }], autoFocus: [{\r\n            type: Input\r\n        }], opened: [{\r\n            type: Input\r\n        }], \r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    _animationStartListener: [{\r\n            type: HostListener,\r\n            args: ['@transform.start', ['$event']]\r\n        }], \r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    _animationDoneListener: [{\r\n            type: HostListener,\r\n            args: ['@transform.done', ['$event']]\r\n        }] }); })();\r\n/**\r\n * `<mat-drawer-container>` component.\r\n *\r\n * This is the parent component to one or two `<mat-drawer>`s that validates the state internally\r\n * and coordinates the backdrop and content styling.\r\n */\r\nclass MatDrawerContainer {\r\n    constructor(_dir, _element, _ngZone, _changeDetectorRef, viewportRuler, defaultAutosize = false, _animationMode) {\r\n        this._dir = _dir;\r\n        this._element = _element;\r\n        this._ngZone = _ngZone;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._animationMode = _animationMode;\r\n        /** Drawers that belong to this container. */\r\n        this._drawers = new QueryList();\r\n        /** Event emitted when the drawer backdrop is clicked. */\r\n        this.backdropClick = new EventEmitter();\r\n        /** Emits when the component is destroyed. */\r\n        this._destroyed = new Subject();\r\n        /** Emits on every ngDoCheck. Used for debouncing reflows. */\r\n        this._doCheckSubject = new Subject();\r\n        /**\r\n         * Margins to be applied to the content. These are used to push / shrink the drawer content when a\r\n         * drawer is open. We use margin rather than transform even for push mode because transform breaks\r\n         * fixed position elements inside of the transformed element.\r\n         */\r\n        this._contentMargins = { left: null, right: null };\r\n        this._contentMarginChanges = new Subject();\r\n        // If a `Dir` directive exists up the tree, listen direction changes\r\n        // and update the left/right properties to point to the proper start/end.\r\n        if (_dir) {\r\n            _dir.change.pipe(takeUntil(this._destroyed)).subscribe(() => {\r\n                this._validateDrawers();\r\n                this.updateContentMargins();\r\n            });\r\n        }\r\n        // Since the minimum width of the sidenav depends on the viewport width,\r\n        // we need to recompute the margins if the viewport changes.\r\n        viewportRuler.change()\r\n            .pipe(takeUntil(this._destroyed))\r\n            .subscribe(() => this.updateContentMargins());\r\n        this._autosize = defaultAutosize;\r\n    }\r\n    /** The drawer child with the `start` position. */\r\n    get start() { return this._start; }\r\n    /** The drawer child with the `end` position. */\r\n    get end() { return this._end; }\r\n    /**\r\n     * Whether to automatically resize the container whenever\r\n     * the size of any of its drawers changes.\r\n     *\r\n     * **Use at your own risk!** Enabling this option can cause layout thrashing by measuring\r\n     * the drawers on every change detection cycle. Can be configured globally via the\r\n     * `MAT_DRAWER_DEFAULT_AUTOSIZE` token.\r\n     */\r\n    get autosize() { return this._autosize; }\r\n    set autosize(value) { this._autosize = coerceBooleanProperty(value); }\r\n    /**\r\n     * Whether the drawer container should have a backdrop while one of the sidenavs is open.\r\n     * If explicitly set to `true`, the backdrop will be enabled for drawers in the `side`\r\n     * mode as well.\r\n     */\r\n    get hasBackdrop() {\r\n        if (this._backdropOverride == null) {\r\n            return !this._start || this._start.mode !== 'side' || !this._end || this._end.mode !== 'side';\r\n        }\r\n        return this._backdropOverride;\r\n    }\r\n    set hasBackdrop(value) {\r\n        this._backdropOverride = value == null ? null : coerceBooleanProperty(value);\r\n    }\r\n    /** Reference to the CdkScrollable instance that wraps the scrollable content. */\r\n    get scrollable() {\r\n        return this._userContent || this._content;\r\n    }\r\n    ngAfterContentInit() {\r\n        this._allDrawers.changes\r\n            .pipe(startWith(this._allDrawers), takeUntil(this._destroyed))\r\n            .subscribe((drawer) => {\r\n            this._drawers.reset(drawer.filter(item => !item._container || item._container === this));\r\n            this._drawers.notifyOnChanges();\r\n        });\r\n        this._drawers.changes.pipe(startWith(null)).subscribe(() => {\r\n            this._validateDrawers();\r\n            this._drawers.forEach((drawer) => {\r\n                this._watchDrawerToggle(drawer);\r\n                this._watchDrawerPosition(drawer);\r\n                this._watchDrawerMode(drawer);\r\n            });\r\n            if (!this._drawers.length ||\r\n                this._isDrawerOpen(this._start) ||\r\n                this._isDrawerOpen(this._end)) {\r\n                this.updateContentMargins();\r\n            }\r\n            this._changeDetectorRef.markForCheck();\r\n        });\r\n        // Avoid hitting the NgZone through the debounce timeout.\r\n        this._ngZone.runOutsideAngular(() => {\r\n            this._doCheckSubject.pipe(debounceTime(10), // Arbitrary debounce time, less than a frame at 60fps\r\n            takeUntil(this._destroyed)).subscribe(() => this.updateContentMargins());\r\n        });\r\n    }\r\n    ngOnDestroy() {\r\n        this._contentMarginChanges.complete();\r\n        this._doCheckSubject.complete();\r\n        this._drawers.destroy();\r\n        this._destroyed.next();\r\n        this._destroyed.complete();\r\n    }\r\n    /** Calls `open` of both start and end drawers */\r\n    open() {\r\n        this._drawers.forEach(drawer => drawer.open());\r\n    }\r\n    /** Calls `close` of both start and end drawers */\r\n    close() {\r\n        this._drawers.forEach(drawer => drawer.close());\r\n    }\r\n    /**\r\n     * Recalculates and updates the inline styles for the content. Note that this should be used\r\n     * sparingly, because it causes a reflow.\r\n     */\r\n    updateContentMargins() {\r\n        // 1. For drawers in `over` mode, they don't affect the content.\r\n        // 2. For drawers in `side` mode they should shrink the content. We do this by adding to the\r\n        //    left margin (for left drawer) or right margin (for right the drawer).\r\n        // 3. For drawers in `push` mode the should shift the content without resizing it. We do this by\r\n        //    adding to the left or right margin and simultaneously subtracting the same amount of\r\n        //    margin from the other side.\r\n        let left = 0;\r\n        let right = 0;\r\n        if (this._left && this._left.opened) {\r\n            if (this._left.mode == 'side') {\r\n                left += this._left._getWidth();\r\n            }\r\n            else if (this._left.mode == 'push') {\r\n                const width = this._left._getWidth();\r\n                left += width;\r\n                right -= width;\r\n            }\r\n        }\r\n        if (this._right && this._right.opened) {\r\n            if (this._right.mode == 'side') {\r\n                right += this._right._getWidth();\r\n            }\r\n            else if (this._right.mode == 'push') {\r\n                const width = this._right._getWidth();\r\n                right += width;\r\n                left -= width;\r\n            }\r\n        }\r\n        // If either `right` or `left` is zero, don't set a style to the element. This\r\n        // allows users to specify a custom size via CSS class in SSR scenarios where the\r\n        // measured widths will always be zero. Note that we reset to `null` here, rather\r\n        // than below, in order to ensure that the types in the `if` below are consistent.\r\n        left = left || null;\r\n        right = right || null;\r\n        if (left !== this._contentMargins.left || right !== this._contentMargins.right) {\r\n            this._contentMargins = { left, right };\r\n            // Pull back into the NgZone since in some cases we could be outside. We need to be careful\r\n            // to do it only when something changed, otherwise we can end up hitting the zone too often.\r\n            this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins));\r\n        }\r\n    }\r\n    ngDoCheck() {\r\n        // If users opted into autosizing, do a check every change detection cycle.\r\n        if (this._autosize && this._isPushed()) {\r\n            // Run outside the NgZone, otherwise the debouncer will throw us into an infinite loop.\r\n            this._ngZone.runOutsideAngular(() => this._doCheckSubject.next());\r\n        }\r\n    }\r\n    /**\r\n     * Subscribes to drawer events in order to set a class on the main container element when the\r\n     * drawer is open and the backdrop is visible. This ensures any overflow on the container element\r\n     * is properly hidden.\r\n     */\r\n    _watchDrawerToggle(drawer) {\r\n        drawer._animationStarted.pipe(filter((event) => event.fromState !== event.toState), takeUntil(this._drawers.changes))\r\n            .subscribe((event) => {\r\n            // Set the transition class on the container so that the animations occur. This should not\r\n            // be set initially because animations should only be triggered via a change in state.\r\n            if (event.toState !== 'open-instant' && this._animationMode !== 'NoopAnimations') {\r\n                this._element.nativeElement.classList.add('mat-drawer-transition');\r\n            }\r\n            this.updateContentMargins();\r\n            this._changeDetectorRef.markForCheck();\r\n        });\r\n        if (drawer.mode !== 'side') {\r\n            drawer.openedChange.pipe(takeUntil(this._drawers.changes)).subscribe(() => this._setContainerClass(drawer.opened));\r\n        }\r\n    }\r\n    /**\r\n     * Subscribes to drawer onPositionChanged event in order to\r\n     * re-validate drawers when the position changes.\r\n     */\r\n    _watchDrawerPosition(drawer) {\r\n        if (!drawer) {\r\n            return;\r\n        }\r\n        // NOTE: We need to wait for the microtask queue to be empty before validating,\r\n        // since both drawers may be swapping positions at the same time.\r\n        drawer.onPositionChanged.pipe(takeUntil(this._drawers.changes)).subscribe(() => {\r\n            this._ngZone.onMicrotaskEmpty.pipe(take(1)).subscribe(() => {\r\n                this._validateDrawers();\r\n            });\r\n        });\r\n    }\r\n    /** Subscribes to changes in drawer mode so we can run change detection. */\r\n    _watchDrawerMode(drawer) {\r\n        if (drawer) {\r\n            drawer._modeChanged.pipe(takeUntil(merge(this._drawers.changes, this._destroyed)))\r\n                .subscribe(() => {\r\n                this.updateContentMargins();\r\n                this._changeDetectorRef.markForCheck();\r\n            });\r\n        }\r\n    }\r\n    /** Toggles the 'mat-drawer-opened' class on the main 'mat-drawer-container' element. */\r\n    _setContainerClass(isAdd) {\r\n        const classList = this._element.nativeElement.classList;\r\n        const className = 'mat-drawer-container-has-open';\r\n        if (isAdd) {\r\n            classList.add(className);\r\n        }\r\n        else {\r\n            classList.remove(className);\r\n        }\r\n    }\r\n    /** Validate the state of the drawer children components. */\r\n    _validateDrawers() {\r\n        this._start = this._end = null;\r\n        // Ensure that we have at most one start and one end drawer.\r\n        this._drawers.forEach(drawer => {\r\n            if (drawer.position == 'end') {\r\n                if (this._end != null && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n                    throwMatDuplicatedDrawerError('end');\r\n                }\r\n                this._end = drawer;\r\n            }\r\n            else {\r\n                if (this._start != null && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n                    throwMatDuplicatedDrawerError('start');\r\n                }\r\n                this._start = drawer;\r\n            }\r\n        });\r\n        this._right = this._left = null;\r\n        // Detect if we're LTR or RTL.\r\n        if (this._dir && this._dir.value === 'rtl') {\r\n            this._left = this._end;\r\n            this._right = this._start;\r\n        }\r\n        else {\r\n            this._left = this._start;\r\n            this._right = this._end;\r\n        }\r\n    }\r\n    /** Whether the container is being pushed to the side by one of the drawers. */\r\n    _isPushed() {\r\n        return (this._isDrawerOpen(this._start) && this._start.mode != 'over') ||\r\n            (this._isDrawerOpen(this._end) && this._end.mode != 'over');\r\n    }\r\n    _onBackdropClicked() {\r\n        this.backdropClick.emit();\r\n        this._closeModalDrawersViaBackdrop();\r\n    }\r\n    _closeModalDrawersViaBackdrop() {\r\n        // Close all open drawers where closing is not disabled and the mode is not `side`.\r\n        [this._start, this._end]\r\n            .filter(drawer => drawer && !drawer.disableClose && this._canHaveBackdrop(drawer))\r\n            .forEach(drawer => drawer._closeViaBackdropClick());\r\n    }\r\n    _isShowingBackdrop() {\r\n        return (this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start)) ||\r\n            (this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end));\r\n    }\r\n    _canHaveBackdrop(drawer) {\r\n        return drawer.mode !== 'side' || !!this._backdropOverride;\r\n    }\r\n    _isDrawerOpen(drawer) {\r\n        return drawer != null && drawer.opened;\r\n    }\r\n}\r\nMatDrawerContainer.ɵfac = function MatDrawerContainer_Factory(t) { return new (t || MatDrawerContainer)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ViewportRuler), ɵngcc0.ɵɵdirectiveInject(MAT_DRAWER_DEFAULT_AUTOSIZE), ɵngcc0.ɵɵdirectiveInject(ANIMATION_MODULE_TYPE, 8)); };\r\nMatDrawerContainer.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatDrawerContainer, selectors: [[\"mat-drawer-container\"]], contentQueries: function MatDrawerContainer_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatDrawerContent, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatDrawer, 5);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._content = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._allDrawers = _t);\r\n    } }, viewQuery: function MatDrawerContainer_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵviewQuery(MatDrawerContent, 5);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._userContent = _t.first);\r\n    } }, hostAttrs: [1, \"mat-drawer-container\"], hostVars: 2, hostBindings: function MatDrawerContainer_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵclassProp(\"mat-drawer-container-explicit-backdrop\", ctx._backdropOverride);\r\n    } }, inputs: { autosize: \"autosize\", hasBackdrop: \"hasBackdrop\" }, outputs: { backdropClick: \"backdropClick\" }, exportAs: [\"matDrawerContainer\"], features: [ɵngcc0.ɵɵProvidersFeature([{\r\n                provide: MAT_DRAWER_CONTAINER,\r\n                useExisting: MatDrawerContainer\r\n            }])], ngContentSelectors: _c2, decls: 4, vars: 2, consts: [[\"class\", \"mat-drawer-backdrop\", 3, \"mat-drawer-shown\", \"click\", 4, \"ngIf\"], [4, \"ngIf\"], [1, \"mat-drawer-backdrop\", 3, \"click\"]], template: function MatDrawerContainer_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef(_c1);\r\n        ɵngcc0.ɵɵtemplate(0, MatDrawerContainer_div_0_Template, 1, 2, \"div\", 0);\r\n        ɵngcc0.ɵɵprojection(1);\r\n        ɵngcc0.ɵɵprojection(2, 1);\r\n        ɵngcc0.ɵɵtemplate(3, MatDrawerContainer_mat_drawer_content_3_Template, 2, 0, \"mat-drawer-content\", 1);\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.hasBackdrop);\r\n        ɵngcc0.ɵɵadvance(3);\r\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx._content);\r\n    } }, directives: [ɵngcc5.NgIf, MatDrawerContent], styles: [_c5], encapsulation: 2, changeDetection: 0 });\r\nMatDrawerContainer.ctorParameters = () => [\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: ElementRef },\r\n    { type: NgZone },\r\n    { type: ChangeDetectorRef },\r\n    { type: ViewportRuler },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_DRAWER_DEFAULT_AUTOSIZE,] }] },\r\n    { type: String, decorators: [{ type: Optional }, { type: Inject, args: [ANIMATION_MODULE_TYPE,] }] }\r\n];\r\nMatDrawerContainer.propDecorators = {\r\n    _allDrawers: [{ type: ContentChildren, args: [MatDrawer, {\r\n                    // We need to use `descendants: true`, because Ivy will no longer match\r\n                    // indirect descendants if it's left as false.\r\n                    descendants: true\r\n                },] }],\r\n    _content: [{ type: ContentChild, args: [MatDrawerContent,] }],\r\n    _userContent: [{ type: ViewChild, args: [MatDrawerContent,] }],\r\n    autosize: [{ type: Input }],\r\n    hasBackdrop: [{ type: Input }],\r\n    backdropClick: [{ type: Output }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatDrawerContainer, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'mat-drawer-container',\r\n                exportAs: 'matDrawerContainer',\r\n                template: \"<div class=\\\"mat-drawer-backdrop\\\" (click)=\\\"_onBackdropClicked()\\\" *ngIf=\\\"hasBackdrop\\\"\\n     [class.mat-drawer-shown]=\\\"_isShowingBackdrop()\\\"></div>\\n\\n<ng-content select=\\\"mat-drawer\\\"></ng-content>\\n\\n<ng-content select=\\\"mat-drawer-content\\\">\\n</ng-content>\\n<mat-drawer-content *ngIf=\\\"!_content\\\">\\n  <ng-content></ng-content>\\n</mat-drawer-content>\\n\",\r\n                host: {\r\n                    'class': 'mat-drawer-container',\r\n                    '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride'\r\n                },\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None,\r\n                providers: [{\r\n                        provide: MAT_DRAWER_CONTAINER,\r\n                        useExisting: MatDrawerContainer\r\n                    }],\r\n                styles: [\".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\\n\"]\r\n            }]\r\n    }], function () { return [{ type: ɵngcc4.Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc1.ViewportRuler }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [MAT_DRAWER_DEFAULT_AUTOSIZE]\r\n            }] }, { type: String, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [ANIMATION_MODULE_TYPE]\r\n            }] }]; }, { backdropClick: [{\r\n            type: Output\r\n        }], autosize: [{\r\n            type: Input\r\n        }], hasBackdrop: [{\r\n            type: Input\r\n        }], _allDrawers: [{\r\n            type: ContentChildren,\r\n            args: [MatDrawer, {\r\n                    // We need to use `descendants: true`, because Ivy will no longer match\r\n                    // indirect descendants if it's left as false.\r\n                    descendants: true\r\n                }]\r\n        }], _content: [{\r\n            type: ContentChild,\r\n            args: [MatDrawerContent]\r\n        }], _userContent: [{\r\n            type: ViewChild,\r\n            args: [MatDrawerContent]\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass MatSidenavContent extends MatDrawerContent {\r\n    constructor(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone) {\r\n        super(changeDetectorRef, container, elementRef, scrollDispatcher, ngZone);\r\n    }\r\n}\r\nMatSidenavContent.ɵfac = function MatSidenavContent_Factory(t) { return new (t || MatSidenavContent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(forwardRef(() => MatSidenavContainer)), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.ScrollDispatcher), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };\r\nMatSidenavContent.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatSidenavContent, selectors: [[\"mat-sidenav-content\"]], hostAttrs: [1, \"mat-drawer-content\", \"mat-sidenav-content\"], hostVars: 4, hostBindings: function MatSidenavContent_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵstyleProp(\"margin-left\", ctx._container._contentMargins.left, \"px\")(\"margin-right\", ctx._container._contentMargins.right, \"px\");\r\n    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 1, vars: 0, template: function MatSidenavContent_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef();\r\n        ɵngcc0.ɵɵprojection(0);\r\n    } }, encapsulation: 2, changeDetection: 0 });\r\nMatSidenavContent.ctorParameters = () => [\r\n    { type: ChangeDetectorRef },\r\n    { type: MatSidenavContainer, decorators: [{ type: Inject, args: [forwardRef(() => MatSidenavContainer),] }] },\r\n    { type: ElementRef },\r\n    { type: ScrollDispatcher },\r\n    { type: NgZone }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatSidenavContent, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'mat-sidenav-content',\r\n                template: '<ng-content></ng-content>',\r\n                host: {\r\n                    'class': 'mat-drawer-content mat-sidenav-content',\r\n                    '[style.margin-left.px]': '_container._contentMargins.left',\r\n                    '[style.margin-right.px]': '_container._contentMargins.right'\r\n                },\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.ChangeDetectorRef }, { type: MatSidenavContainer, decorators: [{\r\n                type: Inject,\r\n                args: [forwardRef(() => MatSidenavContainer)]\r\n            }] }, { type: ɵngcc0.ElementRef }, { type: ɵngcc1.ScrollDispatcher }, { type: ɵngcc0.NgZone }]; }, null); })();\r\nclass MatSidenav extends MatDrawer {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._fixedInViewport = false;\r\n        this._fixedTopGap = 0;\r\n        this._fixedBottomGap = 0;\r\n    }\r\n    /** Whether the sidenav is fixed in the viewport. */\r\n    get fixedInViewport() { return this._fixedInViewport; }\r\n    set fixedInViewport(value) { this._fixedInViewport = coerceBooleanProperty(value); }\r\n    /**\r\n     * The gap between the top of the sidenav and the top of the viewport when the sidenav is in fixed\r\n     * mode.\r\n     */\r\n    get fixedTopGap() { return this._fixedTopGap; }\r\n    set fixedTopGap(value) { this._fixedTopGap = coerceNumberProperty(value); }\r\n    /**\r\n     * The gap between the bottom of the sidenav and the bottom of the viewport when the sidenav is in\r\n     * fixed mode.\r\n     */\r\n    get fixedBottomGap() { return this._fixedBottomGap; }\r\n    set fixedBottomGap(value) { this._fixedBottomGap = coerceNumberProperty(value); }\r\n}\r\nMatSidenav.ɵfac = /*@__PURE__*/ function () { let ɵMatSidenav_BaseFactory; return function MatSidenav_Factory(t) { return (ɵMatSidenav_BaseFactory || (ɵMatSidenav_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatSidenav)))(t || MatSidenav); }; }();\r\nMatSidenav.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatSidenav, selectors: [[\"mat-sidenav\"]], hostAttrs: [\"tabIndex\", \"-1\", 1, \"mat-drawer\", \"mat-sidenav\"], hostVars: 17, hostBindings: function MatSidenav_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵattribute(\"align\", null);\r\n        ɵngcc0.ɵɵstyleProp(\"top\", ctx.fixedInViewport ? ctx.fixedTopGap : null, \"px\")(\"bottom\", ctx.fixedInViewport ? ctx.fixedBottomGap : null, \"px\");\r\n        ɵngcc0.ɵɵclassProp(\"mat-drawer-end\", ctx.position === \"end\")(\"mat-drawer-over\", ctx.mode === \"over\")(\"mat-drawer-push\", ctx.mode === \"push\")(\"mat-drawer-side\", ctx.mode === \"side\")(\"mat-drawer-opened\", ctx.opened)(\"mat-sidenav-fixed\", ctx.fixedInViewport);\r\n    } }, inputs: { fixedInViewport: \"fixedInViewport\", fixedTopGap: \"fixedTopGap\", fixedBottomGap: \"fixedBottomGap\" }, exportAs: [\"matSidenav\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c0, decls: 2, vars: 0, consts: [[\"cdkScrollable\", \"\", 1, \"mat-drawer-inner-container\"]], template: function MatSidenav_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef();\r\n        ɵngcc0.ɵɵelementStart(0, \"div\", 0);\r\n        ɵngcc0.ɵɵprojection(1);\r\n        ɵngcc0.ɵɵelementEnd();\r\n    } }, directives: [ɵngcc1.CdkScrollable], encapsulation: 2, data: { animation: [matDrawerAnimations.transformDrawer] }, changeDetection: 0 });\r\nMatSidenav.propDecorators = {\r\n    fixedInViewport: [{ type: Input }],\r\n    fixedTopGap: [{ type: Input }],\r\n    fixedBottomGap: [{ type: Input }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatSidenav, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'mat-sidenav',\r\n                exportAs: 'matSidenav',\r\n                template: \"<div class=\\\"mat-drawer-inner-container\\\" cdkScrollable>\\r\\n  <ng-content></ng-content>\\r\\n</div>\\r\\n\",\r\n                animations: [matDrawerAnimations.transformDrawer],\r\n                host: {\r\n                    'class': 'mat-drawer mat-sidenav',\r\n                    'tabIndex': '-1',\r\n                    // must prevent the browser from aligning text based on value\r\n                    '[attr.align]': 'null',\r\n                    '[class.mat-drawer-end]': 'position === \"end\"',\r\n                    '[class.mat-drawer-over]': 'mode === \"over\"',\r\n                    '[class.mat-drawer-push]': 'mode === \"push\"',\r\n                    '[class.mat-drawer-side]': 'mode === \"side\"',\r\n                    '[class.mat-drawer-opened]': 'opened',\r\n                    '[class.mat-sidenav-fixed]': 'fixedInViewport',\r\n                    '[style.top.px]': 'fixedInViewport ? fixedTopGap : null',\r\n                    '[style.bottom.px]': 'fixedInViewport ? fixedBottomGap : null'\r\n                },\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None\r\n            }]\r\n    }], null, { fixedInViewport: [{\r\n            type: Input\r\n        }], fixedTopGap: [{\r\n            type: Input\r\n        }], fixedBottomGap: [{\r\n            type: Input\r\n        }] }); })();\r\nclass MatSidenavContainer extends MatDrawerContainer {\r\n}\r\nMatSidenavContainer.ɵfac = /*@__PURE__*/ function () { let ɵMatSidenavContainer_BaseFactory; return function MatSidenavContainer_Factory(t) { return (ɵMatSidenavContainer_BaseFactory || (ɵMatSidenavContainer_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatSidenavContainer)))(t || MatSidenavContainer); }; }();\r\nMatSidenavContainer.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatSidenavContainer, selectors: [[\"mat-sidenav-container\"]], contentQueries: function MatSidenavContainer_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatSidenavContent, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatSidenav, 5);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._content = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._allDrawers = _t);\r\n    } }, hostAttrs: [1, \"mat-drawer-container\", \"mat-sidenav-container\"], hostVars: 2, hostBindings: function MatSidenavContainer_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵclassProp(\"mat-drawer-container-explicit-backdrop\", ctx._backdropOverride);\r\n    } }, exportAs: [\"matSidenavContainer\"], features: [ɵngcc0.ɵɵProvidersFeature([{\r\n                provide: MAT_DRAWER_CONTAINER,\r\n                useExisting: MatSidenavContainer\r\n            }]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c4, decls: 4, vars: 2, consts: [[\"class\", \"mat-drawer-backdrop\", 3, \"mat-drawer-shown\", \"click\", 4, \"ngIf\"], [\"cdkScrollable\", \"\", 4, \"ngIf\"], [1, \"mat-drawer-backdrop\", 3, \"click\"], [\"cdkScrollable\", \"\"]], template: function MatSidenavContainer_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef(_c3);\r\n        ɵngcc0.ɵɵtemplate(0, MatSidenavContainer_div_0_Template, 1, 2, \"div\", 0);\r\n        ɵngcc0.ɵɵprojection(1);\r\n        ɵngcc0.ɵɵprojection(2, 1);\r\n        ɵngcc0.ɵɵtemplate(3, MatSidenavContainer_mat_sidenav_content_3_Template, 2, 0, \"mat-sidenav-content\", 1);\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.hasBackdrop);\r\n        ɵngcc0.ɵɵadvance(3);\r\n        ɵngcc0.ɵɵproperty(\"ngIf\", !ctx._content);\r\n    } }, directives: [ɵngcc5.NgIf, MatSidenavContent, ɵngcc1.CdkScrollable], styles: [_c5], encapsulation: 2, changeDetection: 0 });\r\nMatSidenavContainer.propDecorators = {\r\n    _allDrawers: [{ type: ContentChildren, args: [MatSidenav, {\r\n                    // We need to use `descendants: true`, because Ivy will no longer match\r\n                    // indirect descendants if it's left as false.\r\n                    descendants: true\r\n                },] }],\r\n    _content: [{ type: ContentChild, args: [MatSidenavContent,] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatSidenavContainer, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'mat-sidenav-container',\r\n                exportAs: 'matSidenavContainer',\r\n                template: \"<div class=\\\"mat-drawer-backdrop\\\" (click)=\\\"_onBackdropClicked()\\\" *ngIf=\\\"hasBackdrop\\\"\\n     [class.mat-drawer-shown]=\\\"_isShowingBackdrop()\\\"></div>\\n\\n<ng-content select=\\\"mat-sidenav\\\"></ng-content>\\n\\n<ng-content select=\\\"mat-sidenav-content\\\">\\n</ng-content>\\n<mat-sidenav-content *ngIf=\\\"!_content\\\" cdkScrollable>\\n  <ng-content></ng-content>\\n</mat-sidenav-content>\\n\",\r\n                host: {\r\n                    'class': 'mat-drawer-container mat-sidenav-container',\r\n                    '[class.mat-drawer-container-explicit-backdrop]': '_backdropOverride'\r\n                },\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None,\r\n                providers: [{\r\n                        provide: MAT_DRAWER_CONTAINER,\r\n                        useExisting: MatSidenavContainer\r\n                    }],\r\n                styles: [\".mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}\\n\"]\r\n            }]\r\n    }], null, { _allDrawers: [{\r\n            type: ContentChildren,\r\n            args: [MatSidenav, {\r\n                    // We need to use `descendants: true`, because Ivy will no longer match\r\n                    // indirect descendants if it's left as false.\r\n                    descendants: true\r\n                }]\r\n        }], _content: [{\r\n            type: ContentChild,\r\n            args: [MatSidenavContent]\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass MatSidenavModule {\r\n}\r\nMatSidenavModule.ɵfac = function MatSidenavModule_Factory(t) { return new (t || MatSidenavModule)(); };\r\nMatSidenavModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MatSidenavModule });\r\nMatSidenavModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ imports: [[\r\n            CommonModule,\r\n            MatCommonModule,\r\n            PlatformModule,\r\n            CdkScrollableModule,\r\n        ], CdkScrollableModule,\r\n        MatCommonModule] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatSidenavModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [\r\n                    CommonModule,\r\n                    MatCommonModule,\r\n                    PlatformModule,\r\n                    CdkScrollableModule,\r\n                ],\r\n                exports: [\r\n                    CdkScrollableModule,\r\n                    MatCommonModule,\r\n                    MatDrawer,\r\n                    MatDrawerContainer,\r\n                    MatDrawerContent,\r\n                    MatSidenav,\r\n                    MatSidenavContainer,\r\n                    MatSidenavContent,\r\n                ],\r\n                declarations: [\r\n                    MatDrawer,\r\n                    MatDrawerContainer,\r\n                    MatDrawerContent,\r\n                    MatSidenav,\r\n                    MatSidenavContainer,\r\n                    MatSidenavContent,\r\n                ]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatSidenavModule, { declarations: function () { return [MatDrawer, MatDrawerContainer, MatDrawerContent, MatSidenav, MatSidenavContainer, MatSidenavContent]; }, imports: function () { return [CommonModule,\r\n        MatCommonModule,\r\n        PlatformModule,\r\n        CdkScrollableModule]; }, exports: function () { return [CdkScrollableModule,\r\n        MatCommonModule, MatDrawer, MatDrawerContainer, MatDrawerContent, MatSidenav, MatSidenavContainer, MatSidenavContent]; } }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { MAT_DRAWER_DEFAULT_AUTOSIZE, MAT_DRAWER_DEFAULT_AUTOSIZE_FACTORY, MatDrawer, MatDrawerContainer, MatDrawerContent, MatSidenav, MatSidenavContainer, MatSidenavContent, MatSidenavModule, matDrawerAnimations, throwMatDuplicatedDrawerError, MAT_DRAWER_CONTAINER as ɵangular_material_src_material_sidenav_sidenav_a };\r\n\r\n//# sourceMappingURL=sidenav.js.map"],"sourceRoot":"webpack:///"}