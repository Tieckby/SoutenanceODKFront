{"version":3,"sources":["./node_modules/@angular/material/__ivy_ngcc__/fesm2015/dialog.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAA+F;AACwB;AACqJ;AACnN;AACN;AACE;AACX;AACe;AACU;AACO;AACO;AAClB;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACwC;AACI;AACE;AACC;AACL;;AAE1C,6DAA6D;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,4DAAO;AAC5B;AACA;AACA;AACA,QAAQ,0DAAK,eAAe,0DAAK,EAAE,sCAAsC;AACzE,QAAQ,0DAAK,UAAU,0DAAK,EAAE,oBAAoB;AAClD,QAAQ,+DAAU,eAAe,4DAAO,qCAAqC,0DAAK,EAAE,gCAAgC;AACpH,QAAQ,+DAAU,yBAAyB,4DAAO,wCAAwC,0DAAK,EAAE,aAAa;AAC9G;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iEAAgB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,uDAAY;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,wFAAiC;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,wFAAiC;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,wFAAiC;AAC/D;AACA;AACA;AACA,4EAA4E,2CAA2C,+DAAwB,CAAC,qDAAiB,GAAG,+DAAwB,CAAC,+DAAuB,GAAG,+DAAwB,CAAC,4DAAwB,GAAG,+DAAwB,CAAC,qDAAQ,MAAM,+DAAwB,mBAAmB,+DAAwB,CAAC,2DAAmB,GAAG;AAC5Y,6CAA6C,+DAAwB,EAAE,4FAA4F;AACnK,QAAQ,yDAAkB,CAAC,gEAAe;AAC1C,KAAK;AACL;AACA,QAAQ,4DAAqB,MAAM,yDAAkB;AACrD,KAAK,EAAE,aAAa,wEAAiC,GAAG;AACxD;AACA,KAAK,OAAO,qDAAU,EAAE;AACxB,KAAK,OAAO,+DAAgB,EAAE;AAC9B,KAAK,OAAO,4DAAiB,EAAE;AAC/B,KAAK,gCAAgC,OAAO,mDAAQ,EAAE,GAAG,OAAO,iDAAM,SAAS,qDAAQ,IAAI,GAAG;AAC9F,KAAK,wBAAwB;AAC7B,KAAK,OAAO,2DAAY;AACxB;AACA;AACA,qBAAqB,OAAO,oDAAS,SAAS,gEAAe,GAAG,eAAe,IAAI;AACnF;AACA,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB,KAAK,gBAAgB,UAAU,OAAO,qDAAiB,EAAE,GAAG,OAAO,+DAAuB,EAAE,GAAG,OAAO,4DAAwB,EAAE,GAAG;AACnI,sBAAsB,mDAAQ;AAC9B,aAAa;AACb,sBAAsB,iDAAM;AAC5B,uBAAuB,qDAAQ;AAC/B,aAAa,GAAG,GAAG,wBAAwB,GAAG,OAAO,2DAAmB,EAAE,EAAE,EAAE,GAAG;AACjF,kBAAkB,oDAAS;AAC3B,mBAAmB,gEAAe,GAAG,eAAe;AACpD,SAAS,GAAG,EAAE,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA,8CAA8C,6BAA6B;AAC3E;AACA;AACA;AACA,8CAA8C,6BAA6B;AAC3E;AACA;AACA;AACA,uBAAuB,qBAAqB;AAC5C;AACA,8CAA8C,8BAA8B;AAC5E;AACA;AACA,8CAA8C,8BAA8B;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,qCAAqC,gDAAgD,+EAA+E,mEAA4B,gDAAgD,GAAG,EAAE;AAC1S,wCAAwC,+DAAwB,EAAE,gOAAgO;AAClS,QAAQ,qEAA8B,mHAAmH,sCAAsC,EAAE,kHAAkH,qCAAqC,EAAE;AAC1V,KAAK;AACL,QAAQ,4DAAqB;AAC7B,QAAQ,yDAAkB;AAC1B,QAAQ,qEAA8B;AACtC,KAAK,EAAE,aAAa,wEAAiC,kHAAkH;AACvK,QAAQ,wDAAiB;AACzB,KAAK,EAAE,eAAe,gEAAsB,mCAAmC,cAAc,aAAa,kBAAkB,sBAAsB,cAAc,UAAU,WAAW,YAAY,mBAAmB,mBAAmB,gDAAgD,kBAAkB,oBAAoB,cAAc,eAAe,eAAe,gBAAgB,cAAc,iCAAiC,kBAAkB,gBAAgB,cAAc,oBAAoB,cAAc,aAAa,eAAe,gBAAgB,mBAAmB,uBAAuB,oBAAoB,+BAA+B,yBAAyB,kCAAkC,uBAAuB,oHAAoH,gBAAgB,wIAAwI,cAAc,iBAAiB,+BAA+B,mDAAmD,EAAE;AACplC,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB;AACA;AACA;AACA,+BAA+B,iEAAsB;AACrD;AACA;AACA,iCAAiC,0EAA+B;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,gDAAgD,cAAc,aAAa,kBAAkB,sBAAsB,cAAc,UAAU,WAAW,YAAY,mBAAmB,mBAAmB,gDAAgD,kBAAkB,oBAAoB,cAAc,eAAe,eAAe,gBAAgB,cAAc,iCAAiC,kBAAkB,gBAAgB,cAAc,oBAAoB,cAAc,aAAa,eAAe,gBAAgB,mBAAmB,uBAAuB,oBAAoB,+BAA+B,yBAAyB,kCAAkC,uBAAuB,oHAAoH,gBAAgB,wIAAwI,cAAc,iBAAiB;AACj+B,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,WAAW;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yCAAO;AACvC;AACA,gCAAgC,yCAAO;AACvC;AACA,iCAAiC,yCAAO;AACxC;AACA;AACA;AACA;AACA;AACA,uDAAuD,sDAAM,qCAAqC,oDAAI;AACtG;AACA;AACA;AACA,SAAS;AACT;AACA,uDAAuD,sDAAM,qCAAqC,oDAAI;AACtG;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,kBAAkB,sDAAM;AACxB,qCAAqC,yDAAM,2BAA2B,qEAAc;AACpF,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,sDAAM,sCAAsC,oDAAI;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,gBAAgB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yDAAc;AAC1C;AACA,uCAAuC,yDAAc;AACrD;AACA,uCAAuC,yDAAc;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0DAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,yCAAO;AACrD,2CAA2C,yCAAO;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,4CAAK;AACnC;AACA,2CAA2C,0DAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAa;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAe;AACxC;AACA,yBAAyB,6CAA6C;AACtE,SAAS;AACT,oCAAoC,gEAAe;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","file":"default-node_modules_angular_material___ivy_ngcc___fesm2015_dialog_js-es2015.js","sourcesContent":["import { Overlay, OverlayConfig, OverlayContainer, OverlayModule } from '@angular/cdk/overlay';\r\nimport { BasePortalOutlet, CdkPortalOutlet, ComponentPortal, TemplatePortal, PortalModule } from '@angular/cdk/portal';\r\nimport { EventEmitter, Directive, ElementRef, ChangeDetectorRef, Optional, Inject, ViewChild, Component, ViewEncapsulation, ChangeDetectionStrategy, InjectionToken, Injector, TemplateRef, InjectFlags, Type, Injectable, SkipSelf, Input, NgModule } from '@angular/core';\r\nimport { MatCommonModule } from '@angular/material/core';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { DOCUMENT, Location } from '@angular/common';\r\nimport { Subject, defer, of } from 'rxjs';\r\nimport { filter, take, startWith } from 'rxjs/operators';\r\nimport { FocusTrapFactory, FocusMonitor } from '@angular/cdk/a11y';\r\nimport { _getFocusedElementPierceShadowDom } from '@angular/cdk/platform';\r\nimport { trigger, state, style, transition, animate } from '@angular/animations';\r\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Configuration for opening a modal dialog with the MatDialog service.\r\n */\r\nimport * as ɵngcc0 from '@angular/core';\r\nimport * as ɵngcc1 from '@angular/cdk/a11y';\r\nimport * as ɵngcc2 from '@angular/cdk/portal';\r\nimport * as ɵngcc3 from '@angular/cdk/overlay';\r\nimport * as ɵngcc4 from '@angular/common';\r\n\r\nfunction MatDialogContainer_ng_template_0_Template(rf, ctx) { }\r\nclass MatDialogConfig {\r\n    constructor() {\r\n        /** The ARIA role of the dialog element. */\r\n        this.role = 'dialog';\r\n        /** Custom class for the overlay pane. */\r\n        this.panelClass = '';\r\n        /** Whether the dialog has a backdrop. */\r\n        this.hasBackdrop = true;\r\n        /** Custom class for the backdrop. */\r\n        this.backdropClass = '';\r\n        /** Whether the user can use escape or clicking on the backdrop to close the modal. */\r\n        this.disableClose = false;\r\n        /** Width of the dialog. */\r\n        this.width = '';\r\n        /** Height of the dialog. */\r\n        this.height = '';\r\n        /** Max-width of the dialog. If a number is provided, assumes pixel units. Defaults to 80vw. */\r\n        this.maxWidth = '80vw';\r\n        /** Data being injected into the child component. */\r\n        this.data = null;\r\n        /** ID of the element that describes the dialog. */\r\n        this.ariaDescribedBy = null;\r\n        /** ID of the element that labels the dialog. */\r\n        this.ariaLabelledBy = null;\r\n        /** Aria label to assign to the dialog element. */\r\n        this.ariaLabel = null;\r\n        /** Whether the dialog should focus the first focusable element on open. */\r\n        this.autoFocus = true;\r\n        /**\r\n         * Whether the dialog should restore focus to the\r\n         * previously-focused element, after it's closed.\r\n         */\r\n        this.restoreFocus = true;\r\n        /**\r\n         * Whether the dialog should close when the user goes backwards/forwards in history.\r\n         * Note that this usually doesn't include clicking on links (unless the user is using\r\n         * the `HashLocationStrategy`).\r\n         */\r\n        this.closeOnNavigation = true;\r\n        // TODO(jelbourn): add configuration for lifecycle hooks, ARIA labelling.\r\n    }\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Animations used by MatDialog.\r\n * @docs-private\r\n */\r\nconst matDialogAnimations = {\r\n    /** Animation that is applied on the dialog container by default. */\r\n    dialogContainer: trigger('dialogContainer', [\r\n        // Note: The `enter` animation transitions to `transform: none`, because for some reason\r\n        // specifying the transform explicitly, causes IE both to blur the dialog content and\r\n        // decimate the animation performance. Leaving it as `none` solves both issues.\r\n        state('void, exit', style({ opacity: 0, transform: 'scale(0.7)' })),\r\n        state('enter', style({ transform: 'none' })),\r\n        transition('* => enter', animate('150ms cubic-bezier(0, 0, 0.2, 1)', style({ transform: 'none', opacity: 1 }))),\r\n        transition('* => void, * => exit', animate('75ms cubic-bezier(0.4, 0.0, 0.2, 1)', style({ opacity: 0 }))),\r\n    ])\r\n};\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Throws an exception for the case when a ComponentPortal is\r\n * attached to a DomPortalOutlet without an origin.\r\n * @docs-private\r\n */\r\nfunction throwMatDialogContentAlreadyAttachedError() {\r\n    throw Error('Attempting to attach dialog content after content is already attached');\r\n}\r\n/**\r\n * Base class for the `MatDialogContainer`. The base class does not implement\r\n * animations as these are left to implementers of the dialog container.\r\n */\r\nclass _MatDialogContainerBase extends BasePortalOutlet {\r\n    constructor(_elementRef, _focusTrapFactory, _changeDetectorRef, _document, \r\n    /** The dialog configuration. */\r\n    _config, _focusMonitor) {\r\n        super();\r\n        this._elementRef = _elementRef;\r\n        this._focusTrapFactory = _focusTrapFactory;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        this._config = _config;\r\n        this._focusMonitor = _focusMonitor;\r\n        /** Emits when an animation state changes. */\r\n        this._animationStateChanged = new EventEmitter();\r\n        /** Element that was focused before the dialog was opened. Save this to restore upon close. */\r\n        this._elementFocusedBeforeDialogWasOpened = null;\r\n        /**\r\n         * Type of interaction that led to the dialog being closed. This is used to determine\r\n         * whether the focus style will be applied when returning focus to its original location\r\n         * after the dialog is closed.\r\n         */\r\n        this._closeInteractionType = null;\r\n        /**\r\n         * Attaches a DOM portal to the dialog container.\r\n         * @param portal Portal to be attached.\r\n         * @deprecated To be turned into a method.\r\n         * @breaking-change 10.0.0\r\n         */\r\n        this.attachDomPortal = (portal) => {\r\n            if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n                throwMatDialogContentAlreadyAttachedError();\r\n            }\r\n            return this._portalOutlet.attachDomPortal(portal);\r\n        };\r\n        this._ariaLabelledBy = _config.ariaLabelledBy || null;\r\n        this._document = _document;\r\n    }\r\n    /** Initializes the dialog container with the attached content. */\r\n    _initializeWithAttachedContent() {\r\n        this._setupFocusTrap();\r\n        // Save the previously focused element. This element will be re-focused\r\n        // when the dialog closes.\r\n        this._capturePreviouslyFocusedElement();\r\n        // Move focus onto the dialog immediately in order to prevent the user\r\n        // from accidentally opening multiple dialogs at the same time.\r\n        this._focusDialogContainer();\r\n    }\r\n    /**\r\n     * Attach a ComponentPortal as content to this dialog container.\r\n     * @param portal Portal to be attached as the dialog content.\r\n     */\r\n    attachComponentPortal(portal) {\r\n        if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throwMatDialogContentAlreadyAttachedError();\r\n        }\r\n        return this._portalOutlet.attachComponentPortal(portal);\r\n    }\r\n    /**\r\n     * Attach a TemplatePortal as content to this dialog container.\r\n     * @param portal Portal to be attached as the dialog content.\r\n     */\r\n    attachTemplatePortal(portal) {\r\n        if (this._portalOutlet.hasAttached() && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throwMatDialogContentAlreadyAttachedError();\r\n        }\r\n        return this._portalOutlet.attachTemplatePortal(portal);\r\n    }\r\n    /** Moves focus back into the dialog if it was moved out. */\r\n    _recaptureFocus() {\r\n        if (!this._containsFocus()) {\r\n            const focusContainer = !this._config.autoFocus || !this._focusTrap.focusInitialElement();\r\n            if (focusContainer) {\r\n                this._elementRef.nativeElement.focus();\r\n            }\r\n        }\r\n    }\r\n    /** Moves the focus inside the focus trap. */\r\n    _trapFocus() {\r\n        // If we were to attempt to focus immediately, then the content of the dialog would not yet be\r\n        // ready in instances where change detection has to run first. To deal with this, we simply\r\n        // wait for the microtask queue to be empty.\r\n        if (this._config.autoFocus) {\r\n            this._focusTrap.focusInitialElementWhenReady();\r\n        }\r\n        else if (!this._containsFocus()) {\r\n            // Otherwise ensure that focus is on the dialog container. It's possible that a different\r\n            // component tried to move focus while the open animation was running. See:\r\n            // https://github.com/angular/components/issues/16215. Note that we only want to do this\r\n            // if the focus isn't inside the dialog already, because it's possible that the consumer\r\n            // turned off `autoFocus` in order to move focus themselves.\r\n            this._elementRef.nativeElement.focus();\r\n        }\r\n    }\r\n    /** Restores focus to the element that was focused before the dialog opened. */\r\n    _restoreFocus() {\r\n        const previousElement = this._elementFocusedBeforeDialogWasOpened;\r\n        // We need the extra check, because IE can set the `activeElement` to null in some cases.\r\n        if (this._config.restoreFocus && previousElement &&\r\n            typeof previousElement.focus === 'function') {\r\n            const activeElement = _getFocusedElementPierceShadowDom();\r\n            const element = this._elementRef.nativeElement;\r\n            // Make sure that focus is still inside the dialog or is on the body (usually because a\r\n            // non-focusable element like the backdrop was clicked) before moving it. It's possible that\r\n            // the consumer moved it themselves before the animation was done, in which case we shouldn't\r\n            // do anything.\r\n            if (!activeElement || activeElement === this._document.body || activeElement === element ||\r\n                element.contains(activeElement)) {\r\n                if (this._focusMonitor) {\r\n                    this._focusMonitor.focusVia(previousElement, this._closeInteractionType);\r\n                    this._closeInteractionType = null;\r\n                }\r\n                else {\r\n                    previousElement.focus();\r\n                }\r\n            }\r\n        }\r\n        if (this._focusTrap) {\r\n            this._focusTrap.destroy();\r\n        }\r\n    }\r\n    /** Sets up the focus trap. */\r\n    _setupFocusTrap() {\r\n        this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement);\r\n    }\r\n    /** Captures the element that was focused before the dialog was opened. */\r\n    _capturePreviouslyFocusedElement() {\r\n        if (this._document) {\r\n            this._elementFocusedBeforeDialogWasOpened = _getFocusedElementPierceShadowDom();\r\n        }\r\n    }\r\n    /** Focuses the dialog container. */\r\n    _focusDialogContainer() {\r\n        // Note that there is no focus method when rendering on the server.\r\n        if (this._elementRef.nativeElement.focus) {\r\n            this._elementRef.nativeElement.focus();\r\n        }\r\n    }\r\n    /** Returns whether focus is inside the dialog. */\r\n    _containsFocus() {\r\n        const element = this._elementRef.nativeElement;\r\n        const activeElement = _getFocusedElementPierceShadowDom();\r\n        return element === activeElement || element.contains(activeElement);\r\n    }\r\n}\r\n_MatDialogContainerBase.ɵfac = function _MatDialogContainerBase_Factory(t) { return new (t || _MatDialogContainerBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusTrapFactory), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT, 8), ɵngcc0.ɵɵdirectiveInject(MatDialogConfig), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor)); };\r\n_MatDialogContainerBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: _MatDialogContainerBase, viewQuery: function _MatDialogContainerBase_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵviewQuery(CdkPortalOutlet, 7);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._portalOutlet = _t.first);\r\n    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\r\n_MatDialogContainerBase.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: FocusTrapFactory },\r\n    { type: ChangeDetectorRef },\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] },\r\n    { type: MatDialogConfig },\r\n    { type: FocusMonitor }\r\n];\r\n_MatDialogContainerBase.propDecorators = {\r\n    _portalOutlet: [{ type: ViewChild, args: [CdkPortalOutlet, { static: true },] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(_MatDialogContainerBase, [{\r\n        type: Directive\r\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc1.FocusTrapFactory }, { type: ɵngcc0.ChangeDetectorRef }, { type: undefined, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [DOCUMENT]\r\n            }] }, { type: MatDialogConfig }, { type: ɵngcc1.FocusMonitor }]; }, { _portalOutlet: [{\r\n            type: ViewChild,\r\n            args: [CdkPortalOutlet, { static: true }]\r\n        }] }); })();\r\n/**\r\n * Internal component that wraps user-provided dialog content.\r\n * Animation is based on https://material.io/guidelines/motion/choreography.html.\r\n * @docs-private\r\n */\r\nclass MatDialogContainer extends _MatDialogContainerBase {\r\n    constructor() {\r\n        super(...arguments);\r\n        /** State of the dialog animation. */\r\n        this._state = 'enter';\r\n    }\r\n    /** Callback, invoked whenever an animation on the host completes. */\r\n    _onAnimationDone({ toState, totalTime }) {\r\n        if (toState === 'enter') {\r\n            this._trapFocus();\r\n            this._animationStateChanged.next({ state: 'opened', totalTime });\r\n        }\r\n        else if (toState === 'exit') {\r\n            this._restoreFocus();\r\n            this._animationStateChanged.next({ state: 'closed', totalTime });\r\n        }\r\n    }\r\n    /** Callback, invoked when an animation on the host starts. */\r\n    _onAnimationStart({ toState, totalTime }) {\r\n        if (toState === 'enter') {\r\n            this._animationStateChanged.next({ state: 'opening', totalTime });\r\n        }\r\n        else if (toState === 'exit' || toState === 'void') {\r\n            this._animationStateChanged.next({ state: 'closing', totalTime });\r\n        }\r\n    }\r\n    /** Starts the dialog exit animation. */\r\n    _startExitAnimation() {\r\n        this._state = 'exit';\r\n        // Mark the container for check so it can react if the\r\n        // view container is using OnPush change detection.\r\n        this._changeDetectorRef.markForCheck();\r\n    }\r\n}\r\nMatDialogContainer.ɵfac = /*@__PURE__*/ function () { let ɵMatDialogContainer_BaseFactory; return function MatDialogContainer_Factory(t) { return (ɵMatDialogContainer_BaseFactory || (ɵMatDialogContainer_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatDialogContainer)))(t || MatDialogContainer); }; }();\r\nMatDialogContainer.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatDialogContainer, selectors: [[\"mat-dialog-container\"]], hostAttrs: [\"tabindex\", \"-1\", \"aria-modal\", \"true\", 1, \"mat-dialog-container\"], hostVars: 6, hostBindings: function MatDialogContainer_HostBindings(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵsyntheticHostListener(\"@dialogContainer.start\", function MatDialogContainer_animation_dialogContainer_start_HostBindingHandler($event) { return ctx._onAnimationStart($event); })(\"@dialogContainer.done\", function MatDialogContainer_animation_dialogContainer_done_HostBindingHandler($event) { return ctx._onAnimationDone($event); });\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵhostProperty(\"id\", ctx._id);\r\n        ɵngcc0.ɵɵattribute(\"role\", ctx._config.role)(\"aria-labelledby\", ctx._config.ariaLabel ? null : ctx._ariaLabelledBy)(\"aria-label\", ctx._config.ariaLabel)(\"aria-describedby\", ctx._config.ariaDescribedBy || null);\r\n        ɵngcc0.ɵɵsyntheticHostProperty(\"@dialogContainer\", ctx._state);\r\n    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 1, vars: 0, consts: [[\"cdkPortalOutlet\", \"\"]], template: function MatDialogContainer_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵtemplate(0, MatDialogContainer_ng_template_0_Template, 0, 0, \"ng-template\", 0);\r\n    } }, directives: [ɵngcc2.CdkPortalOutlet], styles: [\".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\\n\"], encapsulation: 2, data: { animation: [matDialogAnimations.dialogContainer] } });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatDialogContainer, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'mat-dialog-container',\r\n                template: \"<ng-template cdkPortalOutlet></ng-template>\\n\",\r\n                encapsulation: ViewEncapsulation.None,\r\n                // Using OnPush for dialogs caused some G3 sync issues. Disabled until we can track them down.\r\n                // tslint:disable-next-line:validate-decorators\r\n                changeDetection: ChangeDetectionStrategy.Default,\r\n                animations: [matDialogAnimations.dialogContainer],\r\n                host: {\r\n                    'class': 'mat-dialog-container',\r\n                    'tabindex': '-1',\r\n                    'aria-modal': 'true',\r\n                    '[id]': '_id',\r\n                    '[attr.role]': '_config.role',\r\n                    '[attr.aria-labelledby]': '_config.ariaLabel ? null : _ariaLabelledBy',\r\n                    '[attr.aria-label]': '_config.ariaLabel',\r\n                    '[attr.aria-describedby]': '_config.ariaDescribedBy || null',\r\n                    '[@dialogContainer]': '_state',\r\n                    '(@dialogContainer.start)': '_onAnimationStart($event)',\r\n                    '(@dialogContainer.done)': '_onAnimationDone($event)'\r\n                },\r\n                styles: [\".mat-dialog-container{display:block;padding:24px;border-radius:4px;box-sizing:border-box;overflow:auto;outline:0;width:100%;height:100%;min-height:inherit;max-height:inherit}.cdk-high-contrast-active .mat-dialog-container{outline:solid 1px}.mat-dialog-content{display:block;margin:0 -24px;padding:0 24px;max-height:65vh;overflow:auto;-webkit-overflow-scrolling:touch}.mat-dialog-title{margin:0 0 20px;display:block}.mat-dialog-actions{padding:8px 0;display:flex;flex-wrap:wrap;min-height:52px;align-items:center;box-sizing:content-box;margin-bottom:-24px}.mat-dialog-actions[align=end]{justify-content:flex-end}.mat-dialog-actions[align=center]{justify-content:center}.mat-dialog-actions .mat-button-base+.mat-button-base,.mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}\\n\"]\r\n            }]\r\n    }], null, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// TODO(jelbourn): resizing\r\n// Counter for unique dialog ids.\r\nlet uniqueId = 0;\r\n/**\r\n * Reference to a dialog opened via the MatDialog service.\r\n */\r\nclass MatDialogRef {\r\n    constructor(_overlayRef, _containerInstance, \r\n    /** Id of the dialog. */\r\n    id = `mat-dialog-${uniqueId++}`) {\r\n        this._overlayRef = _overlayRef;\r\n        this._containerInstance = _containerInstance;\r\n        this.id = id;\r\n        /** Whether the user is allowed to close the dialog. */\r\n        this.disableClose = this._containerInstance._config.disableClose;\r\n        /** Subject for notifying the user that the dialog has finished opening. */\r\n        this._afterOpened = new Subject();\r\n        /** Subject for notifying the user that the dialog has finished closing. */\r\n        this._afterClosed = new Subject();\r\n        /** Subject for notifying the user that the dialog has started closing. */\r\n        this._beforeClosed = new Subject();\r\n        /** Current state of the dialog. */\r\n        this._state = 0 /* OPEN */;\r\n        // Pass the id along to the container.\r\n        _containerInstance._id = id;\r\n        // Emit when opening animation completes\r\n        _containerInstance._animationStateChanged.pipe(filter(event => event.state === 'opened'), take(1))\r\n            .subscribe(() => {\r\n            this._afterOpened.next();\r\n            this._afterOpened.complete();\r\n        });\r\n        // Dispose overlay when closing animation is complete\r\n        _containerInstance._animationStateChanged.pipe(filter(event => event.state === 'closed'), take(1)).subscribe(() => {\r\n            clearTimeout(this._closeFallbackTimeout);\r\n            this._finishDialogClose();\r\n        });\r\n        _overlayRef.detachments().subscribe(() => {\r\n            this._beforeClosed.next(this._result);\r\n            this._beforeClosed.complete();\r\n            this._afterClosed.next(this._result);\r\n            this._afterClosed.complete();\r\n            this.componentInstance = null;\r\n            this._overlayRef.dispose();\r\n        });\r\n        _overlayRef.keydownEvents()\r\n            .pipe(filter(event => {\r\n            return event.keyCode === ESCAPE && !this.disableClose && !hasModifierKey(event);\r\n        }))\r\n            .subscribe(event => {\r\n            event.preventDefault();\r\n            _closeDialogVia(this, 'keyboard');\r\n        });\r\n        _overlayRef.backdropClick().subscribe(() => {\r\n            if (this.disableClose) {\r\n                this._containerInstance._recaptureFocus();\r\n            }\r\n            else {\r\n                _closeDialogVia(this, 'mouse');\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Close the dialog.\r\n     * @param dialogResult Optional result to return to the dialog opener.\r\n     */\r\n    close(dialogResult) {\r\n        this._result = dialogResult;\r\n        // Transition the backdrop in parallel to the dialog.\r\n        this._containerInstance._animationStateChanged.pipe(filter(event => event.state === 'closing'), take(1))\r\n            .subscribe(event => {\r\n            this._beforeClosed.next(dialogResult);\r\n            this._beforeClosed.complete();\r\n            this._overlayRef.detachBackdrop();\r\n            // The logic that disposes of the overlay depends on the exit animation completing, however\r\n            // it isn't guaranteed if the parent view is destroyed while it's running. Add a fallback\r\n            // timeout which will clean everything up if the animation hasn't fired within the specified\r\n            // amount of time plus 100ms. We don't need to run this outside the NgZone, because for the\r\n            // vast majority of cases the timeout will have been cleared before it has the chance to fire.\r\n            this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), event.totalTime + 100);\r\n        });\r\n        this._state = 1 /* CLOSING */;\r\n        this._containerInstance._startExitAnimation();\r\n    }\r\n    /**\r\n     * Gets an observable that is notified when the dialog is finished opening.\r\n     */\r\n    afterOpened() {\r\n        return this._afterOpened;\r\n    }\r\n    /**\r\n     * Gets an observable that is notified when the dialog is finished closing.\r\n     */\r\n    afterClosed() {\r\n        return this._afterClosed;\r\n    }\r\n    /**\r\n     * Gets an observable that is notified when the dialog has started closing.\r\n     */\r\n    beforeClosed() {\r\n        return this._beforeClosed;\r\n    }\r\n    /**\r\n     * Gets an observable that emits when the overlay's backdrop has been clicked.\r\n     */\r\n    backdropClick() {\r\n        return this._overlayRef.backdropClick();\r\n    }\r\n    /**\r\n     * Gets an observable that emits when keydown events are targeted on the overlay.\r\n     */\r\n    keydownEvents() {\r\n        return this._overlayRef.keydownEvents();\r\n    }\r\n    /**\r\n     * Updates the dialog's position.\r\n     * @param position New dialog position.\r\n     */\r\n    updatePosition(position) {\r\n        let strategy = this._getPositionStrategy();\r\n        if (position && (position.left || position.right)) {\r\n            position.left ? strategy.left(position.left) : strategy.right(position.right);\r\n        }\r\n        else {\r\n            strategy.centerHorizontally();\r\n        }\r\n        if (position && (position.top || position.bottom)) {\r\n            position.top ? strategy.top(position.top) : strategy.bottom(position.bottom);\r\n        }\r\n        else {\r\n            strategy.centerVertically();\r\n        }\r\n        this._overlayRef.updatePosition();\r\n        return this;\r\n    }\r\n    /**\r\n     * Updates the dialog's width and height.\r\n     * @param width New width of the dialog.\r\n     * @param height New height of the dialog.\r\n     */\r\n    updateSize(width = '', height = '') {\r\n        this._overlayRef.updateSize({ width, height });\r\n        this._overlayRef.updatePosition();\r\n        return this;\r\n    }\r\n    /** Add a CSS class or an array of classes to the overlay pane. */\r\n    addPanelClass(classes) {\r\n        this._overlayRef.addPanelClass(classes);\r\n        return this;\r\n    }\r\n    /** Remove a CSS class or an array of classes from the overlay pane. */\r\n    removePanelClass(classes) {\r\n        this._overlayRef.removePanelClass(classes);\r\n        return this;\r\n    }\r\n    /** Gets the current state of the dialog's lifecycle. */\r\n    getState() {\r\n        return this._state;\r\n    }\r\n    /**\r\n     * Finishes the dialog close by updating the state of the dialog\r\n     * and disposing the overlay.\r\n     */\r\n    _finishDialogClose() {\r\n        this._state = 2 /* CLOSED */;\r\n        this._overlayRef.dispose();\r\n    }\r\n    /** Fetches the position strategy object from the overlay ref. */\r\n    _getPositionStrategy() {\r\n        return this._overlayRef.getConfig().positionStrategy;\r\n    }\r\n}\r\n/**\r\n * Closes the dialog with the specified interaction type. This is currently not part of\r\n * `MatDialogRef` as that would conflict with custom dialog ref mocks provided in tests.\r\n * More details. See: https://github.com/angular/components/pull/9257#issuecomment-651342226.\r\n */\r\n// TODO: TODO: Move this back into `MatDialogRef` when we provide an official mock dialog ref.\r\nfunction _closeDialogVia(ref, interactionType, result) {\r\n    // Some mock dialog ref instances in tests do not have the `_containerInstance` property.\r\n    // For those, we keep the behavior as is and do not deal with the interaction type.\r\n    if (ref._containerInstance !== undefined) {\r\n        ref._containerInstance._closeInteractionType = interactionType;\r\n    }\r\n    return ref.close(result);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Injection token that can be used to access the data that was passed in to a dialog. */\r\nconst MAT_DIALOG_DATA = new InjectionToken('MatDialogData');\r\n/** Injection token that can be used to specify default dialog options. */\r\nconst MAT_DIALOG_DEFAULT_OPTIONS = new InjectionToken('mat-dialog-default-options');\r\n/** Injection token that determines the scroll handling while the dialog is open. */\r\nconst MAT_DIALOG_SCROLL_STRATEGY = new InjectionToken('mat-dialog-scroll-strategy');\r\n/** @docs-private */\r\nfunction MAT_DIALOG_SCROLL_STRATEGY_FACTORY(overlay) {\r\n    return () => overlay.scrollStrategies.block();\r\n}\r\n/** @docs-private */\r\nfunction MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY(overlay) {\r\n    return () => overlay.scrollStrategies.block();\r\n}\r\n/** @docs-private */\r\nconst MAT_DIALOG_SCROLL_STRATEGY_PROVIDER = {\r\n    provide: MAT_DIALOG_SCROLL_STRATEGY,\r\n    deps: [Overlay],\r\n    useFactory: MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY,\r\n};\r\n/**\r\n * Base class for dialog services. The base dialog service allows\r\n * for arbitrary dialog refs and dialog container components.\r\n */\r\nclass _MatDialogBase {\r\n    constructor(_overlay, _injector, _defaultOptions, _parentDialog, _overlayContainer, scrollStrategy, _dialogRefConstructor, _dialogContainerType, _dialogDataToken) {\r\n        this._overlay = _overlay;\r\n        this._injector = _injector;\r\n        this._defaultOptions = _defaultOptions;\r\n        this._parentDialog = _parentDialog;\r\n        this._overlayContainer = _overlayContainer;\r\n        this._dialogRefConstructor = _dialogRefConstructor;\r\n        this._dialogContainerType = _dialogContainerType;\r\n        this._dialogDataToken = _dialogDataToken;\r\n        this._openDialogsAtThisLevel = [];\r\n        this._afterAllClosedAtThisLevel = new Subject();\r\n        this._afterOpenedAtThisLevel = new Subject();\r\n        this._ariaHiddenElements = new Map();\r\n        // TODO (jelbourn): tighten the typing right-hand side of this expression.\r\n        /**\r\n         * Stream that emits when all open dialog have finished closing.\r\n         * Will emit on subscribe if there are no open dialogs to begin with.\r\n         */\r\n        this.afterAllClosed = defer(() => this.openDialogs.length ?\r\n            this._getAfterAllClosed() :\r\n            this._getAfterAllClosed().pipe(startWith(undefined)));\r\n        this._scrollStrategy = scrollStrategy;\r\n    }\r\n    /** Keeps track of the currently-open dialogs. */\r\n    get openDialogs() {\r\n        return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel;\r\n    }\r\n    /** Stream that emits when a dialog has been opened. */\r\n    get afterOpened() {\r\n        return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel;\r\n    }\r\n    _getAfterAllClosed() {\r\n        const parent = this._parentDialog;\r\n        return parent ? parent._getAfterAllClosed() : this._afterAllClosedAtThisLevel;\r\n    }\r\n    open(componentOrTemplateRef, config) {\r\n        config = _applyConfigDefaults(config, this._defaultOptions || new MatDialogConfig());\r\n        if (config.id && this.getDialogById(config.id) &&\r\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throw Error(`Dialog with id \"${config.id}\" exists already. The dialog id must be unique.`);\r\n        }\r\n        const overlayRef = this._createOverlay(config);\r\n        const dialogContainer = this._attachDialogContainer(overlayRef, config);\r\n        const dialogRef = this._attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config);\r\n        // If this is the first dialog that we're opening, hide all the non-overlay content.\r\n        if (!this.openDialogs.length) {\r\n            this._hideNonDialogContentFromAssistiveTechnology();\r\n        }\r\n        this.openDialogs.push(dialogRef);\r\n        dialogRef.afterClosed().subscribe(() => this._removeOpenDialog(dialogRef));\r\n        this.afterOpened.next(dialogRef);\r\n        // Notify the dialog container that the content has been attached.\r\n        dialogContainer._initializeWithAttachedContent();\r\n        return dialogRef;\r\n    }\r\n    /**\r\n     * Closes all of the currently-open dialogs.\r\n     */\r\n    closeAll() {\r\n        this._closeDialogs(this.openDialogs);\r\n    }\r\n    /**\r\n     * Finds an open dialog by its id.\r\n     * @param id ID to use when looking up the dialog.\r\n     */\r\n    getDialogById(id) {\r\n        return this.openDialogs.find(dialog => dialog.id === id);\r\n    }\r\n    ngOnDestroy() {\r\n        // Only close the dialogs at this level on destroy\r\n        // since the parent service may still be active.\r\n        this._closeDialogs(this._openDialogsAtThisLevel);\r\n        this._afterAllClosedAtThisLevel.complete();\r\n        this._afterOpenedAtThisLevel.complete();\r\n    }\r\n    /**\r\n     * Creates the overlay into which the dialog will be loaded.\r\n     * @param config The dialog configuration.\r\n     * @returns A promise resolving to the OverlayRef for the created overlay.\r\n     */\r\n    _createOverlay(config) {\r\n        const overlayConfig = this._getOverlayConfig(config);\r\n        return this._overlay.create(overlayConfig);\r\n    }\r\n    /**\r\n     * Creates an overlay config from a dialog config.\r\n     * @param dialogConfig The dialog configuration.\r\n     * @returns The overlay configuration.\r\n     */\r\n    _getOverlayConfig(dialogConfig) {\r\n        const state = new OverlayConfig({\r\n            positionStrategy: this._overlay.position().global(),\r\n            scrollStrategy: dialogConfig.scrollStrategy || this._scrollStrategy(),\r\n            panelClass: dialogConfig.panelClass,\r\n            hasBackdrop: dialogConfig.hasBackdrop,\r\n            direction: dialogConfig.direction,\r\n            minWidth: dialogConfig.minWidth,\r\n            minHeight: dialogConfig.minHeight,\r\n            maxWidth: dialogConfig.maxWidth,\r\n            maxHeight: dialogConfig.maxHeight,\r\n            disposeOnNavigation: dialogConfig.closeOnNavigation\r\n        });\r\n        if (dialogConfig.backdropClass) {\r\n            state.backdropClass = dialogConfig.backdropClass;\r\n        }\r\n        return state;\r\n    }\r\n    /**\r\n     * Attaches a dialog container to a dialog's already-created overlay.\r\n     * @param overlay Reference to the dialog's underlying overlay.\r\n     * @param config The dialog configuration.\r\n     * @returns A promise resolving to a ComponentRef for the attached container.\r\n     */\r\n    _attachDialogContainer(overlay, config) {\r\n        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\r\n        const injector = Injector.create({\r\n            parent: userInjector || this._injector,\r\n            providers: [{ provide: MatDialogConfig, useValue: config }]\r\n        });\r\n        const containerPortal = new ComponentPortal(this._dialogContainerType, config.viewContainerRef, injector, config.componentFactoryResolver);\r\n        const containerRef = overlay.attach(containerPortal);\r\n        return containerRef.instance;\r\n    }\r\n    /**\r\n     * Attaches the user-provided component to the already-created dialog container.\r\n     * @param componentOrTemplateRef The type of component being loaded into the dialog,\r\n     *     or a TemplateRef to instantiate as the content.\r\n     * @param dialogContainer Reference to the wrapping dialog container.\r\n     * @param overlayRef Reference to the overlay in which the dialog resides.\r\n     * @param config The dialog configuration.\r\n     * @returns A promise resolving to the MatDialogRef that should be returned to the user.\r\n     */\r\n    _attachDialogContent(componentOrTemplateRef, dialogContainer, overlayRef, config) {\r\n        // Create a reference to the dialog we're creating in order to give the user a handle\r\n        // to modify and close it.\r\n        const dialogRef = new this._dialogRefConstructor(overlayRef, dialogContainer, config.id);\r\n        if (componentOrTemplateRef instanceof TemplateRef) {\r\n            dialogContainer.attachTemplatePortal(new TemplatePortal(componentOrTemplateRef, null, { $implicit: config.data, dialogRef }));\r\n        }\r\n        else {\r\n            const injector = this._createInjector(config, dialogRef, dialogContainer);\r\n            const contentRef = dialogContainer.attachComponentPortal(new ComponentPortal(componentOrTemplateRef, config.viewContainerRef, injector));\r\n            dialogRef.componentInstance = contentRef.instance;\r\n        }\r\n        dialogRef\r\n            .updateSize(config.width, config.height)\r\n            .updatePosition(config.position);\r\n        return dialogRef;\r\n    }\r\n    /**\r\n     * Creates a custom injector to be used inside the dialog. This allows a component loaded inside\r\n     * of a dialog to close itself and, optionally, to return a value.\r\n     * @param config Config object that is used to construct the dialog.\r\n     * @param dialogRef Reference to the dialog.\r\n     * @param dialogContainer Dialog container element that wraps all of the contents.\r\n     * @returns The custom injector that can be used inside the dialog.\r\n     */\r\n    _createInjector(config, dialogRef, dialogContainer) {\r\n        const userInjector = config && config.viewContainerRef && config.viewContainerRef.injector;\r\n        // The dialog container should be provided as the dialog container and the dialog's\r\n        // content are created out of the same `ViewContainerRef` and as such, are siblings\r\n        // for injector purposes. To allow the hierarchy that is expected, the dialog\r\n        // container is explicitly provided in the injector.\r\n        const providers = [\r\n            { provide: this._dialogContainerType, useValue: dialogContainer },\r\n            { provide: this._dialogDataToken, useValue: config.data },\r\n            { provide: this._dialogRefConstructor, useValue: dialogRef }\r\n        ];\r\n        if (config.direction && (!userInjector ||\r\n            !userInjector.get(Directionality, null, InjectFlags.Optional))) {\r\n            providers.push({\r\n                provide: Directionality,\r\n                useValue: { value: config.direction, change: of() }\r\n            });\r\n        }\r\n        return Injector.create({ parent: userInjector || this._injector, providers });\r\n    }\r\n    /**\r\n     * Removes a dialog from the array of open dialogs.\r\n     * @param dialogRef Dialog to be removed.\r\n     */\r\n    _removeOpenDialog(dialogRef) {\r\n        const index = this.openDialogs.indexOf(dialogRef);\r\n        if (index > -1) {\r\n            this.openDialogs.splice(index, 1);\r\n            // If all the dialogs were closed, remove/restore the `aria-hidden`\r\n            // to a the siblings and emit to the `afterAllClosed` stream.\r\n            if (!this.openDialogs.length) {\r\n                this._ariaHiddenElements.forEach((previousValue, element) => {\r\n                    if (previousValue) {\r\n                        element.setAttribute('aria-hidden', previousValue);\r\n                    }\r\n                    else {\r\n                        element.removeAttribute('aria-hidden');\r\n                    }\r\n                });\r\n                this._ariaHiddenElements.clear();\r\n                this._getAfterAllClosed().next();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Hides all of the content that isn't an overlay from assistive technology.\r\n     */\r\n    _hideNonDialogContentFromAssistiveTechnology() {\r\n        const overlayContainer = this._overlayContainer.getContainerElement();\r\n        // Ensure that the overlay container is attached to the DOM.\r\n        if (overlayContainer.parentElement) {\r\n            const siblings = overlayContainer.parentElement.children;\r\n            for (let i = siblings.length - 1; i > -1; i--) {\r\n                let sibling = siblings[i];\r\n                if (sibling !== overlayContainer &&\r\n                    sibling.nodeName !== 'SCRIPT' &&\r\n                    sibling.nodeName !== 'STYLE' &&\r\n                    !sibling.hasAttribute('aria-live')) {\r\n                    this._ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));\r\n                    sibling.setAttribute('aria-hidden', 'true');\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /** Closes all of the dialogs in an array. */\r\n    _closeDialogs(dialogs) {\r\n        let i = dialogs.length;\r\n        while (i--) {\r\n            // The `_openDialogs` property isn't updated after close until the rxjs subscription\r\n            // runs on the next microtask, in addition to modifying the array as we're going\r\n            // through it. We loop through all of them and call close without assuming that\r\n            // they'll be removed from the list instantaneously.\r\n            dialogs[i].close();\r\n        }\r\n    }\r\n}\r\n_MatDialogBase.ɵfac = function _MatDialogBase_Factory(t) { return new (t || _MatDialogBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(undefined), ɵngcc0.ɵɵdirectiveInject(undefined), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.OverlayContainer), ɵngcc0.ɵɵdirectiveInject(undefined), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Type), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Type), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.InjectionToken)); };\r\n_MatDialogBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: _MatDialogBase });\r\n_MatDialogBase.ctorParameters = () => [\r\n    { type: Overlay },\r\n    { type: Injector },\r\n    { type: undefined },\r\n    { type: undefined },\r\n    { type: OverlayContainer },\r\n    { type: undefined },\r\n    { type: Type },\r\n    { type: Type },\r\n    { type: InjectionToken }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(_MatDialogBase, [{\r\n        type: Directive\r\n    }], function () { return [{ type: ɵngcc3.Overlay }, { type: ɵngcc0.Injector }, { type: undefined }, { type: undefined }, { type: ɵngcc3.OverlayContainer }, { type: undefined }, { type: ɵngcc0.Type }, { type: ɵngcc0.Type }, { type: ɵngcc0.InjectionToken }]; }, null); })();\r\n/**\r\n * Service to open Material Design modal dialogs.\r\n */\r\nclass MatDialog extends _MatDialogBase {\r\n    constructor(overlay, injector, \r\n    /**\r\n     * @deprecated `_location` parameter to be removed.\r\n     * @breaking-change 10.0.0\r\n     */\r\n    location, defaultOptions, scrollStrategy, parentDialog, overlayContainer) {\r\n        super(overlay, injector, defaultOptions, parentDialog, overlayContainer, scrollStrategy, MatDialogRef, MatDialogContainer, MAT_DIALOG_DATA);\r\n    }\r\n}\r\nMatDialog.ɵfac = function MatDialog_Factory(t) { return new (t || MatDialog)(ɵngcc0.ɵɵinject(ɵngcc3.Overlay), ɵngcc0.ɵɵinject(ɵngcc0.Injector), ɵngcc0.ɵɵinject(ɵngcc4.Location, 8), ɵngcc0.ɵɵinject(MAT_DIALOG_DEFAULT_OPTIONS, 8), ɵngcc0.ɵɵinject(MAT_DIALOG_SCROLL_STRATEGY), ɵngcc0.ɵɵinject(MatDialog, 12), ɵngcc0.ɵɵinject(ɵngcc3.OverlayContainer)); };\r\nMatDialog.ɵprov = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjectable({ token: MatDialog, factory: MatDialog.ɵfac });\r\nMatDialog.ctorParameters = () => [\r\n    { type: Overlay },\r\n    { type: Injector },\r\n    { type: Location, decorators: [{ type: Optional }] },\r\n    { type: MatDialogConfig, decorators: [{ type: Optional }, { type: Inject, args: [MAT_DIALOG_DEFAULT_OPTIONS,] }] },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_SCROLL_STRATEGY,] }] },\r\n    { type: MatDialog, decorators: [{ type: Optional }, { type: SkipSelf }] },\r\n    { type: OverlayContainer }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatDialog, [{\r\n        type: Injectable\r\n    }], function () { return [{ type: ɵngcc3.Overlay }, { type: ɵngcc0.Injector }, { type: ɵngcc4.Location, decorators: [{\r\n                type: Optional\r\n            }] }, { type: MatDialogConfig, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Inject,\r\n                args: [MAT_DIALOG_DEFAULT_OPTIONS]\r\n            }] }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [MAT_DIALOG_SCROLL_STRATEGY]\r\n            }] }, { type: MatDialog, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: SkipSelf\r\n            }] }, { type: ɵngcc3.OverlayContainer }]; }, null); })();\r\n/**\r\n * Applies default options to the dialog config.\r\n * @param config Config to be modified.\r\n * @param defaultOptions Default options provided.\r\n * @returns The new configuration object.\r\n */\r\nfunction _applyConfigDefaults(config, defaultOptions) {\r\n    return Object.assign(Object.assign({}, defaultOptions), config);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Counter used to generate unique IDs for dialog elements. */\r\nlet dialogElementUid = 0;\r\n/**\r\n * Button that will close the current dialog.\r\n */\r\nclass MatDialogClose {\r\n    constructor(\r\n    /**\r\n     * Reference to the containing dialog.\r\n     * @deprecated `dialogRef` property to become private.\r\n     * @breaking-change 13.0.0\r\n     */\r\n    // The dialog title directive is always used in combination with a `MatDialogRef`.\r\n    // tslint:disable-next-line: lightweight-tokens\r\n    dialogRef, _elementRef, _dialog) {\r\n        this.dialogRef = dialogRef;\r\n        this._elementRef = _elementRef;\r\n        this._dialog = _dialog;\r\n        /** Default to \"button\" to prevents accidental form submits. */\r\n        this.type = 'button';\r\n    }\r\n    ngOnInit() {\r\n        if (!this.dialogRef) {\r\n            // When this directive is included in a dialog via TemplateRef (rather than being\r\n            // in a Component), the DialogRef isn't available via injection because embedded\r\n            // views cannot be given a custom injector. Instead, we look up the DialogRef by\r\n            // ID. This must occur in `onInit`, as the ID binding for the dialog container won't\r\n            // be resolved at constructor time.\r\n            this.dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);\r\n        }\r\n    }\r\n    ngOnChanges(changes) {\r\n        const proxiedChange = changes['_matDialogClose'] || changes['_matDialogCloseResult'];\r\n        if (proxiedChange) {\r\n            this.dialogResult = proxiedChange.currentValue;\r\n        }\r\n    }\r\n    _onButtonClick(event) {\r\n        // Determinate the focus origin using the click event, because using the FocusMonitor will\r\n        // result in incorrect origins. Most of the time, close buttons will be auto focused in the\r\n        // dialog, and therefore clicking the button won't result in a focus change. This means that\r\n        // the FocusMonitor won't detect any origin change, and will always output `program`.\r\n        _closeDialogVia(this.dialogRef, event.screenX === 0 && event.screenY === 0 ? 'keyboard' : 'mouse', this.dialogResult);\r\n    }\r\n}\r\nMatDialogClose.ɵfac = function MatDialogClose_Factory(t) { return new (t || MatDialogClose)(ɵngcc0.ɵɵdirectiveInject(MatDialogRef, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MatDialog)); };\r\nMatDialogClose.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MatDialogClose, selectors: [[\"\", \"mat-dialog-close\", \"\"], [\"\", \"matDialogClose\", \"\"]], hostVars: 2, hostBindings: function MatDialogClose_HostBindings(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵlistener(\"click\", function MatDialogClose_click_HostBindingHandler($event) { return ctx._onButtonClick($event); });\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵattribute(\"aria-label\", ctx.ariaLabel || null)(\"type\", ctx.type);\r\n    } }, inputs: { type: \"type\", dialogResult: [\"mat-dialog-close\", \"dialogResult\"], ariaLabel: [\"aria-label\", \"ariaLabel\"], _matDialogClose: [\"matDialogClose\", \"_matDialogClose\"] }, exportAs: [\"matDialogClose\"], features: [ɵngcc0.ɵɵNgOnChangesFeature] });\r\nMatDialogClose.ctorParameters = () => [\r\n    { type: MatDialogRef, decorators: [{ type: Optional }] },\r\n    { type: ElementRef },\r\n    { type: MatDialog }\r\n];\r\nMatDialogClose.propDecorators = {\r\n    ariaLabel: [{ type: Input, args: ['aria-label',] }],\r\n    type: [{ type: Input }],\r\n    dialogResult: [{ type: Input, args: ['mat-dialog-close',] }],\r\n    _matDialogClose: [{ type: Input, args: ['matDialogClose',] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatDialogClose, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-dialog-close], [matDialogClose]',\r\n                exportAs: 'matDialogClose',\r\n                host: {\r\n                    '(click)': '_onButtonClick($event)',\r\n                    '[attr.aria-label]': 'ariaLabel || null',\r\n                    '[attr.type]': 'type'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: MatDialogRef, decorators: [{\r\n                type: Optional\r\n            }] }, { type: ɵngcc0.ElementRef }, { type: MatDialog }]; }, { type: [{\r\n            type: Input\r\n        }], dialogResult: [{\r\n            type: Input,\r\n            args: ['mat-dialog-close']\r\n        }], ariaLabel: [{\r\n            type: Input,\r\n            args: ['aria-label']\r\n        }], _matDialogClose: [{\r\n            type: Input,\r\n            args: ['matDialogClose']\r\n        }] }); })();\r\n/**\r\n * Title of a dialog element. Stays fixed to the top of the dialog when scrolling.\r\n */\r\nclass MatDialogTitle {\r\n    constructor(\r\n    // The dialog title directive is always used in combination with a `MatDialogRef`.\r\n    // tslint:disable-next-line: lightweight-tokens\r\n    _dialogRef, _elementRef, _dialog) {\r\n        this._dialogRef = _dialogRef;\r\n        this._elementRef = _elementRef;\r\n        this._dialog = _dialog;\r\n        /** Unique id for the dialog title. If none is supplied, it will be auto-generated. */\r\n        this.id = `mat-dialog-title-${dialogElementUid++}`;\r\n    }\r\n    ngOnInit() {\r\n        if (!this._dialogRef) {\r\n            this._dialogRef = getClosestDialog(this._elementRef, this._dialog.openDialogs);\r\n        }\r\n        if (this._dialogRef) {\r\n            Promise.resolve().then(() => {\r\n                const container = this._dialogRef._containerInstance;\r\n                if (container && !container._ariaLabelledBy) {\r\n                    container._ariaLabelledBy = this.id;\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\nMatDialogTitle.ɵfac = function MatDialogTitle_Factory(t) { return new (t || MatDialogTitle)(ɵngcc0.ɵɵdirectiveInject(MatDialogRef, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(MatDialog)); };\r\nMatDialogTitle.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MatDialogTitle, selectors: [[\"\", \"mat-dialog-title\", \"\"], [\"\", \"matDialogTitle\", \"\"]], hostAttrs: [1, \"mat-dialog-title\"], hostVars: 1, hostBindings: function MatDialogTitle_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵhostProperty(\"id\", ctx.id);\r\n    } }, inputs: { id: \"id\" }, exportAs: [\"matDialogTitle\"] });\r\nMatDialogTitle.ctorParameters = () => [\r\n    { type: MatDialogRef, decorators: [{ type: Optional }] },\r\n    { type: ElementRef },\r\n    { type: MatDialog }\r\n];\r\nMatDialogTitle.propDecorators = {\r\n    id: [{ type: Input }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatDialogTitle, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: '[mat-dialog-title], [matDialogTitle]',\r\n                exportAs: 'matDialogTitle',\r\n                host: {\r\n                    'class': 'mat-dialog-title',\r\n                    '[id]': 'id'\r\n                }\r\n            }]\r\n    }], function () { return [{ type: MatDialogRef, decorators: [{\r\n                type: Optional\r\n            }] }, { type: ɵngcc0.ElementRef }, { type: MatDialog }]; }, { id: [{\r\n            type: Input\r\n        }] }); })();\r\n/**\r\n * Scrollable content container of a dialog.\r\n */\r\nclass MatDialogContent {\r\n}\r\nMatDialogContent.ɵfac = function MatDialogContent_Factory(t) { return new (t || MatDialogContent)(); };\r\nMatDialogContent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MatDialogContent, selectors: [[\"\", \"mat-dialog-content\", \"\"], [\"mat-dialog-content\"], [\"\", \"matDialogContent\", \"\"]], hostAttrs: [1, \"mat-dialog-content\"] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatDialogContent, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: `[mat-dialog-content], mat-dialog-content, [matDialogContent]`,\r\n                host: { 'class': 'mat-dialog-content' }\r\n            }]\r\n    }], null, null); })();\r\n/**\r\n * Container for the bottom action buttons in a dialog.\r\n * Stays fixed to the bottom when scrolling.\r\n */\r\nclass MatDialogActions {\r\n}\r\nMatDialogActions.ɵfac = function MatDialogActions_Factory(t) { return new (t || MatDialogActions)(); };\r\nMatDialogActions.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MatDialogActions, selectors: [[\"\", \"mat-dialog-actions\", \"\"], [\"mat-dialog-actions\"], [\"\", \"matDialogActions\", \"\"]], hostAttrs: [1, \"mat-dialog-actions\"] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatDialogActions, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: `[mat-dialog-actions], mat-dialog-actions, [matDialogActions]`,\r\n                host: { 'class': 'mat-dialog-actions' }\r\n            }]\r\n    }], null, null); })();\r\n/**\r\n * Finds the closest MatDialogRef to an element by looking at the DOM.\r\n * @param element Element relative to which to look for a dialog.\r\n * @param openDialogs References to the currently-open dialogs.\r\n */\r\nfunction getClosestDialog(element, openDialogs) {\r\n    let parent = element.nativeElement.parentElement;\r\n    while (parent && !parent.classList.contains('mat-dialog-container')) {\r\n        parent = parent.parentElement;\r\n    }\r\n    return parent ? openDialogs.find(dialog => dialog.id === parent.id) : null;\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass MatDialogModule {\r\n}\r\nMatDialogModule.ɵfac = function MatDialogModule_Factory(t) { return new (t || MatDialogModule)(); };\r\nMatDialogModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MatDialogModule });\r\nMatDialogModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [\r\n        MatDialog,\r\n        MAT_DIALOG_SCROLL_STRATEGY_PROVIDER,\r\n    ], imports: [[\r\n            OverlayModule,\r\n            PortalModule,\r\n            MatCommonModule,\r\n        ], MatCommonModule] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatDialogModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [\r\n                    OverlayModule,\r\n                    PortalModule,\r\n                    MatCommonModule,\r\n                ],\r\n                exports: [\r\n                    MatDialogContainer,\r\n                    MatDialogClose,\r\n                    MatDialogTitle,\r\n                    MatDialogContent,\r\n                    MatDialogActions,\r\n                    MatCommonModule,\r\n                ],\r\n                declarations: [\r\n                    MatDialogContainer,\r\n                    MatDialogClose,\r\n                    MatDialogTitle,\r\n                    MatDialogActions,\r\n                    MatDialogContent,\r\n                ],\r\n                providers: [\r\n                    MatDialog,\r\n                    MAT_DIALOG_SCROLL_STRATEGY_PROVIDER,\r\n                ],\r\n                entryComponents: [MatDialogContainer]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatDialogModule, { declarations: function () { return [MatDialogContainer, MatDialogClose, MatDialogTitle, MatDialogActions, MatDialogContent]; }, imports: function () { return [OverlayModule,\r\n        PortalModule,\r\n        MatCommonModule]; }, exports: function () { return [MatDialogContainer, MatDialogClose, MatDialogTitle, MatDialogContent, MatDialogActions, MatCommonModule]; } }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { MAT_DIALOG_DATA, MAT_DIALOG_DEFAULT_OPTIONS, MAT_DIALOG_SCROLL_STRATEGY, MAT_DIALOG_SCROLL_STRATEGY_FACTORY, MAT_DIALOG_SCROLL_STRATEGY_PROVIDER, MAT_DIALOG_SCROLL_STRATEGY_PROVIDER_FACTORY, MatDialog, MatDialogActions, MatDialogClose, MatDialogConfig, MatDialogContainer, MatDialogContent, MatDialogModule, MatDialogRef, MatDialogTitle, _MatDialogBase, _MatDialogContainerBase, _closeDialogVia, matDialogAnimations, throwMatDialogContentAlreadyAttachedError };\r\n\r\n//# sourceMappingURL=dialog.js.map"],"sourceRoot":"webpack:///"}