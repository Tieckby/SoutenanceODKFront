{"version":3,"sources":["./node_modules/@angular/material/__ivy_ngcc__/fesm2015/menu.js"],"names":[],"mappings":"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AuE,mEAA4B,wCAAwC,GAAG,EAAE;AAC9Q,oCAAoC,+DAAwB,EAAE,sFAAsF,gEAAyB,GAAG,yDAAyD,IAAI,wEAAiC,GAAG;AACjR,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB;AACA;AACA,6BAA6B,yDAAyD;AACtF,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yDAAc;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0EAAkB,CAAC,qEAAa;AACzD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yCAAO;AACnC;AACA,4BAA4B,yCAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,+BAA+B,+DAAwB,CAAC,qDAAiB,GAAG,+DAAwB,CAAC,qDAAQ,GAAG,+DAAwB,CAAC,2DAAmB,GAAG,+DAAwB,qBAAqB,+DAAwB,CAAC,4DAAwB,GAAG;AACpT,iCAAiC,+DAAwB,EAAE,2KAA2K;AACtO,QAAQ,wDAAiB,iEAAiE,mCAAmC,EAAE,sEAAsE,gCAAgC,EAAE;AACvO,KAAK;AACL,QAAQ,yDAAkB;AAC1B,QAAQ,yDAAkB;AAC1B,KAAK,EAAE,WAAW,qEAAqE,wCAAwC,wEAAiC,+YAA+Y;AAC/iB,QAAQ,6DAAsB;AAC9B,QAAQ,0DAAmB;AAC3B,QAAQ,uDAAgB;AACxB,QAAQ,wDAAiB;AACzB,KAAK;AACL,QAAQ,uDAAgB;AACxB,QAAQ,wDAAiB;AACzB,QAAQ,uDAAgB;AACxB,QAAQ,wDAAiB;AACzB,KAAK,EAAE,eAAe,6DAAgB,EAAE,iDAAW,yCAAyC;AAC5F;AACA,KAAK,OAAO,qDAAU,EAAE;AACxB,KAAK,gCAAgC,OAAO,iDAAM,SAAS,qDAAQ,IAAI,GAAG;AAC1E,KAAK,OAAO,2DAAY,EAAE;AAC1B,KAAK,gCAAgC,OAAO,iDAAM,2BAA2B,GAAG,OAAO,mDAAQ,EAAE,GAAG;AACpG,KAAK,OAAO,4DAAiB;AAC7B;AACA;AACA,YAAY,OAAO,gDAAK,EAAE;AAC1B,sBAAsB,OAAO,uDAAY,gCAAgC;AACzE,yBAAyB,OAAO,uDAAY,yBAAyB;AACrE;AACA,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,iCAAiC,yEAA8B;AAC/D,+BAA+B,iEAAsB;AACrD;AACA,aAAa;AACb,KAAK,gBAAgB,UAAU,OAAO,qDAAiB,EAAE,GAAG;AAC5D,sBAAsB,iDAAM;AAC5B,uBAAuB,qDAAQ;AAC/B,aAAa,GAAG,GAAG,OAAO,2DAAmB,EAAE,GAAG;AAClD,sBAAsB,iDAAM;AAC5B;AACA,aAAa;AACb,sBAAsB,mDAAQ;AAC9B,aAAa,GAAG,GAAG,OAAO,4DAAwB,EAAE,EAAE,EAAE,GAAG;AAC3D,kBAAkB,gDAAK;AACvB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAY;AAC9B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAY;AAC9B;AACA,SAAS,GAAG,EAAE,EAAE;;AAEhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,yDAAc;AACnD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oDAAS;AACnD;AACA,gCAAgC,oDAAkB;AAClD;AACA;AACA;AACA;AACA;AACA,kCAAkC,yCAAO;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAY;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,eAAe;AACxD;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6BAA6B;AACvD;AACA,+BAA+B,4EAAqB;AACpD;AACA;AACA,uBAAuB,0BAA0B;AACjD;AACA,4BAA4B,4EAAqB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wBAAwB;AAC7C,4BAA4B,2BAA2B;AACvD;AACA;AACA;AACA;AACA;AACA,+BAA+B,8DAAe;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,yDAAS,+BAA+B,0DAAS,UAAU,4CAAK;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yDAAS,+BAA+B,0DAAS,UAAU,4CAAK;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA,iBAAiB,0DAAM;AACvB,qBAAqB,sEAAc;AACnC;AACA;AACA;AACA;AACA,iBAAiB,8DAAU;AAC3B;AACA;AACA;AACA;AACA,iBAAiB,+DAAW;AAC5B;AACA;AACA;AACA;AACA;AACA,gCAAgC,4DAAQ,gBAAgB,8DAAU;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qDAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sBAAsB,EAAE,UAAU;AAClE;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,yDAAS;AAC3B;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,sDAAsD,gCAAgC,+DAAwB,CAAC,qDAAiB,GAAG,+DAAwB,CAAC,iDAAa,GAAG,+DAAwB,4BAA4B;AAChO,kCAAkC,+DAAwB,EAAE,8FAA8F;AAC1J,QAAQ,4DAAqB;AAC7B,QAAQ,4DAAqB;AAC7B,QAAQ,4DAAqB;AAC7B,KAAK;AACL;AACA,QAA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gBAAgB;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oDAAkB;AAC7D,kCAAkC,oDAAkB;AACpD,sCAAsC,oDAAkB;AACxD;AACA;AACA;AACA;AACA;AACA,iBAAiB,mFAAgC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uDAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uDAAM,qCAAqC,qDAAI;AACzE;AACA,gBAAgB,0DAAS;AACzB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,gEAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,gDAAgD;AAC7D,aAAa,mFAAmF;AAChG;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yFAAyF,yCAAE;AAC3F,0FAA0F,uDAAM,+CAA+C,uDAAM,0BAA0B,yCAAE;AACjL,eAAe,4CAAK;AACpB;AACA;AACA;AACA,aAAa,kFAA+B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAK,gBAAgB,yDAAK;AAClD;AACA;AACA,oDAAoD,+DAAW;AAC/D,yBAAyB,8DAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uDAAM,mEAAmE,sDAAK,IAAI,gDAAa;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qDAAI,KAAK,sDAAK,IAAI,gDAAa,GAAG,0DAAS;AACrE;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,+DAAc;AAC7C;AACA;AACA;AACA;AACA,oEAAoE,uCAAuC,+DAAwB,CAAC,0DAAc,GAAG,+DAAwB,CAAC,qDAAiB,GAAG,+DAAwB,CAAC,2DAAuB,GAAG,+DAAwB,4BAA4B,+DAAwB,qBAAqB,+DAAwB,mBAAmB,+DAAwB,CAAC,8DAAqB,MAAM,+DAAwB,CAAC,2DAAmB,GAAG;AACpe,yCAAyC,+DAAwB,EAAE,2GAA2G;AAC9K,QAAQ,wDAAiB,iFAAiF,qCAAqC,EAAE,8EAA8E,mCAAmC,EAAE,0EAA0E,iCAAiC,EAAE;AACjX,KAAK;AACL,QAAQ,yDAAkB;AAC1B,KAAK,EAAE,WAAW,0OAA0O,YAAY,2GAA2G,EAAE;AACrX;AACA,KAAK,OAAO,0DAAO,EAAE;AACrB,KAAK,OAAO,qDAAU,EAAE;AACxB,KAAK,OAAO,2DAAgB,EAAE;AAC9B,KAAK,gCAAgC,OAAO,iDAAM,qCAAqC,GAAG;AAC1F,KAAK,gCAAgC,OAAO,iDAAM,2BAA2B,GAAG,OAAO,mDAAQ,EAAE,GAAG;AACpG,KAAK,kCAAkC,OAAO,mDAAQ,EAAE,GAAG,OAAO,+CAAI,EAAE,GAAG;AAC3E,KAAK,OAAO,8DAAc,gBAAgB,OAAO,mDAAQ,EAAE,GAAG;AAC9D,KAAK,OAAO,2DAAY;AACxB;AACA;AACA,qBAAqB,OAAO,sDAAW,iCAAiC;AACxE,oBAAoB,OAAO,sDAAW,iCAAiC;AACvE,qBAAqB,OAAO,sDAAW,iCAAiC;AACxE,oCAAoC,OAAO,gDAAK,mCAAmC;AACnF,YAAY,OAAO,gDAAK,gCAAgC;AACxD,gBAAgB,OAAO,gDAAK,iCAAiC;AAC7D,oBAAoB,OAAO,gDAAK,yCAAyC;AACzE,kBAAkB,OAAO,iDAAM,EAAE;AACjC,kBAAkB,OAAO,iDAAM,EAAE;AACjC,kBAAkB,OAAO,iDAAM,EAAE;AACjC,mBAAmB,OAAO,iDAAM,EAAE;AAClC,wBAAwB,OAAO,uDAAY,oCAAoC;AAC/E,sBAAsB,OAAO,uDAAY,kCAAkC;AAC3E,oBAAoB,OAAO,uDAAY,gCAAgC;AACvE;AACA,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB,KAAK,gBAAgB,UAAU,OAAO,0DAAc,EAAE,GAAG,OAAO,qDAAiB,EAAE,GAAG,OAAO,2DAAuB,EAAE,GAAG;AACzH,sBAAsB,iDAAM;AAC5B;AACA,aAAa,GAAG,GAAG;AACnB,sBAAsB,iDAAM;AAC5B;AACA,aAAa;AACb,sBAAsB,mDAAQ;AAC9B,aAAa,GAAG,GAAG;AACnB,sBAAsB,mDAAQ;AAC9B,aAAa;AACb,sBAAsB,+CAAI;AAC1B,aAAa,GAAG,GAAG,OAAO,8DAAqB;AAC/C,sBAAsB,mDAAQ;AAC9B,aAAa,GAAG,GAAG,OAAO,2DAAmB,EAAE,EAAE,EAAE,GAAG;AACtD,kBAAkB,sDAAW;AAC7B;AACA,SAAS;AACT,kBAAkB,gDAAK;AACvB;AACA,SAAS;AACT,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,iDAAM;AACxB,SAAS;AACT,kBAAkB,sDAAW;AAC7B;AACA,SAAS;AACT,kBAAkB,sDAAW;AAC7B;AACA,SAAS;AACT,kBAAkB,gDAAK;AACvB;AACA,SAAS;AACT,kBAAkB,gDAAK;AACvB;AACA,SAAS;AACT;AACA;AACA,kBAAkB,uDAAY;AAC9B;AACA,SAAS;AACT;AACA;AACA,kBAAkB,uDAAY;AAC9B;AACA,SAAS;AACT;AACA;AACA,kBAAkB,uDAAY;AAC9B;AACA,SAAS;AACT,kBAAkB,gDAAK;AACvB;AACA,SAAS,GAAG,EAAE,EAAE;AAChB;AACA;AACA;AACA,iDAAiD,iCAAiC,4CAA4C,uEAAuE,mEAA4B,wCAAwC,GAAG,EAAE;AAC9Q,oCAAoC,+DAAwB,EAAE,kLAAkL,wEAAiC,GAAG;AACpR,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,oDAAS;AACvB;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb,KAAK,eAAe,EAAE;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,mCAAmC;AAC3F,mCAAmC,8DAAuB,EAAE,sBAAsB;AAClF,mCAAmC,8DAAuB,EAAE;AAC5D,YAAY,yDAAY;AACxB,YAAY,mEAAe;AAC3B,YAAY,mEAAe;AAC3B,YAAY,gEAAa;AACzB,WAAW,wEAAmB;AAC9B,QAAQ,mEAAe,GAAG;AAC1B,cAAc,oDAAoD,+DAAwB;AAC1F,cAAc,mDAAQ;AACtB;AACA;AACA,oBAAoB,yDAAY;AAChC,oBAAoB,mEAAe;AACnC,oBAAoB,mEAAe;AACnC,oBAAoB,gEAAa;AACjC;AACA;AACA,oBAAoB,wEAAmB;AACvC,oBAAoB,mEAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,KAAK,eAAe,EAAE;AACtB,cAAc,oDAAoD,gEAAyB,iBAAiB,4BAA4B,+DAA+D,EAAE,wBAAwB,SAAS,yDAAY;AACtP,QAAQ,mEAAe;AACvB,QAAQ,mEAAe;AACvB,QAAQ,gEAAa,EAAE,EAAE,wBAAwB,SAAS,wEAAmB;AAC7E,QAAQ,mEAAe,wDAAwD,EAAE,EAAE,EAAE,EAAE;;AAEvF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEqgB;;AAErgB,gC","file":"default-node_modules_angular_material___ivy_ngcc___fesm2015_menu_js-es2015.js","sourcesContent":["import { FocusMonitor, FocusKeyManager, isFakeTouchstartFromScreenReader, isFakeMousedownFromScreenReader } from '@angular/cdk/a11y';\r\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\r\nimport { UP_ARROW, DOWN_ARROW, RIGHT_ARROW, LEFT_ARROW, ESCAPE, hasModifierKey, ENTER, SPACE } from '@angular/cdk/keycodes';\r\nimport { InjectionToken, Directive, TemplateRef, ComponentFactoryResolver, ApplicationRef, Injector, ViewContainerRef, Inject, ChangeDetectorRef, Component, ChangeDetectionStrategy, ViewEncapsulation, ElementRef, Optional, Input, HostListener, QueryList, EventEmitter, NgZone, ContentChildren, ViewChild, ContentChild, Output, Self, HostBinding, NgModule } from '@angular/core';\r\nimport { Subject, Subscription, merge, of, asapScheduler } from 'rxjs';\r\nimport { startWith, switchMap, take, filter, takeUntil, delay } from 'rxjs/operators';\r\nimport { trigger, state, style, transition, animate } from '@angular/animations';\r\nimport { TemplatePortal, DomPortalOutlet } from '@angular/cdk/portal';\r\nimport { DOCUMENT, CommonModule } from '@angular/common';\r\nimport { mixinDisableRipple, mixinDisabled, MatCommonModule, MatRippleModule } from '@angular/material/core';\r\nimport { Directionality } from '@angular/cdk/bidi';\r\nimport { Overlay, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\r\nimport { normalizePassiveListenerOptions } from '@angular/cdk/platform';\r\nimport { CdkScrollableModule } from '@angular/cdk/scrolling';\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Animations used by the mat-menu component.\r\n * Animation duration and timing values are based on:\r\n * https://material.io/guidelines/components/menus.html#menus-usage\r\n * @docs-private\r\n */\r\nimport * as ɵngcc0 from '@angular/core';\r\nimport * as ɵngcc1 from '@angular/cdk/a11y';\r\nimport * as ɵngcc2 from '@angular/material/core';\r\nimport * as ɵngcc3 from '@angular/common';\r\nimport * as ɵngcc4 from '@angular/cdk/overlay';\r\nimport * as ɵngcc5 from '@angular/cdk/bidi';\r\n\r\nconst _c0 = [\"mat-menu-item\", \"\"];\r\nfunction MatMenuItem__svg_svg_2_Template(rf, ctx) { if (rf & 1) {\r\n    ɵngcc0.ɵɵnamespaceSVG();\r\n    ɵngcc0.ɵɵelementStart(0, \"svg\", 2);\r\n    ɵngcc0.ɵɵelement(1, \"polygon\", 3);\r\n    ɵngcc0.ɵɵelementEnd();\r\n} }\r\nconst _c1 = [\"*\"];\r\nfunction MatMenu_ng_template_0_Template(rf, ctx) { if (rf & 1) {\r\n    const _r2 = ɵngcc0.ɵɵgetCurrentView();\r\n    ɵngcc0.ɵɵelementStart(0, \"div\", 0);\r\n    ɵngcc0.ɵɵlistener(\"keydown\", function MatMenu_ng_template_0_Template_div_keydown_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r1 = ɵngcc0.ɵɵnextContext(); return ctx_r1._handleKeydown($event); })(\"click\", function MatMenu_ng_template_0_Template_div_click_0_listener() { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r3 = ɵngcc0.ɵɵnextContext(); return ctx_r3.closed.emit(\"click\"); })(\"@transformMenu.start\", function MatMenu_ng_template_0_Template_div_animation_transformMenu_start_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r4 = ɵngcc0.ɵɵnextContext(); return ctx_r4._onAnimationStart($event); })(\"@transformMenu.done\", function MatMenu_ng_template_0_Template_div_animation_transformMenu_done_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r2); const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5._onAnimationDone($event); });\r\n    ɵngcc0.ɵɵelementStart(1, \"div\", 1);\r\n    ɵngcc0.ɵɵprojection(2);\r\n    ɵngcc0.ɵɵelementEnd();\r\n    ɵngcc0.ɵɵelementEnd();\r\n} if (rf & 2) {\r\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\r\n    ɵngcc0.ɵɵproperty(\"id\", ctx_r0.panelId)(\"ngClass\", ctx_r0._classList)(\"@transformMenu\", ctx_r0._panelAnimationState);\r\n    ɵngcc0.ɵɵattribute(\"aria-label\", ctx_r0.ariaLabel || null)(\"aria-labelledby\", ctx_r0.ariaLabelledby || null)(\"aria-describedby\", ctx_r0.ariaDescribedby || null);\r\n} }\r\nconst matMenuAnimations = {\r\n    /**\r\n     * This animation controls the menu panel's entry and exit from the page.\r\n     *\r\n     * When the menu panel is added to the DOM, it scales in and fades in its border.\r\n     *\r\n     * When the menu panel is removed from the DOM, it simply fades out after a brief\r\n     * delay to display the ripple.\r\n     */\r\n    transformMenu: trigger('transformMenu', [\r\n        state('void', style({\r\n            opacity: 0,\r\n            transform: 'scale(0.8)'\r\n        })),\r\n        transition('void => enter', animate('120ms cubic-bezier(0, 0, 0.2, 1)', style({\r\n            opacity: 1,\r\n            transform: 'scale(1)'\r\n        }))),\r\n        transition('* => void', animate('100ms 25ms linear', style({ opacity: 0 })))\r\n    ]),\r\n    /**\r\n     * This animation fades in the background color and content of the menu panel\r\n     * after its containing element is scaled in.\r\n     */\r\n    fadeInItems: trigger('fadeInItems', [\r\n        // TODO(crisbeto): this is inside the `transformMenu`\r\n        // now. Remove next time we do breaking changes.\r\n        state('showing', style({ opacity: 1 })),\r\n        transition('void => *', [\r\n            style({ opacity: 0 }),\r\n            animate('400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)')\r\n        ])\r\n    ])\r\n};\r\n/**\r\n * @deprecated\r\n * @breaking-change 8.0.0\r\n * @docs-private\r\n */\r\nconst fadeInItems = matMenuAnimations.fadeInItems;\r\n/**\r\n * @deprecated\r\n * @breaking-change 8.0.0\r\n * @docs-private\r\n */\r\nconst transformMenu = matMenuAnimations.transformMenu;\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Injection token that can be used to reference instances of `MatMenuContent`. It serves\r\n * as alternative token to the actual `MatMenuContent` class which could cause unnecessary\r\n * retention of the class and its directive metadata.\r\n */\r\nconst MAT_MENU_CONTENT = new InjectionToken('MatMenuContent');\r\nclass _MatMenuContentBase {\r\n    constructor(_template, _componentFactoryResolver, _appRef, _injector, _viewContainerRef, _document, _changeDetectorRef) {\r\n        this._template = _template;\r\n        this._componentFactoryResolver = _componentFactoryResolver;\r\n        this._appRef = _appRef;\r\n        this._injector = _injector;\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._document = _document;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        /** Emits when the menu content has been attached. */\r\n        this._attached = new Subject();\r\n    }\r\n    /**\r\n     * Attaches the content with a particular context.\r\n     * @docs-private\r\n     */\r\n    attach(context = {}) {\r\n        if (!this._portal) {\r\n            this._portal = new TemplatePortal(this._template, this._viewContainerRef);\r\n        }\r\n        this.detach();\r\n        if (!this._outlet) {\r\n            this._outlet = new DomPortalOutlet(this._document.createElement('div'), this._componentFactoryResolver, this._appRef, this._injector);\r\n        }\r\n        const element = this._template.elementRef.nativeElement;\r\n        // Because we support opening the same menu from different triggers (which in turn have their\r\n        // own `OverlayRef` panel), we have to re-insert the host element every time, otherwise we\r\n        // risk it staying attached to a pane that's no longer in the DOM.\r\n        element.parentNode.insertBefore(this._outlet.outletElement, element);\r\n        // When `MatMenuContent` is used in an `OnPush` component, the insertion of the menu\r\n        // content via `createEmbeddedView` does not cause the content to be seen as \"dirty\"\r\n        // by Angular. This causes the `@ContentChildren` for menu items within the menu to\r\n        // not be updated by Angular. By explicitly marking for check here, we tell Angular that\r\n        // it needs to check for new menu items and update the `@ContentChild` in `MatMenu`.\r\n        // @breaking-change 9.0.0 Make change detector ref required\r\n        if (this._changeDetectorRef) {\r\n            this._changeDetectorRef.markForCheck();\r\n        }\r\n        this._portal.attach(this._outlet, context);\r\n        this._attached.next();\r\n    }\r\n    /**\r\n     * Detaches the content.\r\n     * @docs-private\r\n     */\r\n    detach() {\r\n        if (this._portal.isAttached) {\r\n            this._portal.detach();\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        if (this._outlet) {\r\n            this._outlet.dispose();\r\n        }\r\n    }\r\n}\r\n_MatMenuContentBase.ɵfac = function _MatMenuContentBase_Factory(t) { return new (t || _MatMenuContentBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ApplicationRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Injector), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };\r\n_MatMenuContentBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: _MatMenuContentBase });\r\n_MatMenuContentBase.ctorParameters = () => [\r\n    { type: TemplateRef },\r\n    { type: ComponentFactoryResolver },\r\n    { type: ApplicationRef },\r\n    { type: Injector },\r\n    { type: ViewContainerRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: ChangeDetectorRef }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(_MatMenuContentBase, [{\r\n        type: Directive\r\n    }], function () { return [{ type: ɵngcc0.TemplateRef }, { type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ApplicationRef }, { type: ɵngcc0.Injector }, { type: ɵngcc0.ViewContainerRef }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [DOCUMENT]\r\n            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, null); })();\r\n/**\r\n * Menu content that will be rendered lazily once the menu is opened.\r\n */\r\nclass MatMenuContent extends _MatMenuContentBase {\r\n}\r\nMatMenuContent.ɵfac = /*@__PURE__*/ function () { let ɵMatMenuContent_BaseFactory; return function MatMenuContent_Factory(t) { return (ɵMatMenuContent_BaseFactory || (ɵMatMenuContent_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatMenuContent)))(t || MatMenuContent); }; }();\r\nMatMenuContent.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MatMenuContent, selectors: [[\"ng-template\", \"matMenuContent\", \"\"]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: MAT_MENU_CONTENT, useExisting: MatMenuContent }]), ɵngcc0.ɵɵInheritDefinitionFeature] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuContent, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: 'ng-template[matMenuContent]',\r\n                providers: [{ provide: MAT_MENU_CONTENT, useExisting: MatMenuContent }]\r\n            }]\r\n    }], null, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Throws an exception for the case when menu trigger doesn't have a valid mat-menu instance\r\n * @docs-private\r\n */\r\nfunction throwMatMenuMissingError() {\r\n    throw Error(`matMenuTriggerFor: must pass in an mat-menu instance.\r\n\r\n    Example:\r\n      <mat-menu #menu=\"matMenu\"></mat-menu>\r\n      <button [matMenuTriggerFor]=\"menu\"></button>`);\r\n}\r\n/**\r\n * Throws an exception for the case when menu's x-position value isn't valid.\r\n * In other words, it doesn't match 'before' or 'after'.\r\n * @docs-private\r\n */\r\nfunction throwMatMenuInvalidPositionX() {\r\n    throw Error(`xPosition value must be either 'before' or after'.\r\n      Example: <mat-menu xPosition=\"before\" #menu=\"matMenu\"></mat-menu>`);\r\n}\r\n/**\r\n * Throws an exception for the case when menu's y-position value isn't valid.\r\n * In other words, it doesn't match 'above' or 'below'.\r\n * @docs-private\r\n */\r\nfunction throwMatMenuInvalidPositionY() {\r\n    throw Error(`yPosition value must be either 'above' or below'.\r\n      Example: <mat-menu yPosition=\"above\" #menu=\"matMenu\"></mat-menu>`);\r\n}\r\n/**\r\n * Throws an exception for the case when a menu is assigned\r\n * to a trigger that is placed inside the same menu.\r\n * @docs-private\r\n */\r\nfunction throwMatMenuRecursiveError() {\r\n    throw Error(`matMenuTriggerFor: menu cannot contain its own trigger. Assign a menu that is ` +\r\n        `not a parent of the trigger or move the trigger outside of the menu.`);\r\n}\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/**\r\n * Injection token used to provide the parent menu to menu-specific components.\r\n * @docs-private\r\n */\r\nconst MAT_MENU_PANEL = new InjectionToken('MAT_MENU_PANEL');\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n// Boilerplate for applying mixins to MatMenuItem.\r\n/** @docs-private */\r\nconst _MatMenuItemBase = mixinDisableRipple(mixinDisabled(class {\r\n}));\r\n/**\r\n * Single item inside of a `mat-menu`. Provides the menu item styling and accessibility treatment.\r\n */\r\nclass MatMenuItem extends _MatMenuItemBase {\r\n    constructor(_elementRef, \r\n    /**\r\n     * @deprecated `_document` parameter is no longer being used and will be removed.\r\n     * @breaking-change 12.0.0\r\n     */\r\n    _document, _focusMonitor, _parentMenu, \r\n    /**\r\n     * @deprecated `_changeDetectorRef` to become a required parameter.\r\n     * @breaking-change 14.0.0\r\n     */\r\n    _changeDetectorRef) {\r\n        // @breaking-change 8.0.0 make `_focusMonitor` and `document` required params.\r\n        super();\r\n        this._elementRef = _elementRef;\r\n        this._focusMonitor = _focusMonitor;\r\n        this._parentMenu = _parentMenu;\r\n        this._changeDetectorRef = _changeDetectorRef;\r\n        /** ARIA role for the menu item. */\r\n        this.role = 'menuitem';\r\n        /** Stream that emits when the menu item is hovered. */\r\n        this._hovered = new Subject();\r\n        /** Stream that emits when the menu item is focused. */\r\n        this._focused = new Subject();\r\n        /** Whether the menu item is highlighted. */\r\n        this._highlighted = false;\r\n        /** Whether the menu item acts as a trigger for a sub-menu. */\r\n        this._triggersSubmenu = false;\r\n        if (_parentMenu && _parentMenu.addItem) {\r\n            _parentMenu.addItem(this);\r\n        }\r\n    }\r\n    /** Focuses the menu item. */\r\n    focus(origin, options) {\r\n        if (this._focusMonitor && origin) {\r\n            this._focusMonitor.focusVia(this._getHostElement(), origin, options);\r\n        }\r\n        else {\r\n            this._getHostElement().focus(options);\r\n        }\r\n        this._focused.next(this);\r\n    }\r\n    ngAfterViewInit() {\r\n        if (this._focusMonitor) {\r\n            // Start monitoring the element so it gets the appropriate focused classes. We want\r\n            // to show the focus style for menu items only when the focus was not caused by a\r\n            // mouse or touch interaction.\r\n            this._focusMonitor.monitor(this._elementRef, false);\r\n        }\r\n    }\r\n    ngOnDestroy() {\r\n        if (this._focusMonitor) {\r\n            this._focusMonitor.stopMonitoring(this._elementRef);\r\n        }\r\n        if (this._parentMenu && this._parentMenu.removeItem) {\r\n            this._parentMenu.removeItem(this);\r\n        }\r\n        this._hovered.complete();\r\n        this._focused.complete();\r\n    }\r\n    /** Used to set the `tabindex`. */\r\n    _getTabIndex() {\r\n        return this.disabled ? '-1' : '0';\r\n    }\r\n    /** Returns the host DOM element. */\r\n    _getHostElement() {\r\n        return this._elementRef.nativeElement;\r\n    }\r\n    /** Prevents the default element actions if it is disabled. */\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    _checkDisabled(event) {\r\n        if (this.disabled) {\r\n            event.preventDefault();\r\n            event.stopPropagation();\r\n        }\r\n    }\r\n    /** Emits to the hover stream. */\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    _handleMouseEnter() {\r\n        this._hovered.next(this);\r\n    }\r\n    /** Gets the label to be used when determining whether the option should be focused. */\r\n    getLabel() {\r\n        var _a, _b;\r\n        const clone = this._elementRef.nativeElement.cloneNode(true);\r\n        const icons = clone.querySelectorAll('mat-icon, .material-icons');\r\n        // Strip away icons so they don't show up in the text.\r\n        for (let i = 0; i < icons.length; i++) {\r\n            const icon = icons[i];\r\n            (_a = icon.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(icon);\r\n        }\r\n        return ((_b = clone.textContent) === null || _b === void 0 ? void 0 : _b.trim()) || '';\r\n    }\r\n    _setHighlighted(isHighlighted) {\r\n        var _a;\r\n        // We need to mark this for check for the case where the content is coming from a\r\n        // `matMenuContent` whose change detection tree is at the declaration position,\r\n        // not the insertion position. See #23175.\r\n        // @breaking-change 14.0.0 Remove null check for `_changeDetectorRef`.\r\n        this._highlighted = isHighlighted;\r\n        (_a = this._changeDetectorRef) === null || _a === void 0 ? void 0 : _a.markForCheck();\r\n    }\r\n}\r\nMatMenuItem.ɵfac = function MatMenuItem_Factory(t) { return new (t || MatMenuItem)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(DOCUMENT), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_PANEL, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef)); };\r\nMatMenuItem.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatMenuItem, selectors: [[\"\", \"mat-menu-item\", \"\"]], hostAttrs: [1, \"mat-focus-indicator\"], hostVars: 10, hostBindings: function MatMenuItem_HostBindings(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵlistener(\"click\", function MatMenuItem_click_HostBindingHandler($event) { return ctx._checkDisabled($event); })(\"mouseenter\", function MatMenuItem_mouseenter_HostBindingHandler() { return ctx._handleMouseEnter(); });\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵattribute(\"role\", ctx.role)(\"tabindex\", ctx._getTabIndex())(\"aria-disabled\", ctx.disabled.toString())(\"disabled\", ctx.disabled || null);\r\n        ɵngcc0.ɵɵclassProp(\"mat-menu-item\", true)(\"mat-menu-item-highlighted\", ctx._highlighted)(\"mat-menu-item-submenu-trigger\", ctx._triggersSubmenu);\r\n    } }, inputs: { disabled: \"disabled\", disableRipple: \"disableRipple\", role: \"role\" }, exportAs: [\"matMenuItem\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature], attrs: _c0, ngContentSelectors: _c1, decls: 3, vars: 3, consts: [[\"matRipple\", \"\", 1, \"mat-menu-ripple\", 3, \"matRippleDisabled\", \"matRippleTrigger\"], [\"class\", \"mat-menu-submenu-icon\", \"viewBox\", \"0 0 5 10\", \"focusable\", \"false\", 4, \"ngIf\"], [\"viewBox\", \"0 0 5 10\", \"focusable\", \"false\", 1, \"mat-menu-submenu-icon\"], [\"points\", \"0,0 5,5 0,10\"]], template: function MatMenuItem_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef();\r\n        ɵngcc0.ɵɵprojection(0);\r\n        ɵngcc0.ɵɵelement(1, \"div\", 0);\r\n        ɵngcc0.ɵɵtemplate(2, MatMenuItem__svg_svg_2_Template, 2, 0, \"svg\", 1);\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵadvance(1);\r\n        ɵngcc0.ɵɵproperty(\"matRippleDisabled\", ctx.disableRipple || ctx.disabled)(\"matRippleTrigger\", ctx._getHostElement());\r\n        ɵngcc0.ɵɵadvance(1);\r\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx._triggersSubmenu);\r\n    } }, directives: [ɵngcc2.MatRipple, ɵngcc3.NgIf], encapsulation: 2, changeDetection: 0 });\r\nMatMenuItem.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\r\n    { type: FocusMonitor },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_PANEL,] }, { type: Optional }] },\r\n    { type: ChangeDetectorRef }\r\n];\r\nMatMenuItem.propDecorators = {\r\n    role: [{ type: Input }],\r\n    _checkDisabled: [{ type: HostListener, args: ['click', ['$event'],] }],\r\n    _handleMouseEnter: [{ type: HostListener, args: ['mouseenter',] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuItem, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: '[mat-menu-item]',\r\n                exportAs: 'matMenuItem',\r\n                inputs: ['disabled', 'disableRipple'],\r\n                host: {\r\n                    '[attr.role]': 'role',\r\n                    '[class.mat-menu-item]': 'true',\r\n                    '[class.mat-menu-item-highlighted]': '_highlighted',\r\n                    '[class.mat-menu-item-submenu-trigger]': '_triggersSubmenu',\r\n                    '[attr.tabindex]': '_getTabIndex()',\r\n                    '[attr.aria-disabled]': 'disabled.toString()',\r\n                    '[attr.disabled]': 'disabled || null',\r\n                    'class': 'mat-focus-indicator'\r\n                },\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None,\r\n                template: \"<ng-content></ng-content>\\n<div class=\\\"mat-menu-ripple\\\" matRipple\\n     [matRippleDisabled]=\\\"disableRipple || disabled\\\"\\n     [matRippleTrigger]=\\\"_getHostElement()\\\">\\n</div>\\n\\n<svg\\n  *ngIf=\\\"_triggersSubmenu\\\"\\n  class=\\\"mat-menu-submenu-icon\\\"\\n  viewBox=\\\"0 0 5 10\\\"\\n  focusable=\\\"false\\\"><polygon points=\\\"0,0 5,5 0,10\\\"/></svg>\\n\"\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [DOCUMENT]\r\n            }] }, { type: ɵngcc1.FocusMonitor }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [MAT_MENU_PANEL]\r\n            }, {\r\n                type: Optional\r\n            }] }, { type: ɵngcc0.ChangeDetectorRef }]; }, { role: [{\r\n            type: Input\r\n        }], \r\n    /** Prevents the default element actions if it is disabled. */\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    _checkDisabled: [{\r\n            type: HostListener,\r\n            args: ['click', ['$event']]\r\n        }], \r\n    /** Emits to the hover stream. */\r\n    // We have to use a `HostListener` here in order to support both Ivy and ViewEngine.\r\n    // In Ivy the `host` bindings will be merged when this class is extended, whereas in\r\n    // ViewEngine they're overwritten.\r\n    // TODO(crisbeto): we move this back into `host` once Ivy is turned on by default.\r\n    // tslint:disable-next-line:no-host-decorator-in-concrete\r\n    _handleMouseEnter: [{\r\n            type: HostListener,\r\n            args: ['mouseenter']\r\n        }] }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Injection token to be used to override the default options for `mat-menu`. */\r\nconst MAT_MENU_DEFAULT_OPTIONS = new InjectionToken('mat-menu-default-options', {\r\n    providedIn: 'root',\r\n    factory: MAT_MENU_DEFAULT_OPTIONS_FACTORY\r\n});\r\n/** @docs-private */\r\nfunction MAT_MENU_DEFAULT_OPTIONS_FACTORY() {\r\n    return {\r\n        overlapTrigger: false,\r\n        xPosition: 'after',\r\n        yPosition: 'below',\r\n        backdropClass: 'cdk-overlay-transparent-backdrop',\r\n    };\r\n}\r\nlet menuPanelUid = 0;\r\n/** Base class with all of the `MatMenu` functionality. */\r\nclass _MatMenuBase {\r\n    constructor(_elementRef, _ngZone, _defaultOptions) {\r\n        this._elementRef = _elementRef;\r\n        this._ngZone = _ngZone;\r\n        this._defaultOptions = _defaultOptions;\r\n        this._xPosition = this._defaultOptions.xPosition;\r\n        this._yPosition = this._defaultOptions.yPosition;\r\n        /** Only the direct descendant menu items. */\r\n        this._directDescendantItems = new QueryList();\r\n        /** Subscription to tab events on the menu panel */\r\n        this._tabSubscription = Subscription.EMPTY;\r\n        /** Config object to be passed into the menu's ngClass */\r\n        this._classList = {};\r\n        /** Current state of the panel animation. */\r\n        this._panelAnimationState = 'void';\r\n        /** Emits whenever an animation on the menu completes. */\r\n        this._animationDone = new Subject();\r\n        /** Class or list of classes to be added to the overlay panel. */\r\n        this.overlayPanelClass = this._defaultOptions.overlayPanelClass || '';\r\n        /** Class to be added to the backdrop element. */\r\n        this.backdropClass = this._defaultOptions.backdropClass;\r\n        this._overlapTrigger = this._defaultOptions.overlapTrigger;\r\n        this._hasBackdrop = this._defaultOptions.hasBackdrop;\r\n        /** Event emitted when the menu is closed. */\r\n        this.closed = new EventEmitter();\r\n        /**\r\n         * Event emitted when the menu is closed.\r\n         * @deprecated Switch to `closed` instead\r\n         * @breaking-change 8.0.0\r\n         */\r\n        this.close = this.closed;\r\n        this.panelId = `mat-menu-panel-${menuPanelUid++}`;\r\n    }\r\n    /** Position of the menu in the X axis. */\r\n    get xPosition() { return this._xPosition; }\r\n    set xPosition(value) {\r\n        if (value !== 'before' && value !== 'after' &&\r\n            (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throwMatMenuInvalidPositionX();\r\n        }\r\n        this._xPosition = value;\r\n        this.setPositionClasses();\r\n    }\r\n    /** Position of the menu in the Y axis. */\r\n    get yPosition() { return this._yPosition; }\r\n    set yPosition(value) {\r\n        if (value !== 'above' && value !== 'below' && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throwMatMenuInvalidPositionY();\r\n        }\r\n        this._yPosition = value;\r\n        this.setPositionClasses();\r\n    }\r\n    /** Whether the menu should overlap its trigger. */\r\n    get overlapTrigger() { return this._overlapTrigger; }\r\n    set overlapTrigger(value) {\r\n        this._overlapTrigger = coerceBooleanProperty(value);\r\n    }\r\n    /** Whether the menu has a backdrop. */\r\n    get hasBackdrop() { return this._hasBackdrop; }\r\n    set hasBackdrop(value) {\r\n        this._hasBackdrop = coerceBooleanProperty(value);\r\n    }\r\n    /**\r\n     * This method takes classes set on the host mat-menu element and applies them on the\r\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\r\n     * to style the containing menu from outside the component.\r\n     * @param classes list of class names\r\n     */\r\n    set panelClass(classes) {\r\n        const previousPanelClass = this._previousPanelClass;\r\n        if (previousPanelClass && previousPanelClass.length) {\r\n            previousPanelClass.split(' ').forEach((className) => {\r\n                this._classList[className] = false;\r\n            });\r\n        }\r\n        this._previousPanelClass = classes;\r\n        if (classes && classes.length) {\r\n            classes.split(' ').forEach((className) => {\r\n                this._classList[className] = true;\r\n            });\r\n            this._elementRef.nativeElement.className = '';\r\n        }\r\n    }\r\n    /**\r\n     * This method takes classes set on the host mat-menu element and applies them on the\r\n     * menu template that displays in the overlay container.  Otherwise, it's difficult\r\n     * to style the containing menu from outside the component.\r\n     * @deprecated Use `panelClass` instead.\r\n     * @breaking-change 8.0.0\r\n     */\r\n    get classList() { return this.panelClass; }\r\n    set classList(classes) { this.panelClass = classes; }\r\n    ngOnInit() {\r\n        this.setPositionClasses();\r\n    }\r\n    ngAfterContentInit() {\r\n        this._updateDirectDescendants();\r\n        this._keyManager = new FocusKeyManager(this._directDescendantItems)\r\n            .withWrap()\r\n            .withTypeAhead()\r\n            .withHomeAndEnd();\r\n        this._tabSubscription = this._keyManager.tabOut.subscribe(() => this.closed.emit('tab'));\r\n        // If a user manually (programmatically) focuses a menu item, we need to reflect that focus\r\n        // change back to the key manager. Note that we don't need to unsubscribe here because _focused\r\n        // is internal and we know that it gets completed on destroy.\r\n        this._directDescendantItems.changes.pipe(startWith(this._directDescendantItems), switchMap(items => merge(...items.map((item) => item._focused)))).subscribe(focusedItem => this._keyManager.updateActiveItem(focusedItem));\r\n    }\r\n    ngOnDestroy() {\r\n        this._directDescendantItems.destroy();\r\n        this._tabSubscription.unsubscribe();\r\n        this.closed.complete();\r\n    }\r\n    /** Stream that emits whenever the hovered menu item changes. */\r\n    _hovered() {\r\n        // Coerce the `changes` property because Angular types it as `Observable<any>`\r\n        const itemChanges = this._directDescendantItems.changes;\r\n        return itemChanges.pipe(startWith(this._directDescendantItems), switchMap(items => merge(...items.map((item) => item._hovered))));\r\n    }\r\n    /*\r\n     * Registers a menu item with the menu.\r\n     * @docs-private\r\n     * @deprecated No longer being used. To be removed.\r\n     * @breaking-change 9.0.0\r\n     */\r\n    addItem(_item) { }\r\n    /**\r\n     * Removes an item from the menu.\r\n     * @docs-private\r\n     * @deprecated No longer being used. To be removed.\r\n     * @breaking-change 9.0.0\r\n     */\r\n    removeItem(_item) { }\r\n    /** Handle a keyboard event from the menu, delegating to the appropriate action. */\r\n    _handleKeydown(event) {\r\n        const keyCode = event.keyCode;\r\n        const manager = this._keyManager;\r\n        switch (keyCode) {\r\n            case ESCAPE:\r\n                if (!hasModifierKey(event)) {\r\n                    event.preventDefault();\r\n                    this.closed.emit('keydown');\r\n                }\r\n                break;\r\n            case LEFT_ARROW:\r\n                if (this.parentMenu && this.direction === 'ltr') {\r\n                    this.closed.emit('keydown');\r\n                }\r\n                break;\r\n            case RIGHT_ARROW:\r\n                if (this.parentMenu && this.direction === 'rtl') {\r\n                    this.closed.emit('keydown');\r\n                }\r\n                break;\r\n            default:\r\n                if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {\r\n                    manager.setFocusOrigin('keyboard');\r\n                }\r\n                manager.onKeydown(event);\r\n        }\r\n    }\r\n    /**\r\n     * Focus the first item in the menu.\r\n     * @param origin Action from which the focus originated. Used to set the correct styling.\r\n     */\r\n    focusFirstItem(origin = 'program') {\r\n        // When the content is rendered lazily, it takes a bit before the items are inside the DOM.\r\n        if (this.lazyContent) {\r\n            this._ngZone.onStable\r\n                .pipe(take(1))\r\n                .subscribe(() => this._focusFirstItem(origin));\r\n        }\r\n        else {\r\n            this._focusFirstItem(origin);\r\n        }\r\n    }\r\n    /**\r\n     * Actual implementation that focuses the first item. Needs to be separated\r\n     * out so we don't repeat the same logic in the public `focusFirstItem` method.\r\n     */\r\n    _focusFirstItem(origin) {\r\n        const manager = this._keyManager;\r\n        manager.setFocusOrigin(origin).setFirstItemActive();\r\n        // If there's no active item at this point, it means that all the items are disabled.\r\n        // Move focus to the menu panel so keyboard events like Escape still work. Also this will\r\n        // give _some_ feedback to screen readers.\r\n        if (!manager.activeItem && this._directDescendantItems.length) {\r\n            let element = this._directDescendantItems.first._getHostElement().parentElement;\r\n            // Because the `mat-menu` is at the DOM insertion point, not inside the overlay, we don't\r\n            // have a nice way of getting a hold of the menu panel. We can't use a `ViewChild` either\r\n            // because the panel is inside an `ng-template`. We work around it by starting from one of\r\n            // the items and walking up the DOM.\r\n            while (element) {\r\n                if (element.getAttribute('role') === 'menu') {\r\n                    element.focus();\r\n                    break;\r\n                }\r\n                else {\r\n                    element = element.parentElement;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Resets the active item in the menu. This is used when the menu is opened, allowing\r\n     * the user to start from the first option when pressing the down arrow.\r\n     */\r\n    resetActiveItem() {\r\n        this._keyManager.setActiveItem(-1);\r\n    }\r\n    /**\r\n     * Sets the menu panel elevation.\r\n     * @param depth Number of parent menus that come before the menu.\r\n     */\r\n    setElevation(depth) {\r\n        // The elevation starts at the base and increases by one for each level.\r\n        // Capped at 24 because that's the maximum elevation defined in the Material design spec.\r\n        const elevation = Math.min(this._baseElevation + depth, 24);\r\n        const newElevation = `${this._elevationPrefix}${elevation}`;\r\n        const customElevation = Object.keys(this._classList).find(className => {\r\n            return className.startsWith(this._elevationPrefix);\r\n        });\r\n        if (!customElevation || customElevation === this._previousElevation) {\r\n            if (this._previousElevation) {\r\n                this._classList[this._previousElevation] = false;\r\n            }\r\n            this._classList[newElevation] = true;\r\n            this._previousElevation = newElevation;\r\n        }\r\n    }\r\n    /**\r\n     * Adds classes to the menu panel based on its position. Can be used by\r\n     * consumers to add specific styling based on the position.\r\n     * @param posX Position of the menu along the x axis.\r\n     * @param posY Position of the menu along the y axis.\r\n     * @docs-private\r\n     */\r\n    setPositionClasses(posX = this.xPosition, posY = this.yPosition) {\r\n        const classes = this._classList;\r\n        classes['mat-menu-before'] = posX === 'before';\r\n        classes['mat-menu-after'] = posX === 'after';\r\n        classes['mat-menu-above'] = posY === 'above';\r\n        classes['mat-menu-below'] = posY === 'below';\r\n    }\r\n    /** Starts the enter animation. */\r\n    _startAnimation() {\r\n        // @breaking-change 8.0.0 Combine with _resetAnimation.\r\n        this._panelAnimationState = 'enter';\r\n    }\r\n    /** Resets the panel animation to its initial state. */\r\n    _resetAnimation() {\r\n        // @breaking-change 8.0.0 Combine with _startAnimation.\r\n        this._panelAnimationState = 'void';\r\n    }\r\n    /** Callback that is invoked when the panel animation completes. */\r\n    _onAnimationDone(event) {\r\n        this._animationDone.next(event);\r\n        this._isAnimating = false;\r\n    }\r\n    _onAnimationStart(event) {\r\n        this._isAnimating = true;\r\n        // Scroll the content element to the top as soon as the animation starts. This is necessary,\r\n        // because we move focus to the first item while it's still being animated, which can throw\r\n        // the browser off when it determines the scroll position. Alternatively we can move focus\r\n        // when the animation is done, however moving focus asynchronously will interrupt screen\r\n        // readers which are in the process of reading out the menu already. We take the `element`\r\n        // from the `event` since we can't use a `ViewChild` to access the pane.\r\n        if (event.toState === 'enter' && this._keyManager.activeItemIndex === 0) {\r\n            event.element.scrollTop = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Sets up a stream that will keep track of any newly-added menu items and will update the list\r\n     * of direct descendants. We collect the descendants this way, because `_allItems` can include\r\n     * items that are part of child menus, and using a custom way of registering items is unreliable\r\n     * when it comes to maintaining the item order.\r\n     */\r\n    _updateDirectDescendants() {\r\n        this._allItems.changes\r\n            .pipe(startWith(this._allItems))\r\n            .subscribe((items) => {\r\n            this._directDescendantItems.reset(items.filter(item => item._parentMenu === this));\r\n            this._directDescendantItems.notifyOnChanges();\r\n        });\r\n    }\r\n}\r\n_MatMenuBase.ɵfac = function _MatMenuBase_Factory(t) { return new (t || _MatMenuBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_DEFAULT_OPTIONS)); };\r\n_MatMenuBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: _MatMenuBase, contentQueries: function _MatMenuBase_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MAT_MENU_CONTENT, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatMenuItem, 5);\r\n        ɵngcc0.ɵɵcontentQuery(dirIndex, MatMenuItem, 4);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.lazyContent = _t.first);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx._allItems = _t);\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.items = _t);\r\n    } }, viewQuery: function _MatMenuBase_Query(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵviewQuery(TemplateRef, 5);\r\n    } if (rf & 2) {\r\n        let _t;\r\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);\r\n    } }, inputs: { backdropClass: \"backdropClass\", xPosition: \"xPosition\", yPosition: \"yPosition\", overlapTrigger: \"overlapTrigger\", hasBackdrop: \"hasBackdrop\", panelClass: [\"class\", \"panelClass\"], classList: \"classList\", ariaLabel: [\"aria-label\", \"ariaLabel\"], ariaLabelledby: [\"aria-labelledby\", \"ariaLabelledby\"], ariaDescribedby: [\"aria-describedby\", \"ariaDescribedby\"] }, outputs: { closed: \"closed\", close: \"close\" } });\r\n_MatMenuBase.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] }] }\r\n];\r\n_MatMenuBase.propDecorators = {\r\n    _allItems: [{ type: ContentChildren, args: [MatMenuItem, { descendants: true },] }],\r\n    backdropClass: [{ type: Input }],\r\n    ariaLabel: [{ type: Input, args: ['aria-label',] }],\r\n    ariaLabelledby: [{ type: Input, args: ['aria-labelledby',] }],\r\n    ariaDescribedby: [{ type: Input, args: ['aria-describedby',] }],\r\n    xPosition: [{ type: Input }],\r\n    yPosition: [{ type: Input }],\r\n    templateRef: [{ type: ViewChild, args: [TemplateRef,] }],\r\n    items: [{ type: ContentChildren, args: [MatMenuItem, { descendants: false },] }],\r\n    lazyContent: [{ type: ContentChild, args: [MAT_MENU_CONTENT,] }],\r\n    overlapTrigger: [{ type: Input }],\r\n    hasBackdrop: [{ type: Input }],\r\n    panelClass: [{ type: Input, args: ['class',] }],\r\n    classList: [{ type: Input }],\r\n    closed: [{ type: Output }],\r\n    close: [{ type: Output }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(_MatMenuBase, [{\r\n        type: Directive\r\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [MAT_MENU_DEFAULT_OPTIONS]\r\n            }] }]; }, { backdropClass: [{\r\n            type: Input\r\n        }], closed: [{\r\n            type: Output\r\n        }], close: [{\r\n            type: Output\r\n        }], xPosition: [{\r\n            type: Input\r\n        }], yPosition: [{\r\n            type: Input\r\n        }], overlapTrigger: [{\r\n            type: Input\r\n        }], hasBackdrop: [{\r\n            type: Input\r\n        }], panelClass: [{\r\n            type: Input,\r\n            args: ['class']\r\n        }], classList: [{\r\n            type: Input\r\n        }], _allItems: [{\r\n            type: ContentChildren,\r\n            args: [MatMenuItem, { descendants: true }]\r\n        }], ariaLabel: [{\r\n            type: Input,\r\n            args: ['aria-label']\r\n        }], ariaLabelledby: [{\r\n            type: Input,\r\n            args: ['aria-labelledby']\r\n        }], ariaDescribedby: [{\r\n            type: Input,\r\n            args: ['aria-describedby']\r\n        }], templateRef: [{\r\n            type: ViewChild,\r\n            args: [TemplateRef]\r\n        }], items: [{\r\n            type: ContentChildren,\r\n            args: [MatMenuItem, { descendants: false }]\r\n        }], lazyContent: [{\r\n            type: ContentChild,\r\n            args: [MAT_MENU_CONTENT]\r\n        }] }); })();\r\n/** @docs-public MatMenu */\r\nclass MatMenu extends _MatMenuBase {\r\n    constructor(elementRef, ngZone, defaultOptions) {\r\n        super(elementRef, ngZone, defaultOptions);\r\n        this._elevationPrefix = 'mat-elevation-z';\r\n        this._baseElevation = 4;\r\n    }\r\n}\r\nMatMenu.ɵfac = function MatMenu_Factory(t) { return new (t || MatMenu)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_DEFAULT_OPTIONS)); };\r\nMatMenu.ɵcmp = /*@__PURE__*/ ɵngcc0.ɵɵdefineComponent({ type: MatMenu, selectors: [[\"mat-menu\"]], hostVars: 3, hostBindings: function MatMenu_HostBindings(rf, ctx) { if (rf & 2) {\r\n        ɵngcc0.ɵɵattribute(\"aria-label\", null)(\"aria-labelledby\", null)(\"aria-describedby\", null);\r\n    } }, exportAs: [\"matMenu\"], features: [ɵngcc0.ɵɵProvidersFeature([\r\n            { provide: MAT_MENU_PANEL, useExisting: MatMenu },\r\n        ]), ɵngcc0.ɵɵInheritDefinitionFeature], ngContentSelectors: _c1, decls: 1, vars: 0, consts: [[\"tabindex\", \"-1\", \"role\", \"menu\", 1, \"mat-menu-panel\", 3, \"id\", \"ngClass\", \"keydown\", \"click\"], [1, \"mat-menu-content\"]], template: function MatMenu_Template(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵprojectionDef();\r\n        ɵngcc0.ɵɵtemplate(0, MatMenu_ng_template_0_Template, 3, 6, \"ng-template\");\r\n    } }, directives: [ɵngcc3.NgClass], styles: [\"mat-menu{display:none}.mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0;min-height:64px}.mat-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-menu-panel{outline:solid 1px}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}.mat-menu-item[disabled]{pointer-events:none}.cdk-high-contrast-active .mat-menu-item{margin-top:1px}.cdk-high-contrast-active .mat-menu-item.cdk-program-focused,.cdk-high-contrast-active .mat-menu-item.cdk-keyboard-focused,.cdk-high-contrast-active .mat-menu-item-highlighted{outline:dotted 1px}.mat-menu-item-submenu-trigger{padding-right:32px}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}.mat-menu-submenu-icon{position:absolute;top:50%;right:16px;transform:translateY(-50%);width:5px;height:10px;fill:currentColor}[dir=rtl] .mat-menu-submenu-icon{right:auto;left:16px;transform:translateY(-50%) scaleX(-1)}.cdk-high-contrast-active .mat-menu-submenu-icon{fill:CanvasText}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\\n\"], encapsulation: 2, data: { animation: [\r\n            matMenuAnimations.transformMenu,\r\n            matMenuAnimations.fadeInItems\r\n        ] }, changeDetection: 0 });\r\nMatMenu.ctorParameters = () => [\r\n    { type: ElementRef },\r\n    { type: NgZone },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_DEFAULT_OPTIONS,] }] }\r\n];\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenu, [{\r\n        type: Component,\r\n        args: [{\r\n                selector: 'mat-menu',\r\n                template: \"<ng-template>\\n  <div\\n    class=\\\"mat-menu-panel\\\"\\n    [id]=\\\"panelId\\\"\\n    [ngClass]=\\\"_classList\\\"\\n    (keydown)=\\\"_handleKeydown($event)\\\"\\n    (click)=\\\"closed.emit('click')\\\"\\n    [@transformMenu]=\\\"_panelAnimationState\\\"\\n    (@transformMenu.start)=\\\"_onAnimationStart($event)\\\"\\n    (@transformMenu.done)=\\\"_onAnimationDone($event)\\\"\\n    tabindex=\\\"-1\\\"\\n    role=\\\"menu\\\"\\n    [attr.aria-label]=\\\"ariaLabel || null\\\"\\n    [attr.aria-labelledby]=\\\"ariaLabelledby || null\\\"\\n    [attr.aria-describedby]=\\\"ariaDescribedby || null\\\">\\n    <div class=\\\"mat-menu-content\\\">\\n      <ng-content></ng-content>\\n    </div>\\n  </div>\\n</ng-template>\\n\",\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                encapsulation: ViewEncapsulation.None,\r\n                exportAs: 'matMenu',\r\n                host: {\r\n                    '[attr.aria-label]': 'null',\r\n                    '[attr.aria-labelledby]': 'null',\r\n                    '[attr.aria-describedby]': 'null'\r\n                },\r\n                animations: [\r\n                    matMenuAnimations.transformMenu,\r\n                    matMenuAnimations.fadeInItems\r\n                ],\r\n                providers: [\r\n                    { provide: MAT_MENU_PANEL, useExisting: MatMenu },\r\n                ],\r\n                styles: [\"mat-menu{display:none}.mat-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;max-height:calc(100vh - 48px);border-radius:4px;outline:0;min-height:64px}.mat-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-menu-panel{outline:solid 1px}.mat-menu-content:not(:empty){padding-top:8px;padding-bottom:8px}.mat-menu-item{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:transparent;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:block;line-height:48px;height:48px;padding:0 16px;text-align:left;text-decoration:none;max-width:100%;position:relative}.mat-menu-item::-moz-focus-inner{border:0}.mat-menu-item[disabled]{cursor:default}[dir=rtl] .mat-menu-item{text-align:right}.mat-menu-item .mat-icon{margin-right:16px;vertical-align:middle}.mat-menu-item .mat-icon svg{vertical-align:top}[dir=rtl] .mat-menu-item .mat-icon{margin-left:16px;margin-right:0}.mat-menu-item[disabled]{pointer-events:none}.cdk-high-contrast-active .mat-menu-item{margin-top:1px}.cdk-high-contrast-active .mat-menu-item.cdk-program-focused,.cdk-high-contrast-active .mat-menu-item.cdk-keyboard-focused,.cdk-high-contrast-active .mat-menu-item-highlighted{outline:dotted 1px}.mat-menu-item-submenu-trigger{padding-right:32px}[dir=rtl] .mat-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}.mat-menu-submenu-icon{position:absolute;top:50%;right:16px;transform:translateY(-50%);width:5px;height:10px;fill:currentColor}[dir=rtl] .mat-menu-submenu-icon{right:auto;left:16px;transform:translateY(-50%) scaleX(-1)}.cdk-high-contrast-active .mat-menu-submenu-icon{fill:CanvasText}button.mat-menu-item{width:100%}.mat-menu-item .mat-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}\\n\"]\r\n            }]\r\n    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.NgZone }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [MAT_MENU_DEFAULT_OPTIONS]\r\n            }] }]; }, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n/** Injection token that determines the scroll handling while the menu is open. */\r\nconst MAT_MENU_SCROLL_STRATEGY = new InjectionToken('mat-menu-scroll-strategy');\r\n/** @docs-private */\r\nfunction MAT_MENU_SCROLL_STRATEGY_FACTORY(overlay) {\r\n    return () => overlay.scrollStrategies.reposition();\r\n}\r\n/** @docs-private */\r\nconst MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER = {\r\n    provide: MAT_MENU_SCROLL_STRATEGY,\r\n    deps: [Overlay],\r\n    useFactory: MAT_MENU_SCROLL_STRATEGY_FACTORY,\r\n};\r\n/** Default top padding of the menu panel. */\r\nconst MENU_PANEL_TOP_PADDING = 8;\r\n/** Options for binding a passive event listener. */\r\nconst passiveEventListenerOptions = normalizePassiveListenerOptions({ passive: true });\r\n// TODO(andrewseguin): Remove the kebab versions in favor of camelCased attribute selectors\r\nclass _MatMenuTriggerBase {\r\n    constructor(_overlay, _element, _viewContainerRef, scrollStrategy, parentMenu, \r\n    // `MatMenuTrigger` is commonly used in combination with a `MatMenuItem`.\r\n    // tslint:disable-next-line: lightweight-tokens\r\n    _menuItemInstance, _dir, \r\n    // TODO(crisbeto): make the _focusMonitor required when doing breaking changes.\r\n    // @breaking-change 8.0.0\r\n    _focusMonitor) {\r\n        this._overlay = _overlay;\r\n        this._element = _element;\r\n        this._viewContainerRef = _viewContainerRef;\r\n        this._menuItemInstance = _menuItemInstance;\r\n        this._dir = _dir;\r\n        this._focusMonitor = _focusMonitor;\r\n        this._overlayRef = null;\r\n        this._menuOpen = false;\r\n        this._closingActionsSubscription = Subscription.EMPTY;\r\n        this._hoverSubscription = Subscription.EMPTY;\r\n        this._menuCloseSubscription = Subscription.EMPTY;\r\n        /**\r\n         * Handles touch start events on the trigger.\r\n         * Needs to be an arrow function so we can easily use addEventListener and removeEventListener.\r\n         */\r\n        this._handleTouchStart = (event) => {\r\n            if (!isFakeTouchstartFromScreenReader(event)) {\r\n                this._openedBy = 'touch';\r\n            }\r\n        };\r\n        // Tracking input type is necessary so it's possible to only auto-focus\r\n        // the first item of the list when the menu is opened via the keyboard\r\n        this._openedBy = undefined;\r\n        this._ariaHaspopup = true;\r\n        /**\r\n         * Whether focus should be restored when the menu is closed.\r\n         * Note that disabling this option can have accessibility implications\r\n         * and it's up to you to manage focus, if you decide to turn it off.\r\n         */\r\n        this.restoreFocus = true;\r\n        /** Event emitted when the associated menu is opened. */\r\n        this.menuOpened = new EventEmitter();\r\n        /**\r\n         * Event emitted when the associated menu is opened.\r\n         * @deprecated Switch to `menuOpened` instead\r\n         * @breaking-change 8.0.0\r\n         */\r\n        // tslint:disable-next-line:no-output-on-prefix\r\n        this.onMenuOpen = this.menuOpened;\r\n        /** Event emitted when the associated menu is closed. */\r\n        this.menuClosed = new EventEmitter();\r\n        /**\r\n         * Event emitted when the associated menu is closed.\r\n         * @deprecated Switch to `menuClosed` instead\r\n         * @breaking-change 8.0.0\r\n         */\r\n        // tslint:disable-next-line:no-output-on-prefix\r\n        this.onMenuClose = this.menuClosed;\r\n        this._scrollStrategy = scrollStrategy;\r\n        this._parentMaterialMenu = parentMenu instanceof _MatMenuBase ? parentMenu : undefined;\r\n        _element.nativeElement.addEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);\r\n        if (_menuItemInstance) {\r\n            _menuItemInstance._triggersSubmenu = this.triggersSubmenu();\r\n        }\r\n    }\r\n    get _ariaExpanded() {\r\n        return this.menuOpen || null;\r\n    }\r\n    get _ariaControl() {\r\n        return this.menuOpen ? this.menu.panelId : null;\r\n    }\r\n    /**\r\n     * @deprecated\r\n     * @breaking-change 8.0.0\r\n     */\r\n    get _deprecatedMatMenuTriggerFor() { return this.menu; }\r\n    set _deprecatedMatMenuTriggerFor(v) {\r\n        this.menu = v;\r\n    }\r\n    /** References the menu instance that the trigger is associated with. */\r\n    get menu() { return this._menu; }\r\n    set menu(menu) {\r\n        if (menu === this._menu) {\r\n            return;\r\n        }\r\n        this._menu = menu;\r\n        this._menuCloseSubscription.unsubscribe();\r\n        if (menu) {\r\n            if (menu === this._parentMaterialMenu && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n                throwMatMenuRecursiveError();\r\n            }\r\n            this._menuCloseSubscription = menu.close.subscribe((reason) => {\r\n                this._destroyMenu(reason);\r\n                // If a click closed the menu, we should close the entire chain of nested menus.\r\n                if ((reason === 'click' || reason === 'tab') && this._parentMaterialMenu) {\r\n                    this._parentMaterialMenu.closed.emit(reason);\r\n                }\r\n            });\r\n        }\r\n    }\r\n    ngAfterContentInit() {\r\n        this._checkMenu();\r\n        this._handleHover();\r\n    }\r\n    ngOnDestroy() {\r\n        if (this._overlayRef) {\r\n            this._overlayRef.dispose();\r\n            this._overlayRef = null;\r\n        }\r\n        this._element.nativeElement.removeEventListener('touchstart', this._handleTouchStart, passiveEventListenerOptions);\r\n        this._menuCloseSubscription.unsubscribe();\r\n        this._closingActionsSubscription.unsubscribe();\r\n        this._hoverSubscription.unsubscribe();\r\n    }\r\n    /** Whether the menu is open. */\r\n    get menuOpen() {\r\n        return this._menuOpen;\r\n    }\r\n    /** The text direction of the containing app. */\r\n    get dir() {\r\n        return this._dir && this._dir.value === 'rtl' ? 'rtl' : 'ltr';\r\n    }\r\n    /** Whether the menu triggers a sub-menu or a top-level one. */\r\n    triggersSubmenu() {\r\n        return !!(this._menuItemInstance && this._parentMaterialMenu);\r\n    }\r\n    /** Toggles the menu between the open and closed states. */\r\n    toggleMenu() {\r\n        return this._menuOpen ? this.closeMenu() : this.openMenu();\r\n    }\r\n    /** Opens the menu. */\r\n    openMenu() {\r\n        if (this._menuOpen) {\r\n            return;\r\n        }\r\n        this._checkMenu();\r\n        const overlayRef = this._createOverlay();\r\n        const overlayConfig = overlayRef.getConfig();\r\n        this._setPosition(overlayConfig.positionStrategy);\r\n        overlayConfig.hasBackdrop = this.menu.hasBackdrop == null ? !this.triggersSubmenu() :\r\n            this.menu.hasBackdrop;\r\n        overlayRef.attach(this._getPortal());\r\n        if (this.menu.lazyContent) {\r\n            this.menu.lazyContent.attach(this.menuData);\r\n        }\r\n        this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this.closeMenu());\r\n        this._initMenu();\r\n        if (this.menu instanceof _MatMenuBase) {\r\n            this.menu._startAnimation();\r\n        }\r\n    }\r\n    /** Closes the menu. */\r\n    closeMenu() {\r\n        this.menu.close.emit();\r\n    }\r\n    /**\r\n     * Focuses the menu trigger.\r\n     * @param origin Source of the menu trigger's focus.\r\n     */\r\n    focus(origin, options) {\r\n        if (this._focusMonitor && origin) {\r\n            this._focusMonitor.focusVia(this._element, origin, options);\r\n        }\r\n        else {\r\n            this._element.nativeElement.focus(options);\r\n        }\r\n    }\r\n    /**\r\n     * Updates the position of the menu to ensure that it fits all options within the viewport.\r\n     */\r\n    updatePosition() {\r\n        var _a;\r\n        (_a = this._overlayRef) === null || _a === void 0 ? void 0 : _a.updatePosition();\r\n    }\r\n    /** Closes the menu and does the necessary cleanup. */\r\n    _destroyMenu(reason) {\r\n        if (!this._overlayRef || !this.menuOpen) {\r\n            return;\r\n        }\r\n        const menu = this.menu;\r\n        this._closingActionsSubscription.unsubscribe();\r\n        this._overlayRef.detach();\r\n        // Always restore focus if the user is navigating using the keyboard or the menu was opened\r\n        // programmatically. We don't restore for non-root triggers, because it can prevent focus\r\n        // from making it back to the root trigger when closing a long chain of menus by clicking\r\n        // on the backdrop.\r\n        if (this.restoreFocus && (reason === 'keydown' || !this._openedBy || !this.triggersSubmenu())) {\r\n            this.focus(this._openedBy);\r\n        }\r\n        this._openedBy = undefined;\r\n        if (menu instanceof _MatMenuBase) {\r\n            menu._resetAnimation();\r\n            if (menu.lazyContent) {\r\n                // Wait for the exit animation to finish before detaching the content.\r\n                menu._animationDone\r\n                    .pipe(filter(event => event.toState === 'void'), take(1), \r\n                // Interrupt if the content got re-attached.\r\n                takeUntil(menu.lazyContent._attached))\r\n                    .subscribe({\r\n                    next: () => menu.lazyContent.detach(),\r\n                    // No matter whether the content got re-attached, reset the menu.\r\n                    complete: () => this._setIsMenuOpen(false)\r\n                });\r\n            }\r\n            else {\r\n                this._setIsMenuOpen(false);\r\n            }\r\n        }\r\n        else {\r\n            this._setIsMenuOpen(false);\r\n            if (menu.lazyContent) {\r\n                menu.lazyContent.detach();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * This method sets the menu state to open and focuses the first item if\r\n     * the menu was opened via the keyboard.\r\n     */\r\n    _initMenu() {\r\n        this.menu.parentMenu = this.triggersSubmenu() ? this._parentMaterialMenu : undefined;\r\n        this.menu.direction = this.dir;\r\n        this._setMenuElevation();\r\n        this.menu.focusFirstItem(this._openedBy || 'program');\r\n        this._setIsMenuOpen(true);\r\n    }\r\n    /** Updates the menu elevation based on the amount of parent menus that it has. */\r\n    _setMenuElevation() {\r\n        if (this.menu.setElevation) {\r\n            let depth = 0;\r\n            let parentMenu = this.menu.parentMenu;\r\n            while (parentMenu) {\r\n                depth++;\r\n                parentMenu = parentMenu.parentMenu;\r\n            }\r\n            this.menu.setElevation(depth);\r\n        }\r\n    }\r\n    // set state rather than toggle to support triggers sharing a menu\r\n    _setIsMenuOpen(isOpen) {\r\n        this._menuOpen = isOpen;\r\n        this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit();\r\n        if (this.triggersSubmenu()) {\r\n            this._menuItemInstance._setHighlighted(isOpen);\r\n        }\r\n    }\r\n    /**\r\n     * This method checks that a valid instance of MatMenu has been passed into\r\n     * matMenuTriggerFor. If not, an exception is thrown.\r\n     */\r\n    _checkMenu() {\r\n        if (!this.menu && (typeof ngDevMode === 'undefined' || ngDevMode)) {\r\n            throwMatMenuMissingError();\r\n        }\r\n    }\r\n    /**\r\n     * This method creates the overlay from the provided menu's template and saves its\r\n     * OverlayRef so that it can be attached to the DOM when openMenu is called.\r\n     */\r\n    _createOverlay() {\r\n        if (!this._overlayRef) {\r\n            const config = this._getOverlayConfig();\r\n            this._subscribeToPositions(config.positionStrategy);\r\n            this._overlayRef = this._overlay.create(config);\r\n            // Consume the `keydownEvents` in order to prevent them from going to another overlay.\r\n            // Ideally we'd also have our keyboard event logic in here, however doing so will\r\n            // break anybody that may have implemented the `MatMenuPanel` themselves.\r\n            this._overlayRef.keydownEvents().subscribe();\r\n        }\r\n        return this._overlayRef;\r\n    }\r\n    /**\r\n     * This method builds the configuration object needed to create the overlay, the OverlayState.\r\n     * @returns OverlayConfig\r\n     */\r\n    _getOverlayConfig() {\r\n        return new OverlayConfig({\r\n            positionStrategy: this._overlay.position()\r\n                .flexibleConnectedTo(this._element)\r\n                .withLockedPosition()\r\n                .withGrowAfterOpen()\r\n                .withTransformOriginOn('.mat-menu-panel, .mat-mdc-menu-panel'),\r\n            backdropClass: this.menu.backdropClass || 'cdk-overlay-transparent-backdrop',\r\n            panelClass: this.menu.overlayPanelClass,\r\n            scrollStrategy: this._scrollStrategy(),\r\n            direction: this._dir\r\n        });\r\n    }\r\n    /**\r\n     * Listens to changes in the position of the overlay and sets the correct classes\r\n     * on the menu based on the new position. This ensures the animation origin is always\r\n     * correct, even if a fallback position is used for the overlay.\r\n     */\r\n    _subscribeToPositions(position) {\r\n        if (this.menu.setPositionClasses) {\r\n            position.positionChanges.subscribe(change => {\r\n                const posX = change.connectionPair.overlayX === 'start' ? 'after' : 'before';\r\n                const posY = change.connectionPair.overlayY === 'top' ? 'below' : 'above';\r\n                this.menu.setPositionClasses(posX, posY);\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Sets the appropriate positions on a position strategy\r\n     * so the overlay connects with the trigger correctly.\r\n     * @param positionStrategy Strategy whose position to update.\r\n     */\r\n    _setPosition(positionStrategy) {\r\n        let [originX, originFallbackX] = this.menu.xPosition === 'before' ? ['end', 'start'] : ['start', 'end'];\r\n        let [overlayY, overlayFallbackY] = this.menu.yPosition === 'above' ? ['bottom', 'top'] : ['top', 'bottom'];\r\n        let [originY, originFallbackY] = [overlayY, overlayFallbackY];\r\n        let [overlayX, overlayFallbackX] = [originX, originFallbackX];\r\n        let offsetY = 0;\r\n        if (this.triggersSubmenu()) {\r\n            // When the menu is a sub-menu, it should always align itself\r\n            // to the edges of the trigger, instead of overlapping it.\r\n            overlayFallbackX = originX = this.menu.xPosition === 'before' ? 'start' : 'end';\r\n            originFallbackX = overlayX = originX === 'end' ? 'start' : 'end';\r\n            offsetY = overlayY === 'bottom' ? MENU_PANEL_TOP_PADDING : -MENU_PANEL_TOP_PADDING;\r\n        }\r\n        else if (!this.menu.overlapTrigger) {\r\n            originY = overlayY === 'top' ? 'bottom' : 'top';\r\n            originFallbackY = overlayFallbackY === 'top' ? 'bottom' : 'top';\r\n        }\r\n        positionStrategy.withPositions([\r\n            { originX, originY, overlayX, overlayY, offsetY },\r\n            { originX: originFallbackX, originY, overlayX: overlayFallbackX, overlayY, offsetY },\r\n            {\r\n                originX,\r\n                originY: originFallbackY,\r\n                overlayX,\r\n                overlayY: overlayFallbackY,\r\n                offsetY: -offsetY\r\n            },\r\n            {\r\n                originX: originFallbackX,\r\n                originY: originFallbackY,\r\n                overlayX: overlayFallbackX,\r\n                overlayY: overlayFallbackY,\r\n                offsetY: -offsetY\r\n            }\r\n        ]);\r\n    }\r\n    /** Returns a stream that emits whenever an action that should close the menu occurs. */\r\n    _menuClosingActions() {\r\n        const backdrop = this._overlayRef.backdropClick();\r\n        const detachments = this._overlayRef.detachments();\r\n        const parentClose = this._parentMaterialMenu ? this._parentMaterialMenu.closed : of();\r\n        const hover = this._parentMaterialMenu ? this._parentMaterialMenu._hovered().pipe(filter(active => active !== this._menuItemInstance), filter(() => this._menuOpen)) : of();\r\n        return merge(backdrop, parentClose, hover, detachments);\r\n    }\r\n    /** Handles mouse presses on the trigger. */\r\n    _handleMousedown(event) {\r\n        if (!isFakeMousedownFromScreenReader(event)) {\r\n            // Since right or middle button clicks won't trigger the `click` event,\r\n            // we shouldn't consider the menu as opened by mouse in those cases.\r\n            this._openedBy = event.button === 0 ? 'mouse' : undefined;\r\n            // Since clicking on the trigger won't close the menu if it opens a sub-menu,\r\n            // we should prevent focus from moving onto it via click to avoid the\r\n            // highlight from lingering on the menu item.\r\n            if (this.triggersSubmenu()) {\r\n                event.preventDefault();\r\n            }\r\n        }\r\n    }\r\n    /** Handles key presses on the trigger. */\r\n    _handleKeydown(event) {\r\n        const keyCode = event.keyCode;\r\n        // Pressing enter on the trigger will trigger the click handler later.\r\n        if (keyCode === ENTER || keyCode === SPACE) {\r\n            this._openedBy = 'keyboard';\r\n        }\r\n        if (this.triggersSubmenu() && ((keyCode === RIGHT_ARROW && this.dir === 'ltr') ||\r\n            (keyCode === LEFT_ARROW && this.dir === 'rtl'))) {\r\n            this._openedBy = 'keyboard';\r\n            this.openMenu();\r\n        }\r\n    }\r\n    /** Handles click events on the trigger. */\r\n    _handleClick(event) {\r\n        if (this.triggersSubmenu()) {\r\n            // Stop event propagation to avoid closing the parent menu.\r\n            event.stopPropagation();\r\n            this.openMenu();\r\n        }\r\n        else {\r\n            this.toggleMenu();\r\n        }\r\n    }\r\n    /** Handles the cases where the user hovers over the trigger. */\r\n    _handleHover() {\r\n        // Subscribe to changes in the hovered item in order to toggle the panel.\r\n        if (!this.triggersSubmenu() || !this._parentMaterialMenu) {\r\n            return;\r\n        }\r\n        this._hoverSubscription = this._parentMaterialMenu._hovered()\r\n            // Since we might have multiple competing triggers for the same menu (e.g. a sub-menu\r\n            // with different data and triggers), we have to delay it by a tick to ensure that\r\n            // it won't be closed immediately after it is opened.\r\n            .pipe(filter(active => active === this._menuItemInstance && !active.disabled), delay(0, asapScheduler))\r\n            .subscribe(() => {\r\n            this._openedBy = 'mouse';\r\n            // If the same menu is used between multiple triggers, it might still be animating\r\n            // while the new trigger tries to re-open it. Wait for the animation to finish\r\n            // before doing so. Also interrupt if the user moves to another item.\r\n            if (this.menu instanceof _MatMenuBase && this.menu._isAnimating) {\r\n                // We need the `delay(0)` here in order to avoid\r\n                // 'changed after checked' errors in some cases. See #12194.\r\n                this.menu._animationDone\r\n                    .pipe(take(1), delay(0, asapScheduler), takeUntil(this._parentMaterialMenu._hovered()))\r\n                    .subscribe(() => this.openMenu());\r\n            }\r\n            else {\r\n                this.openMenu();\r\n            }\r\n        });\r\n    }\r\n    /** Gets the portal that should be attached to the overlay. */\r\n    _getPortal() {\r\n        // Note that we can avoid this check by keeping the portal on the menu panel.\r\n        // While it would be cleaner, we'd have to introduce another required method on\r\n        // `MatMenuPanel`, making it harder to consume.\r\n        if (!this._portal || this._portal.templateRef !== this.menu.templateRef) {\r\n            this._portal = new TemplatePortal(this.menu.templateRef, this._viewContainerRef);\r\n        }\r\n        return this._portal;\r\n    }\r\n}\r\n_MatMenuTriggerBase.ɵfac = function _MatMenuTriggerBase_Factory(t) { return new (t || _MatMenuTriggerBase)(ɵngcc0.ɵɵdirectiveInject(ɵngcc4.Overlay), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_SCROLL_STRATEGY), ɵngcc0.ɵɵdirectiveInject(MAT_MENU_PANEL, 8), ɵngcc0.ɵɵdirectiveInject(MatMenuItem, 10), ɵngcc0.ɵɵdirectiveInject(ɵngcc5.Directionality, 8), ɵngcc0.ɵɵdirectiveInject(ɵngcc1.FocusMonitor)); };\r\n_MatMenuTriggerBase.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: _MatMenuTriggerBase, hostVars: 3, hostBindings: function _MatMenuTriggerBase_HostBindings(rf, ctx) { if (rf & 1) {\r\n        ɵngcc0.ɵɵlistener(\"mousedown\", function _MatMenuTriggerBase_mousedown_HostBindingHandler($event) { return ctx._handleMousedown($event); })(\"keydown\", function _MatMenuTriggerBase_keydown_HostBindingHandler($event) { return ctx._handleKeydown($event); })(\"click\", function _MatMenuTriggerBase_click_HostBindingHandler($event) { return ctx._handleClick($event); });\r\n    } if (rf & 2) {\r\n        ɵngcc0.ɵɵattribute(\"aria-haspopup\", ctx._ariaHaspopup)(\"aria-expanded\", ctx._ariaExpanded)(\"aria-controls\", ctx._ariaControl);\r\n    } }, inputs: { restoreFocus: [\"matMenuTriggerRestoreFocus\", \"restoreFocus\"], _deprecatedMatMenuTriggerFor: [\"mat-menu-trigger-for\", \"_deprecatedMatMenuTriggerFor\"], menu: [\"matMenuTriggerFor\", \"menu\"], menuData: [\"matMenuTriggerData\", \"menuData\"] }, outputs: { menuOpened: \"menuOpened\", onMenuOpen: \"onMenuOpen\", menuClosed: \"menuClosed\", onMenuClose: \"onMenuClose\" } });\r\n_MatMenuTriggerBase.ctorParameters = () => [\r\n    { type: Overlay },\r\n    { type: ElementRef },\r\n    { type: ViewContainerRef },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_SCROLL_STRATEGY,] }] },\r\n    { type: undefined, decorators: [{ type: Inject, args: [MAT_MENU_PANEL,] }, { type: Optional }] },\r\n    { type: MatMenuItem, decorators: [{ type: Optional }, { type: Self }] },\r\n    { type: Directionality, decorators: [{ type: Optional }] },\r\n    { type: FocusMonitor }\r\n];\r\n_MatMenuTriggerBase.propDecorators = {\r\n    _ariaExpanded: [{ type: HostBinding, args: ['attr.aria-expanded',] }],\r\n    _ariaControl: [{ type: HostBinding, args: ['attr.aria-controls',] }],\r\n    _ariaHaspopup: [{ type: HostBinding, args: ['attr.aria-haspopup',] }],\r\n    _deprecatedMatMenuTriggerFor: [{ type: Input, args: ['mat-menu-trigger-for',] }],\r\n    menu: [{ type: Input, args: ['matMenuTriggerFor',] }],\r\n    menuData: [{ type: Input, args: ['matMenuTriggerData',] }],\r\n    restoreFocus: [{ type: Input, args: ['matMenuTriggerRestoreFocus',] }],\r\n    menuOpened: [{ type: Output }],\r\n    onMenuOpen: [{ type: Output }],\r\n    menuClosed: [{ type: Output }],\r\n    onMenuClose: [{ type: Output }],\r\n    _handleMousedown: [{ type: HostListener, args: ['mousedown', ['$event'],] }],\r\n    _handleKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],\r\n    _handleClick: [{ type: HostListener, args: ['click', ['$event'],] }]\r\n};\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(_MatMenuTriggerBase, [{\r\n        type: Directive\r\n    }], function () { return [{ type: ɵngcc4.Overlay }, { type: ɵngcc0.ElementRef }, { type: ɵngcc0.ViewContainerRef }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [MAT_MENU_SCROLL_STRATEGY]\r\n            }] }, { type: undefined, decorators: [{\r\n                type: Inject,\r\n                args: [MAT_MENU_PANEL]\r\n            }, {\r\n                type: Optional\r\n            }] }, { type: MatMenuItem, decorators: [{\r\n                type: Optional\r\n            }, {\r\n                type: Self\r\n            }] }, { type: ɵngcc5.Directionality, decorators: [{\r\n                type: Optional\r\n            }] }, { type: ɵngcc1.FocusMonitor }]; }, { _ariaHaspopup: [{\r\n            type: HostBinding,\r\n            args: ['attr.aria-haspopup']\r\n        }], restoreFocus: [{\r\n            type: Input,\r\n            args: ['matMenuTriggerRestoreFocus']\r\n        }], menuOpened: [{\r\n            type: Output\r\n        }], onMenuOpen: [{\r\n            type: Output\r\n        }], menuClosed: [{\r\n            type: Output\r\n        }], onMenuClose: [{\r\n            type: Output\r\n        }], _ariaExpanded: [{\r\n            type: HostBinding,\r\n            args: ['attr.aria-expanded']\r\n        }], _ariaControl: [{\r\n            type: HostBinding,\r\n            args: ['attr.aria-controls']\r\n        }], _deprecatedMatMenuTriggerFor: [{\r\n            type: Input,\r\n            args: ['mat-menu-trigger-for']\r\n        }], menu: [{\r\n            type: Input,\r\n            args: ['matMenuTriggerFor']\r\n        }], \r\n    /** Handles mouse presses on the trigger. */\r\n    _handleMousedown: [{\r\n            type: HostListener,\r\n            args: ['mousedown', ['$event']]\r\n        }], \r\n    /** Handles key presses on the trigger. */\r\n    _handleKeydown: [{\r\n            type: HostListener,\r\n            args: ['keydown', ['$event']]\r\n        }], \r\n    /** Handles click events on the trigger. */\r\n    _handleClick: [{\r\n            type: HostListener,\r\n            args: ['click', ['$event']]\r\n        }], menuData: [{\r\n            type: Input,\r\n            args: ['matMenuTriggerData']\r\n        }] }); })();\r\n/** Directive applied to an element that should trigger a `mat-menu`. */\r\nclass MatMenuTrigger extends _MatMenuTriggerBase {\r\n}\r\nMatMenuTrigger.ɵfac = /*@__PURE__*/ function () { let ɵMatMenuTrigger_BaseFactory; return function MatMenuTrigger_Factory(t) { return (ɵMatMenuTrigger_BaseFactory || (ɵMatMenuTrigger_BaseFactory = ɵngcc0.ɵɵgetInheritedFactory(MatMenuTrigger)))(t || MatMenuTrigger); }; }();\r\nMatMenuTrigger.ɵdir = /*@__PURE__*/ ɵngcc0.ɵɵdefineDirective({ type: MatMenuTrigger, selectors: [[\"\", \"mat-menu-trigger-for\", \"\"], [\"\", \"matMenuTriggerFor\", \"\"]], hostAttrs: [1, \"mat-menu-trigger\"], exportAs: [\"matMenuTrigger\"], features: [ɵngcc0.ɵɵInheritDefinitionFeature] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuTrigger, [{\r\n        type: Directive,\r\n        args: [{\r\n                selector: `[mat-menu-trigger-for], [matMenuTriggerFor]`,\r\n                host: {\r\n                    'class': 'mat-menu-trigger'\r\n                },\r\n                exportAs: 'matMenuTrigger'\r\n            }]\r\n    }], null, null); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\nclass MatMenuModule {\r\n}\r\nMatMenuModule.ɵfac = function MatMenuModule_Factory(t) { return new (t || MatMenuModule)(); };\r\nMatMenuModule.ɵmod = /*@__PURE__*/ ɵngcc0.ɵɵdefineNgModule({ type: MatMenuModule });\r\nMatMenuModule.ɵinj = /*@__PURE__*/ ɵngcc0.ɵɵdefineInjector({ providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER], imports: [[\r\n            CommonModule,\r\n            MatCommonModule,\r\n            MatRippleModule,\r\n            OverlayModule,\r\n        ], CdkScrollableModule,\r\n        MatCommonModule] });\r\n(function () { (typeof ngDevMode === \"undefined\" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(MatMenuModule, [{\r\n        type: NgModule,\r\n        args: [{\r\n                imports: [\r\n                    CommonModule,\r\n                    MatCommonModule,\r\n                    MatRippleModule,\r\n                    OverlayModule,\r\n                ],\r\n                exports: [\r\n                    CdkScrollableModule,\r\n                    MatCommonModule,\r\n                    MatMenu,\r\n                    MatMenuItem,\r\n                    MatMenuTrigger,\r\n                    MatMenuContent\r\n                ],\r\n                declarations: [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent],\r\n                providers: [MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER]\r\n            }]\r\n    }], null, null); })();\r\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatMenuModule, { declarations: function () { return [MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent]; }, imports: function () { return [CommonModule,\r\n        MatCommonModule,\r\n        MatRippleModule,\r\n        OverlayModule]; }, exports: function () { return [CdkScrollableModule,\r\n        MatCommonModule, MatMenu, MatMenuItem, MatMenuTrigger, MatMenuContent]; } }); })();\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * @license\r\n * Copyright Google LLC All Rights Reserved.\r\n *\r\n * Use of this source code is governed by an MIT-style license that can be\r\n * found in the LICENSE file at https://angular.io/license\r\n */\r\n\r\n/**\r\n * Generated bundle index. Do not edit.\r\n */\r\n\r\nexport { MAT_MENU_CONTENT, MAT_MENU_DEFAULT_OPTIONS, MAT_MENU_PANEL, MAT_MENU_SCROLL_STRATEGY, MatMenu, MatMenuContent, MatMenuItem, MatMenuModule, MatMenuTrigger, _MatMenuBase, _MatMenuContentBase, _MatMenuTriggerBase, fadeInItems, matMenuAnimations, transformMenu, MAT_MENU_DEFAULT_OPTIONS_FACTORY as ɵangular_material_src_material_menu_menu_a, MAT_MENU_SCROLL_STRATEGY_FACTORY as ɵangular_material_src_material_menu_menu_b, MAT_MENU_SCROLL_STRATEGY_FACTORY_PROVIDER as ɵangular_material_src_material_menu_menu_c };\r\n\r\n//# sourceMappingURL=menu.js.map"],"sourceRoot":"webpack:///"}